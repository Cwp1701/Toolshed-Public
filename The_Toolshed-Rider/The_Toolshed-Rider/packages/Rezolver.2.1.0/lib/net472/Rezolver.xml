<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rezolver</name>
    </assembly>
    <members>
        <member name="T:Rezolver.ArrayTargetContainer">
            <summary>
            Inheriting from TargetDictionary allows the container to support direct registrations
            for concrete array types.
            </summary>
        </member>
        <member name="T:Rezolver.BindAllMembersBehaviour">
             <summary>
             This implementation of <see cref="T:Rezolver.IMemberBindingBehaviour"/> binds all publicly writable
             properties and public fields to values obtained from the container.
             </summary>
             <seealso cref="T:Rezolver.IMemberBindingBehaviour" />
             <remarks>This is a stateless singleton accessible through the <see cref="P:Rezolver.MemberBindingBehaviour.BindAll"/>
             static property.
            
             The class also serves as a good starting point for any custom binding behaviours you might need - as there
             are numerous virtual methods which allow you to change which fields and/or properties are selected for binding,
             as well as how those bindings are created.
            
             The default behaviour is to bind each member to a new <see cref="T:Rezolver.Targets.ResolvedTarget"/> whose
             <see cref="P:Rezolver.Targets.ResolvedTarget.DeclaredType"/> is set to the member's type.
             
             See the [member binding guide](/developers/docs/member-injection/index.html) for more.
             </remarks>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.#ctor">
             <summary>
             Initializes a new instance of the <see cref="T:Rezolver.BindAllMembersBehaviour"/> class.
            
             Can only be created by Rezolver or through inheritance.
             </summary>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.IMemberBindingBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)"/>.
            </summary>
            <param name="context">The current compilation context.</param>
            <param name="type">The type whose members are to be bound.</param>
            <remarks>The base implementation calls <see cref="M:Rezolver.BindAllMembersBehaviour.GetBindableProperties(Rezolver.Compilation.ICompileContext,System.Type)"/>, passing the resultant enumerable to
            the <see cref="M:Rezolver.BindAllMembersBehaviour.BindProperties(Rezolver.Compilation.ICompileContext,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})"/> function; it also does the same thing with
            <see cref="M:Rezolver.BindAllMembersBehaviour.GetBindableFields(Rezolver.Compilation.ICompileContext,System.Type)"/> and <see cref="M:Rezolver.BindAllMembersBehaviour.BindFields(Rezolver.Compilation.ICompileContext,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.FieldInfo})"/> -
            concatenating the two enumerables together and returning the result as an array of <see cref="T:Rezolver.MemberBinding"/> objects.</remarks>
            <returns>Bindings for all bindable properties and fields.</returns>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.BindFields(Rezolver.Compilation.ICompileContext,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.FieldInfo})">
            <summary>
            Called by <see cref="M:Rezolver.BindAllMembersBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)"/> - iterates through the
            <paramref name="fields"/>, calling <see cref="M:Rezolver.BindAllMembersBehaviour.CreateBinding(Rezolver.Compilation.ICompileContext,System.Type,System.Reflection.FieldInfo)"/> for each,
            and those which are non-null.
            </summary>
            <param name="context">The current compilation context.</param>
            <param name="type">The type whose members are to be bound.</param>
            <param name="fields">The fields for which bindings are to be created.  This is fed by
            the function <see cref="M:Rezolver.BindAllMembersBehaviour.GetBindableFields(Rezolver.Compilation.ICompileContext,System.Type)"/></param>
            <returns>An enumerable containing bindings for each of the passed <paramref name="fields"></paramref></returns>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.BindProperties(Rezolver.Compilation.ICompileContext,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})">
            <summary>
            Called by <see cref="M:Rezolver.BindAllMembersBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)"/> - iterates through the
            <paramref name="properties"/>, calling <see cref="M:Rezolver.BindAllMembersBehaviour.CreateBinding(Rezolver.Compilation.ICompileContext,System.Type,System.Reflection.PropertyInfo)"/> for each,
            and those which are non-null.
            </summary>
            <param name="context">The current compilation context.</param>
            <param name="type">The type whose members are to be bound.</param>
            <param name="properties">The properties for which bindings are to be created.  This is fed by
            the function <see cref="M:Rezolver.BindAllMembersBehaviour.GetBindableProperties(Rezolver.Compilation.ICompileContext,System.Type)"/></param>
            <returns>An enumerable of <see cref="T:Rezolver.MemberBinding"/> objects representing the bindings to be used
            for each bindable property in <paramref name="properties"/>.</returns>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.CreateBinding(Rezolver.Compilation.ICompileContext,System.Type,System.Reflection.FieldInfo)">
             <summary>
             Creates a binding for the given field.
            
             Called by <see cref="M:Rezolver.BindAllMembersBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)"/>
             </summary>
             <param name="context">The current compilation context.</param>
             <param name="type">The type whose members are to be bound.</param>
             <param name="field">The field for which a binding is to be created.</param>
             <remarks>Override this method to customise the binding that is create for the given
             field, or to prevent the binding from being created at all(return <c>null</c> if you want
             to abort binding the field).
            
             The base implementation simply creates a new <see cref="T:Rezolver.MemberBinding"/> whose
             <see cref="P:Rezolver.MemberBinding.Target"/> is set to a new <see cref="T:Rezolver.Targets.ResolvedTarget"/> for the type
             <see cref="P:System.Reflection.FieldInfo.FieldType"/> - thus causing the field to be assigned a value
             resolved from the container when the instance is created.</remarks>
             <returns>An individual binding for the passed <paramref name="field"/></returns>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.CreateBinding(Rezolver.Compilation.ICompileContext,System.Type,System.Reflection.PropertyInfo)">
             <summary>
             Creates a binding for the given property.
            
             Called by <see cref="M:Rezolver.BindAllMembersBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)"/>
             </summary>
             <param name="context">The current compilation context.</param>
             <param name="type">The type whose members are to be bound.</param>
             <param name="prop">The property for which a binding is to be created.</param>
             <remarks>Override this method to customise the binding that is create for the given
             property, or to prevent the binding from being created at all(return <c>null</c> if you want
             to abort binding the property).
            
             The base will create a <see cref="T:Rezolver.MemberBinding"/> for publicly writable properties; and a
             <see cref="T:Rezolver.ListMemberBinding"/> for publicly readable properties which follow the rules
             for types supporting .Net's collection initialisers
             https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#collection-initializers</remarks>
             <returns>An individual binding for the passed <paramref name="prop"/></returns>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.GetBindableFields(Rezolver.Compilation.ICompileContext,System.Type)">
             <summary>
             Gets the bindable fields on the <paramref name="type"/>.
            
             Used by <see cref="M:Rezolver.BindAllMembersBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)"/> and passed to the
             <see cref="M:Rezolver.BindAllMembersBehaviour.BindFields(Rezolver.Compilation.ICompileContext,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.FieldInfo})"/> method.
             </summary>
             <param name="context">The current compilation context.</param>
             <param name="type">The type whose members are to be bound.</param>
             <remarks>Override this method to filter the fields which can be bound.  The base implementation
             returns all public instance fields declared on the <paramref name="type"/>.
             </remarks>
             <returns>An enumerable of the fields that can be bound on the given <paramref name="type"/></returns>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.GetBindableProperties(Rezolver.Compilation.ICompileContext,System.Type)">
             <summary>
             Gets the bindable properties on the <paramref name="type"/>.
            
             Used by <see cref="M:Rezolver.BindAllMembersBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)"/> and passed to the
             <see cref="M:Rezolver.BindAllMembersBehaviour.BindProperties(Rezolver.Compilation.ICompileContext,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})"/> method.
             </summary>
             <param name="context">The current compilation context.</param>
             <param name="type">The type whose members are to be bound.</param>
             <remarks>Override this method to filter the properties which can be bound.  The base implementation
             returns all non-indexer instance properties which have publicly accessible 'set' accessors.</remarks>
             <returns>An enumerable of the properties that can be bound on the given <paramref name="type"/></returns>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.ShouldBind(System.Reflection.PropertyInfo)">
             <summary>
             Used by default by the <see cref="M:Rezolver.BindAllMembersBehaviour.GetBindableProperties(Rezolver.Compilation.ICompileContext,System.Type)"/> method to filter all
             instance properties on a type which can be bound.
            
             Returns true if the property does not have an index and is either publicly writable, or is a bindable collection
             type.  The latter follows the same rules as .Net collection initialisers,
             described here https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#collection-initializers
             </summary>
             <param name="pi">The <see cref="T:System.Reflection.PropertyInfo"/> of the property to be checked.</param>
             <returns><c>true</c> if the property <paramref name="pi"/> should be bound.</returns>
        </member>
        <member name="M:Rezolver.BindAllMembersBehaviour.ShouldBind(System.Reflection.FieldInfo)">
            <summary>
            Used by default by the <see cref="M:Rezolver.BindAllMembersBehaviour.GetBindableFields(Rezolver.Compilation.ICompileContext,System.Type)"/> method to filter all
            the instance fields down to those which should be bound.
            </summary>
            <param name="fi">The <see cref="T:System.Reflection.FieldInfo"/> of the property to be checked.</param>
            <returns><c>true</c> if the field <paramref name="fi"/> should be bound.</returns>
        </member>
        <member name="T:Rezolver.BindNoMembersBehaviour">
            <summary>
            This is the default <see cref="T:Rezolver.IMemberBindingBehaviour"/> which doesn't bind any members.  It's
            a singleton accessible only via the <see cref="P:Rezolver.MemberBindingBehaviour.BindNone"/> static property.
            </summary>
            <remarks>
            See the [member binding guide](/developers/docs/member-injection/index.html) for more.
            </remarks>
        </member>
        <member name="M:Rezolver.BindNoMembersBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)">
             <summary>
             Implementation of <see cref="M:Rezolver.IMemberBindingBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)"/>
            
             Always returns an empty array.
             </summary>
             <param name="context"></param>
             <param name="type"></param>
             <returns></returns>
        </member>
        <member name="T:Rezolver.BindPublicFieldsBehaviour">
            <summary>
            An <see cref="T:Rezolver.IMemberBindingBehaviour"/> which binds all public instance fields
            on new instances to services from the container.
            </summary>
            <remarks>
            See the [member binding guide](/developers/docs/member-injection/index.html) for more.
            </remarks>
        </member>
        <member name="M:Rezolver.BindPublicFieldsBehaviour.#ctor">
             <summary>
             Creates a new instance of the <see cref="T:Rezolver.BindPublicFieldsBehaviour"/> class.
            
             Can only be created by Rezolver or through inheritance.
             </summary>
        </member>
        <member name="M:Rezolver.BindPublicFieldsBehaviour.GetBindableProperties(Rezolver.Compilation.ICompileContext,System.Type)">
            <summary>
            Overrides the base class to avoid returning any properties.
            </summary>
            <param name="context">The compile context</param>
            <param name="type">The type to be bound.</param>
            <returns>Always returns an empty <see cref="T:System.Collections.Generic.IEnumerable`1"/></returns>
        </member>
        <member name="T:Rezolver.BindPublicPropertiesBehaviour">
            <summary>
            An <see cref="T:Rezolver.IMemberBindingBehaviour"/> which binds all non-indexer publicly writeable instance
            properties on new instances to services from the container.
            </summary>
            <remarks>
            See the [member binding guide](/developers/docs/member-injection/index.html) for more.
            </remarks>
        </member>
        <member name="M:Rezolver.BindPublicPropertiesBehaviour.#ctor">
             <summary>
             Creates a new instance of the <see cref="T:Rezolver.BindPublicPropertiesBehaviour"/> class
            
             Can only be created by Rezolver or through inheritance.
             </summary>
        </member>
        <member name="M:Rezolver.BindPublicPropertiesBehaviour.GetBindableFields(Rezolver.Compilation.ICompileContext,System.Type)">
            <summary>
            Overrides the base class to avoid returning any fields.
            </summary>
            <param name="context">The compile context</param>
            <param name="type">The type to be bound.</param>
            <returns>Always returns an empty <see cref="T:System.Collections.Generic.IEnumerable`1"/></returns>
        </member>
        <member name="T:Rezolver.BindSpecificMembersBehaviour">
            <summary>
            Overrides the <see cref="T:Rezolver.BindAllMembersBehaviour"/> to provide explicit per-member bindings.
            </summary>
            <remarks>
            See [the fluent API documentation](/developers/docs/member-injection/fluent-api.html) for more.
            </remarks>
        </member>
        <member name="M:Rezolver.BindSpecificMembersBehaviour.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.BindSpecificMembersBehaviour"/> class
            which will auto-bind only those members which are passed in the <paramref name="members"/> enumerable.
            </summary>
            <param name="members">An enumerable of members to be bound on new instances.  When an instance is created, those
            members will be auto-bound by resolving instances of the associated member types.</param>
        </member>
        <member name="M:Rezolver.BindSpecificMembersBehaviour.#ctor(System.Collections.Generic.IEnumerable{Rezolver.MemberBinding})">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.BindSpecificMembersBehaviour"/> class which will apply only those bindings
            which are passed in the <paramref name="memberBindings"/> enumerable.
            </summary>
            <param name="memberBindings">An enumerable of bindings to be applied to members of newly created objects.</param>
        </member>
        <member name="M:Rezolver.BindSpecificMembersBehaviour.ShouldBind(System.Reflection.PropertyInfo)">
            <summary>
            Overrides the base method to return <c>true</c> only for those members which were supplied on construction.
            </summary>
            <param name="pi">A property that is potentially to be bound.</param>
            <returns>A boolean indicating whether the given property is one of the members that were specified
            on construction</returns>
        </member>
        <member name="M:Rezolver.BindSpecificMembersBehaviour.ShouldBind(System.Reflection.FieldInfo)">
            <summary>
            Overrides the base method to return <c>true</c> only for those members which were supplied on construction.
            </summary>
            <param name="fi">A field that is potentially to be bound.</param>
            <returns>A boolean indicating whether the given field is one of the members that were specified
            on construction.</returns>
        </member>
        <member name="M:Rezolver.BindSpecificMembersBehaviour.CreateBinding(Rezolver.Compilation.ICompileContext,System.Type,System.Reflection.FieldInfo)">
            <summary>
            Overrides the base to return bindings only for those members that were passed on construction.
            </summary>
            <param name="context">The current compile context</param>
            <param name="type">The type whose members are being bound (note this could be a type that's
            derived from the one on which the <paramref name="field"/> is declared.</param>
            <param name="field">The field being bound.</param>
            <returns>The binding to be applied to passed <paramref name="field"/> if it's a known field,
            otherwise <c>null</c></returns>
        </member>
        <member name="M:Rezolver.BindSpecificMembersBehaviour.CreateBinding(Rezolver.Compilation.ICompileContext,System.Type,System.Reflection.PropertyInfo)">
            <summary>
            Overrides the base to return bindings only for those members that were passed on construction.
            </summary>
            <param name="context">The current compilation context.</param>
            <param name="type">The type whose members are being bound (note this could be a type that's
            derived from the one on which the property identified by <paramref name="prop"/> is declared.</param>
            <param name="prop">The property being bound.</param>
            <returns>The binding to be applied to the passed <paramref name="prop"/> if it's a known
            property, otherwise <c>null</c></returns>
        </member>
        <member name="T:Rezolver.CombinedContainerConfig">
            <summary>
            An <see cref="T:Rezolver.IContainerConfig"/> which contains zero or or more other <see cref="T:Rezolver.IContainerConfig"/>
            objects.  Behaviours can depend on other behaviours, and this collection ensures that they are applied
            in the correct order.
            </summary>
            <seealso cref="T:Rezolver.CombinedTargetContainerConfig"/>
        </member>
        <member name="M:Rezolver.CombinedContainerConfig.#ctor">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.CombinedContainerConfig"/> type
            </summary>
        </member>
        <member name="M:Rezolver.CombinedContainerConfig.#ctor(Rezolver.CombinedContainerConfig)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.CombinedContainerConfig"/> class by cloning an existing one.
            </summary>
            <param name="collection">The collection whose elements are to be copied.  If null, then the collection is initialised
            empty.</param>
        </member>
        <member name="M:Rezolver.CombinedContainerConfig.#ctor(System.Collections.Generic.IEnumerable{Rezolver.IContainerConfig})">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.CombinedContainerConfig"/> type, using the passed behaviours
            enumerable to seed the underlying collection.
            </summary>
            <param name="behaviours">The behaviours to be added to the collection on construction.</param>
        </member>
        <member name="M:Rezolver.CombinedContainerConfig.#ctor(Rezolver.IContainerConfig[])">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.CombinedContainerConfig"/> type, using the passed behaviours
            enumerable to seed the underlying collection.
            </summary>
            <param name="behaviours">The behaviours to be added to the collection on construction.</param>
        </member>
        <member name="M:Rezolver.CombinedContainerConfig.Clone">
            <summary>
            Clones the configuration in this instance into a new instance of the <see cref="T:Rezolver.CombinedContainerConfig"/>
            type.
            </summary>
        </member>
        <member name="M:Rezolver.CombinedContainerConfig.Configure(Rezolver.Container,Rezolver.IRootTargetContainer)">
            <summary>
            Applies the behaviours in this collection to the passed <paramref name="container"/> and
            <paramref name="targets"/>.
            </summary>
            <param name="container">The container to which the behaviours are being attached.</param>
            <param name="targets">The target container used by the <paramref name="container"/> for its registrations.</param>
            <remarks>The implementation runs through each behaviour that has been added to the collection, in dependency
            order, calling its <see cref="M:Rezolver.IContainerConfig.Configure(Rezolver.Container,Rezolver.IRootTargetContainer)"/> method.</remarks>
        </member>
        <member name="T:Rezolver.CombinedContainerConfigExtensions">
            <summary>
            Contains extension methods for the <see cref="T:Rezolver.CombinedContainerConfig"/> class which simplify the process of
            adding and replacing <see cref="T:Rezolver.IContainerConfig"/> objects which set options and register well-known container services.
            </summary>
        </member>
        <member name="M:Rezolver.CombinedContainerConfigExtensions.UseExpressionCompiler(Rezolver.CombinedContainerConfig)">
            <summary>
            Replaces any existing <see cref="T:Rezolver.IContainerConfig`1" /> in the collection with the
            <see cref="P:Rezolver.Configuration.ExpressionCompilation.Instance"/> from <see cref="T:Rezolver.Configuration.ExpressionCompilation"/> so that
            any container to which the config collection will be applied will use the <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/>.
            </summary>
            <param name="combined">The collection to which the behaviour is to be added.</param>
            <returns>The collection on which the operation is called, to allow chaining of further calls.</returns>
        </member>
        <member name="M:Rezolver.CombinedContainerConfigExtensions.UseCompiler(Rezolver.CombinedContainerConfig,Rezolver.IContainerConfig{Rezolver.Compilation.ITargetCompiler})">
            <summary>
            Replaces any existing <see cref="T:Rezolver.IContainerConfig`1"/> with the passed <paramref name="configuration"/> -
            thus ensuring that any <see cref="T:Rezolver.Container"/> objects which are initialised with the config collection will use whichever
            compiler that is configured when the configuration's <see cref="M:Rezolver.IContainerConfig.Configure(Rezolver.Container,Rezolver.IRootTargetContainer)"/> method
            is called.
            </summary>
            <param name="collection"></param>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.CombinedTargetContainerConfig">
            <summary>
            An <see cref="T:Rezolver.ITargetContainerConfig"/> which contains zero or or more other
            <see cref="T:Rezolver.ITargetContainerConfig"/> objects.  Configurations can depend on others, and this
            collection ensures that they are applied in the correct order.
            </summary>
            <seealso cref="T:Rezolver.CombinedContainerConfig"/>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfig.#ctor">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.CombinedTargetContainerConfig"/> type
            </summary>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfig.#ctor(System.Collections.Generic.IEnumerable{Rezolver.ITargetContainerConfig})">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.CombinedTargetContainerConfig"/> type, using the passed
            configurations to seed the underlying collection.
            </summary>
            <param name="configs">The behaviours to be added to the collection on construction.</param>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfig.#ctor(Rezolver.ITargetContainerConfig[])">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.CombinedTargetContainerConfig"/> type, using the passed
            configurations to seed the underlying collection.
            </summary>
            <param name="configs">The behaviours to be added to the collection on construction.</param>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfig.Clone">
            <summary>
            Creates a clone of this combined configuration collection and returns it.
            </summary>
            <returns>A new instance of <see cref="T:Rezolver.CombinedTargetContainerConfig"/> whose items are identical
            to the collection on which the method is called.</returns>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfig.Configure(Rezolver.IRootTargetContainer)">
            <summary>
            Applies each configuration in this collection to the passed <paramref name="targets"/> <see cref="T:Rezolver.ITargetContainer"/>.
            </summary>
            <param name="targets">The target container to which the configurations in this collection are to be applied.</param>
            <remarks>The implementation runs through each configuration that has been added to the collection, in dependency
            order, calling its <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/> method.</remarks>
        </member>
        <member name="T:Rezolver.CombinedTargetContainerConfigExtensions">
            <summary>
            Extensions for pre-configuring options in an <see cref="T:Rezolver.ITargetContainer"/> via a <see cref="T:Rezolver.CombinedContainerConfig"/>, such as the one
            exposed by <see cref="P:Rezolver.TargetContainer.DefaultConfig"/>.
            </summary>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,``0)">
            <summary>
            Adds a <see cref="T:Rezolver.Configuration.Configure`1"/> callback to the configuration, which will set the passed <paramref name="optionValue"/>
            option in the <see cref="T:Rezolver.ITargetContainer"/> to which the <paramref name="config"/> is later applied.
            </summary>
            <typeparam name="TOption">The type of option to be set</typeparam>
            <param name="config">The combined config to which the configuration callback will be added.</param>
            <param name="optionValue">The value of the option that is to be set when <paramref name="config"/> is applied to an <see cref="T:Rezolver.ITargetContainer"/>
            via its implementation of <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/></param>
            <returns>The <paramref name="config"/> object, for method chaining.</returns>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``2(Rezolver.CombinedTargetContainerConfig,``0)">
            <summary>
            Adds a <see cref="T:Rezolver.Configuration.Configure`1"/> callback to the configuration, which will set the passed <paramref name="optionValue"/>
            option for the service type <typeparamref name="TService"/> in the <see cref="T:Rezolver.ITargetContainer"/> to which the <paramref name="config"/> is later applied.
            </summary>
            <typeparam name="TOption">The type of option to be set.</typeparam>
            <typeparam name="TService">The service type for which the option is to be set.  Use of this is option-dependent - i.e. some options are read
            in a service-specific way and some aren't.</typeparam>
            <param name="config">The combined config to which the configuration callback will be added.</param>
            <param name="optionValue">The value of the option that is to be set when <paramref name="config"/> is applied to an <see cref="T:Rezolver.ITargetContainer"/>
            via its implementation of <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/></param>
            <returns>The <paramref name="config"/> object, for method chaining.</returns>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,System.Type,``0)">
            <summary>
            Adds a <see cref="T:Rezolver.Configuration.Configure`1"/> callback to the configuration, which will set the passed <paramref name="optionValue"/>
            option for the service type <paramref name="serviceType"/> in the <see cref="T:Rezolver.ITargetContainer"/> to which the <paramref name="config"/> is later applied.
            </summary>
            <typeparam name="TOption">The type of option to be set.</typeparam>
            <param name="config">The combined config to which the configuration callback will be added.</param>
            <param name="serviceType">The service type for which the option is to be set.  Use of this is option-dependent - i.e. some options are read
            in a service-specific way and some aren't.  Passing <c>null</c> is equivalent to calling <see cref="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,``0)"/>.</param>
            <param name="optionValue">The value of the option that is to be set when <paramref name="config"/> is applied to an <see cref="T:Rezolver.ITargetContainer"/>
            via its implementation of <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/></param>
            <returns>The <paramref name="config"/> object, for method chaining.</returns>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,System.Func{Rezolver.ITargetContainer,``0})">
            <summary>
            Adds a <see cref="T:Rezolver.Configuration.Configure`1"/> callback to the configuration, which will set the option value returned by
            the <paramref name="optionValueFactory"/> in the <see cref="T:Rezolver.ITargetContainer"/> to which the <paramref name="config"/> is applied.
            </summary>
            <typeparam name="TOption">The type of option to be set</typeparam>
            <param name="config">The combined config to which the configuration callback will be added.</param>
            <param name="optionValueFactory">A callback which returns value of the option that is to be set when <paramref name="config"/> is applied to an <see cref="T:Rezolver.ITargetContainer"/>
            via its implementation of <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/>.  The callback will be passed the target container being configured at that time.</param>
            <returns>The <paramref name="config"/> object, for method chaining.</returns>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``2(Rezolver.CombinedTargetContainerConfig,System.Func{Rezolver.ITargetContainer,System.Type,``0})">
            <summary>
            Adds a <see cref="T:Rezolver.Configuration.Configure`1"/> callback to the configuration, which will set the option value returned by
            the <paramref name="optionValueFactory"/> for the service type <typeparamref name="TService"/> in the <see cref="T:Rezolver.ITargetContainer"/> to which
            the <paramref name="config"/> is applied.
            </summary>
            <typeparam name="TOption">The type of option to be set.</typeparam>
            <typeparam name="TService">The service type for which the option is to be set.  Use of this is option-dependent - i.e. some options are read
            in a service-specific way and some aren't.</typeparam>
            <param name="config">The combined config to which the configuration callback will be added.</param>
            <param name="optionValueFactory">A callback which returns value of the option that is to be set when <paramref name="config"/> is applied to an <see cref="T:Rezolver.ITargetContainer"/>
            via its implementation of <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/>.  The callback will be passed the target container being configured at that time,
            and a <see cref="T:System.Type"/> equal to <typeparamref name="TService"/>.</param>
            <returns>The <paramref name="config"/> object, for method chaining.</returns>
        </member>
        <member name="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,System.Type,System.Func{Rezolver.ITargetContainer,System.Type,``0})">
            <summary>
            Adds a <see cref="T:Rezolver.Configuration.Configure`1"/> callback to the configuration, which will set the option value returned by
            the <paramref name="optionValueFactory"/> for the service type <paramref name="serviceType"/> in the <see cref="T:Rezolver.ITargetContainer"/> to which
            the <paramref name="config"/> is applied.
            </summary>
            <typeparam name="TOption">The type of option to be set.</typeparam>
            <param name="config">The combined config to which the configuration callback will be added.</param>
            <param name="serviceType">The service type for which the option is to be set.  Use of this is option-dependent - i.e. some options are read
            in a service-specific way and some aren't.  Passing <c>null</c> is equivalent to calling <see cref="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,System.Type,System.Func{Rezolver.ITargetContainer,System.Type,``0})"/>.</param>
            <param name="optionValueFactory">A callback which returns value of the option that is to be set when <paramref name="config"/> is applied to an <see cref="T:Rezolver.ITargetContainer"/>
            via its implementation of <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/>.  The callback will be passed the target container being configured at that time,
            and a <see cref="T:System.Type"/> equal to <paramref name="serviceType"/>.</param>
            <returns>The <paramref name="config"/> object, for method chaining.</returns>
        </member>
        <member name="T:Rezolver.Compilation.CompileContext">
             <summary>
             Core implementation of <see cref="T:Rezolver.Compilation.ICompileContext" />.  A root context (i.e. where <see cref="P:Rezolver.Compilation.CompileContext.ParentContext"/> is
             <c>null</c>; created via the <see cref="M:Rezolver.Compilation.CompileContext.#ctor(Rezolver.ResolveContext,Rezolver.ITargetContainer,System.Type)"/>
             constructor) is the starting point for all shared state, such as the <see cref="T:Rezolver.Container"/> and the compilation
             stack.
            
             The <see cref="T:Rezolver.ITargetContainer" /> implementation is done by decorating a new <see cref="T:Rezolver.OverridingTargetContainer" />
             which wraps the actual target container which contains the targets which will be compiled,
             so that new registrations can be added without interfering with upstream containers.
            
             Note that many of the interface members are implemented explicitly - therefore most of your interaction with
             this type is through its implementation of <see cref="T:Rezolver.Compilation.ICompileContext"/> and <see cref="T:Rezolver.ITargetContainer"/>.
             </summary>
             <seealso cref="T:Rezolver.Compilation.ICompileContext" />
             <seealso cref="T:Rezolver.ITargetContainer" />
             <remarks>Note that you can only create an instance of this either through inheritance, via the explicit implementation
             of <see cref="M:Rezolver.Compilation.ICompileContext.NewContext(System.Type,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})"/>, or (preferably) via the
             <see cref="M:Rezolver.Compilation.ITargetCompiler.CreateContext(Rezolver.ResolveContext,Rezolver.ITargetContainer)"/> method of an
             <see cref="T:Rezolver.Compilation.ITargetCompiler" /> resolved from an <see cref="T:Rezolver.Container" />.
             </remarks>
        </member>
        <member name="F:Rezolver.Compilation.CompileContext._emptyConfig">
             <summary>
             This is used to prevent stuff like enumerables being added to every single overriding target
             container that's created for every entry in the compilation stack.  It sidesteps a bug introduced
             by the enumerable behaviour detecting OverridingTargetContainer Root containers which leads
             to an endless loop when Rezolver is used with Asp.Net Core.
            
             Clearly there is another underlying issue here which needs to be addressed but I can't isolate the
             exact cause, except to say that very deep compilation stacks appear to be a problem.  I can't tell
             if it is simply a loop that will eventually finish but which is having to do too much work; or if there
             is a simple bit of logic that can be used to fix it.  In the meantime, preventing compilation context
             target containers from having their own enumerable containers seems to fix the problem, without
             breaking any tests.
             </summary>
        </member>
        <member name="P:Rezolver.Compilation.CompileContext.ParentContext">
            <summary>
            Gets the parent context from which this context was created, if applicable.
            </summary>
            <value>The parent context.</value>
        </member>
        <member name="P:Rezolver.Compilation.CompileContext.ResolveContext">
            <summary>
            Implementation of <see cref="P:Rezolver.Compilation.ICompileContext.ResolveContext"/>
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.CompileContext.TargetType">
            <summary>
            Any factory built for a <see cref="T:Rezolver.ITarget" /> with this context should target this type.
            If null, then the <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target being compiled should be used.
            </summary>
            <remarks>Note that when creating a child context with a null <c>targetType</c> argument, this property will be inherited
            from the <see cref="P:Rezolver.Compilation.CompileContext.ParentContext"/>.</remarks>
        </member>
        <member name="P:Rezolver.Compilation.CompileContext.ScopeBehaviourOverride">
            <summary>
            Implementation of <see cref="P:Rezolver.Compilation.ICompileContext.ScopeBehaviourOverride"/>
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.CompileContext.ScopePreferenceOverride">
            <summary>
            Implementation of <see cref="P:Rezolver.Compilation.ICompileContext.ScopePreferenceOverride"/>
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.CompileContext.DependencyTargetContainer">
             <summary>
             This is the <see cref="T:Rezolver.ITargetContainer"/> through which dependencies are resolved by this context in its
             implementation of <see cref="T:Rezolver.ITargetContainer"/>.
            
             In essence, this class acts as a decorator for this inner target container.
             </summary>
        </member>
        <member name="P:Rezolver.Compilation.CompileContext.CompileStack">
            <summary>
            Gets the stack entries for all the targets that are being compiled for all contexts
            related to this one - both up and down the hierarchy.
            </summary>
            <value>The compile stack.</value>
        </member>
        <member name="M:Rezolver.Compilation.CompileContext.#ctor(Rezolver.Compilation.ICompileContext,System.Type,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})">
            <summary>
            Creates a new <see cref="T:Rezolver.Compilation.CompileContext"/> as a child of another.
            </summary>
            <param name="parentContext">Used to seed the compilation stack, container, dependency container (which
            will still be wrapped in a new <see cref="T:Rezolver.OverridingTargetContainer"/> for isolation) and, optionally,
            the target type (unless you pass a non-null type for <paramref name="targetType" />, which would
            override that).</param>
            <param name="targetType">The target type that is expected to be compiled, or null if the <see cref="P:Rezolver.Compilation.CompileContext.TargetType"/>
            is to be inherited from the <paramref name="parentContext"/>.</param>
            <param name="scopeBehaviourOverride">Override the scope behaviour to be used for the target that is compiled with this context.</param>
            <param name="scopePreferenceOverride">Allows you to override the scope preference for any target being compiled in this context -
            if not provided, then it is automatically inherited from the parent.</param>
        </member>
        <member name="M:Rezolver.Compilation.CompileContext.#ctor(Rezolver.ResolveContext,Rezolver.ITargetContainer,System.Type)">
             <summary>
             Creates a new CompileContext
             </summary>
             <param name="resolveContext">Required.  The context for which compilation is being performed.</param>
             <param name="dependencyTargetContainer">Required - An <see cref="T:Rezolver.ITargetContainer" /> that contains the <see cref="T:Rezolver.ITarget" />s that
             will be required to complete compilation.
            
             Note - this argument is passed to a new <see cref="T:Rezolver.OverridingTargetContainer" /> that is created and proxied by this class' implementation
             of <see cref="T:Rezolver.ITargetContainer" />.
            
             As a result, it's possible to register new targets directly into the context via its implementation of <see cref="T:Rezolver.ITargetContainer"/>,
             without modifying the underlying targets in the container you pass.</param>
             <param name="targetType">Optional. Will be set into the <see cref="P:Rezolver.Compilation.CompileContext.TargetType" /> property.  If null, then any
             <see cref="T:Rezolver.ITarget"/> that is compiled should be compiled for its own <see cref="P:Rezolver.ITarget.DeclaredType"/>.</param>
        </member>
        <member name="M:Rezolver.Compilation.CompileContext.NewContext(System.Type,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})">
             <summary>
             Used by the explicit implementation of <see cref="M:Rezolver.Compilation.ICompileContext.NewContext(System.Type,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})"/>.
            
             Override this in your derived class to create the correct implementation of <see cref="T:Rezolver.Compilation.ICompileContext"/>.
             </summary>
             <param name="targetType">Optional.  The type for which the target is to be compiled, if different from this
             context's <see cref="P:Rezolver.Compilation.CompileContext.TargetType" />.</param>
             <param name="scopeBehaviourOverride">Override the scope behaviour to be used for the target that is compiled with the new context.</param>
             <param name="scopePreferenceOverride">Sets the <see cref="P:Rezolver.Compilation.CompileContext.ScopePreferenceOverride"/>.  As soon as this is set on one context, it is automatically
             inherited by all its child contexts (i.e. you cannot null it)</param>
        </member>
        <member name="M:Rezolver.Compilation.CompileContext.Rezolver#Compilation#ICompileContext#PushCompileStack(Rezolver.ITarget,System.Type)">
            <summary>
            Adds the target to the compilation stack if it doesn't already exist.
            </summary>
            <param name="toCompile">The target to be pushed</param>
            <param name="targetType">The type for which the target is being compiled, if different from <see cref="P:Rezolver.ITarget.DeclaredType" /></param>
            <remarks>Targets can appear on the compilation stack more than once for different types, since the factory
            produced for a target for one type can be different than it is for another.  Ultimately, if a target does in fact have a
            cyclic dependency graph, then this method will detect that.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.CompileContext.Rezolver#Compilation#ICompileContext#PopCompileStack">
            <summary>
            Pops a target from the stack and returns it.  Note that if there
            are no targets on the stack, an <see cref="T:System.InvalidOperationException"/> will occur.
            </summary>
            <returns>The <see cref="T:Rezolver.Compilation.CompileStackEntry"/> that was popped off the compilation stack.</returns>
            <remarks>If <see cref="P:Rezolver.Compilation.CompileContext.ParentContext"/> is not null, then the call is redirected to that context, so that
            the compilation stack is always shared between all contexts spawned from the same root.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.CompileContext.Rezolver#ITargetContainer#Register(Rezolver.ITarget,System.Type)">
            <summary>
            Implements <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/> by wrapping around the child target container created by this context on construction.
            </summary>
            <param name="target">See <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/> for more</param>
            <param name="serviceType">See <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/> for more</param>
        </member>
        <member name="M:Rezolver.Compilation.CompileContext.Rezolver#ITargetContainer#Fetch(System.Type)">
            <summary>
            Implements <see cref="M:Rezolver.ITargetContainer.Fetch(System.Type)"/> by wrapping around the child target container created by this context on construction.
            </summary>
            <param name="type">See <see cref="M:Rezolver.ITargetContainer.Fetch(System.Type)"/> for more.</param>
        </member>
        <member name="M:Rezolver.Compilation.CompileContext.Rezolver#ITargetContainer#FetchAll(System.Type)">
            <summary>
            Implements <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)"/> by wrapping around the child target container created by this context on construction.
            </summary>
            <param name="type">See <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)"/> for more</param>
        </member>
        <member name="M:Rezolver.Compilation.CompileContext.Rezolver#ITargetContainer#CombineWith(Rezolver.ITargetContainer,System.Type)">
            <summary>
            Always throws a <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="existing">Ignored</param>
            <param name="type">Ignored</param>
            <exception cref="T:System.NotSupportedException">Always thrown</exception>
        </member>
        <member name="T:Rezolver.Compilation.CompileStackEntry">
            <summary>
            Represents an entry in the compilation stack of a <see cref="T:Rezolver.Compilation.ICompileContext"/>,
            recording both a target that is being compiled, and the type for which it is being compiled.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.CompileStackEntry.Target">
            <summary>
            Gets the target being compiled.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.CompileStackEntry.TargetType">
            <summary>
            Gets the type for which the target is being compiled.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.CompileStackEntry.#ctor(Rezolver.ITarget,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Compilation.CompileStackEntry"/> class.
            </summary>
            <param name="target">The target being compiled.</param>
            <param name="targetType">Type for which the target is being compiled.</param>
        </member>
        <member name="M:Rezolver.Compilation.CompileStackEntry.Equals(Rezolver.Compilation.CompileStackEntry)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <remarks>Equality is defined as both the <see cref="P:Rezolver.Compilation.CompileStackEntry.Target"/> and the <see cref="P:Rezolver.Compilation.CompileStackEntry.TargetType"/>
            being equal between this instance and the <paramref name="other"/> instance.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.CompileStackEntry.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
        </member>
        <member name="M:Rezolver.Compilation.CompileStackEntry.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.AutoFactoryTargetBuilder">
            <summary>
            Expression builder for the <see cref="T:Rezolver.Targets.AutoFactoryTarget"/> target type.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.AutoFactoryTargetBuilder.Build(Rezolver.Targets.AutoFactoryTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds the expression for the passed <paramref name="target"/>
            </summary>
            <param name="target">The target for which an expression is to be built</param>
            <param name="context">The compilation context</param>
            <param name="compiler">The compiler</param>
            <returns>An expression.</returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.BlockExpressionLocalsRewriter">
             <summary>
             Used to rewrite any block expressions to strip out any locals that have been lifted
             out to an outer scope.
            
             This prevents additional instances of a local being declared inside inner blocks from shared parameter expressions.
             </summary>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder">
             <summary>
             Implementation of <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised to build expressions for the
             <see cref="T:Rezolver.Targets.ChangeTypeTarget"/>
            
             This always produces a conversion expression (i.e. cast or box/unbox)
             </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.Build(Rezolver.Targets.ChangeTypeTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds the conversion expression represented by the <paramref name="target"/>
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ConditionalRewriter">
             <summary>
             Reorders an expression tree where duplicate conditional expressions are found
             in multiple places throughout that expression tree. Those duplicated conditionals
             are moved further up the expression tree into one conditional.
             </summary>
             <remarks>Although there's no reason for this type to be internal, it is for now until someone specifically needs it.
            
             The library already uses it automatically for all expressions created by custom targets so long as the standard base types
             are used to create and compile them.
            
             In essence, what we're doing is taking an expression that's been generated as something like this:
            
             <code>return a == b ? new c(a == b ? new d() : new e()) : new f(a == b ? new d() : new e())</code>
            
             And rewriting it to be:
            
             <code>return a == b ? new c(new d()) : new f(new e())</code>
            
             So, it's looking for one or more duplicate conditionals which appear inside the true or false branches of
             the same conditional, and removing all the redundant checks - reducing the whole thing to one conditional.
            
             In the example above, we only create an instance of c when a == b, therefore we will only ever create an
             instance of d as its constructor argument - so the second a == b conditional is not required.  When a != b,
             similarly, we will only ever create an instance of e as the constructor argument.
            
             As you can see this can be a significant optimisation to the expressions that are generated by the
             <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/>, since each target's expression is built in isolation and
             the existence of previous identical conditionals is not considered.  The optimisation only works when the
             equality expression used in all identical conditionals is exactly the same expression - therefore the
             shared expressions functionality of the <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext"/> is absolutely crucial to
             achieving a good result.
             </remarks>
        </member>
        <member name="F:Rezolver.Compilation.Expressions.ConditionalRewriter.CandidateTest.Test">
            <summary>
            The shared test
            </summary>
        </member>
        <member name="F:Rezolver.Compilation.Expressions.ConditionalRewriter.CandidateTest.RewriteCount">
            <summary>
            The number of times a conditional expression with this test has been rewritten
            </summary>
        </member>
        <member name="F:Rezolver.Compilation.Expressions.ConditionalRewriter.CandidateTest.MatchCount">
            <summary>
            The number of times this test has been discovered in a conditional expression
            </summary>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ConstructorTargetBuilder">
            <summary>
            An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised for building the target <see cref="T:Rezolver.Targets.ConstructorTarget"/>
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ConstructorTargetBuilder.Build(Rezolver.Targets.ConstructorTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Override of <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1.Build(`0,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/>
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The compiler to be used to build the target</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ConstructorTargetBuilder.Build(Rezolver.ConstructorBinding,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression for the specified <see cref="T:Rezolver.ConstructorBinding" />.
            Called by <see cref="M:Rezolver.Compilation.Expressions.ConstructorTargetBuilder.Build(Rezolver.Targets.ConstructorTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" />
            </summary>
            <param name="binding">The binding.</param>
            <param name="context">The context.</param>
            <param name="compiler">The compiler to be used to build the target.</param>
            <remarks>The returned expression will either be a NewExpression or a MemberInitExpression</remarks>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.DecoratorTargetBuilder">
            <summary>
            Specialised builder for <see cref="T:Rezolver.Targets.DecoratorTarget"/> targets.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.DecoratorTargetBuilder.Build(Rezolver.Targets.DecoratorTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Creates a new compilation context, registers the target's <see cref="P:Rezolver.Targets.DecoratorTarget.DecoratedTarget"/>
            into it as the correct target for the <see cref="P:Rezolver.Targets.DecoratorTarget.DecoratedType"/>, and then builds the
            expression for the <see cref="P:Rezolver.Targets.DecoratorTarget.InnerTarget"/> (which is typically a constructor target).
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.DefaultTargetBuilder">
             <summary>
             An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised for building the expression for the <see cref="T:Rezolver.Targets.DefaultTarget"/> target.
            
             Essentially, it just calls <see cref="M:System.Linq.Expressions.Expression.Default(System.Type)"/> for the <see cref="P:Rezolver.Targets.DefaultTarget.DeclaredType"/>.
             </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.DefaultTargetBuilder.Build(Rezolver.Targets.DefaultTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression from the specified target for the given <see cref="T:Rezolver.Compilation.ICompileContext" />
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.DelegateTargetBuilder">
            <summary>
            Specialised builder for the <see cref="T:Rezolver.Targets.DelegateTarget"/> class and all its derivatives.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.DelegateTargetBuilder.Build(Rezolver.Targets.DelegateTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression from the specified target for the given <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext" />
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.EnumerableTargetBuilder">
            <summary>
            An implementation of <see cref="T:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1"/> specialised for the target type <see cref="T:Rezolver.Targets.EnumerableTarget"/>.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.EnumerableTargetBuilder.Build(Rezolver.Targets.EnumerableTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
             <summary>
             Builds an expression which represents an instance of <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements are created by the
             <see cref="P:Rezolver.Targets.EnumerableTarget.Targets"/> of the passed <paramref name="target"/>.
             </summary>
             <param name="target">The target for which an expression is to be built.</param>
             <param name="context">The current compilation context.</param>
             <param name="compiler">The compiler to use when building expressions for child targets.</param>
             <returns>An expression which can be compiled into a delegate that, when executed, will create an instance of the enumerable
             represented by <paramref name="target"/>
             </returns>
             <remarks>
             The compiler is capable of producing both lazy-loaded and eager-loaded enumerables, which can be controlled via
             target container options.
            
             ## Lazy vs Eager loading
            
             The option <see cref="T:Rezolver.Options.LazyEnumerables"/> is read from the <paramref name="context"/> for the
             <see cref="P:Rezolver.Targets.EnumerableTarget.ElementType"/> of the <paramref name="target"/>.  If it is equivalent to <c>true</c>
             (the <see cref="P:Rezolver.Options.LazyEnumerables.Default"/>), then a lazily-loaded enumerable is constructed which will
             create new instances of each object in the enumerable each time it is enumerated.
            
             If the option is instead equivalent to <c>false</c>, then all instances will be created in advance, and an already-materialised
             enumerable is constructed.</remarks>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionBuilderBase">
             <summary>
             Abstract starting point for implementing <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/>.
            
             Note that the interface is implemented explicitly; but exposes protected abstract or virtual
             methods for inheritors to extend.
             </summary>
             <seealso cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder" />
             <remarks>This class takes care of checking the type requested in the <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext"/>
             is compatible with the target that's passed to the <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/>
             method</remarks>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods">
            <summary>
            Provides access to a set of <see cref="T:System.Reflection.MethodInfo"/> objects for common functions required
            by code produced from <see cref="T:Rezolver.ITarget"/>s.  Also contains some factory methods for building
            expressions which bind to those methods.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.IDirectTarget_GetValue_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> for the <see cref="M:Rezolver.IDirectTarget.GetValue"/> method.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.IInstanceProvider_GetInstance_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> for the <see cref="M:Rezolver.IInstanceProvider.GetInstance(Rezolver.ResolveContext)"/>
            method.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.Container_ResolveStrong_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> for an internal strongly typed method `Container.ResolveInternal&lt;TService&gt;(ResolveContext)`
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.CurrentScope_ActivateImplicit_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> for a scope activation method for objects with implicit scoping in the current scope.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.RootScope_ActivateImplicit_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> for a scope activation method for objects with implicit scoping in the root scope.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.CurrentScope_ActivateExplicit_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> for a scope activation method for implicitly scoped objects within this scope.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.RootScope_ActivateExplicit_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> for a scope activation method for explicitly scoped objects within the root scope.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.ResolveContext_New_Type_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> object for the <see cref="M:Rezolver.ResolveContext.ChangeRequestedType(System.Type)"/> method
            </summary>
            <value>The type of the resolve context create new method.</value>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.ResolveContext_New_Container_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> object for the <see cref="M:Rezolver.ResolveContext.ChangeContainer(Rezolver.Container)"/> method
            </summary>
            <value>The type of the resolve context create new method.</value>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.ResolveContext_Resolve_Strong_Method">
            <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo"/> object for the <see cref="M:Rezolver.ResolveContext.Resolve``1"/> method
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.Call_CurrentScope_ActivateImplicit(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Gets a method call expression which will activate the given instance in the current scope
            (accessed through the <see cref="T:Rezolver.ResolveContext"/> identified by the <paramref name="context"/> expression).
            
            Note - the method being called is not publicly accessible.
            </summary>
            <param name="context">Represents the <see cref="T:Rezolver.ResolveContext"/> on which the method will be invoked.</param>
            <param name="instance">The instance to be activated.  If the context's active scope is an instance-tracking
            scope, and the instance is <see cref="T:System.IDisposable"/>, then the instance will be marked for disposal when
            the scope is disposed.</param>
            <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression"/></returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.Call_RootScope_ActivateImplicit(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Gets a method call expression which will activate the given instance in the root scope
            (accessed through the <see cref="T:Rezolver.ResolveContext"/> identified by the <paramref name="context"/> expression).
            
            Note - the method being called is not publicly accessible.
            </summary>
            <param name="context">Represents the <see cref="T:Rezolver.ResolveContext"/> on which the method will be invoked.</param>
            <param name="instance">The instance to be activated.  If the context's active scope is an instance-tracking
            scope, and the instance is <see cref="T:System.IDisposable"/>, then the instance will be marked for disposal when
            the scope is disposed.</param>
            <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression"/></returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.Call_CurrentScope_ActivateExplicit(System.Linq.Expressions.Expression,System.Int32,System.Linq.Expressions.LambdaExpression)">
            <summary>
            Gets a method call expression which will either fetch an existing, or activate a new, explicitly scoped 
            instance in the current scope (accessed through the <see cref="T:Rezolver.ResolveContext"/> identified by the 
            <paramref name="context"/> expression).
            The passed <paramref name="instanceFactory"/> is used to create the new instance if the scope is not
            already tracking an instance.
            
            Note - the method being called is not publicly accessible.
            </summary>
            <param name="context">Represents the <see cref="T:Rezolver.ResolveContext"/> on which the method will be invoked.</param>
            <param name="targetId">Required - the <see cref="P:Rezolver.ITarget.Id"/> of the <see cref="T:Rezolver.ITarget"/> from which 
            the <paramref name="instanceFactory"/> was built.</param>
            <param name="instanceFactory">A lambda expression representing the factory method that should be used to create a 
            new instance if one does not already exist within the scope.</param>
            <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression"/></returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.Call_RootScope_ActivateExplicit(System.Linq.Expressions.Expression,System.Int32,System.Linq.Expressions.LambdaExpression)">
            <summary>
            Emits a <see cref="T:System.Linq.Expressions.MethodCallExpression"/> which represents activating the instance produced by the 
            <paramref name="instanceFactory"/> through the root scope.  Only to be used when compiling a target 
            which has a <see cref="P:Rezolver.ITarget.ScopeBehaviour"/> of <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> and a
            <see cref="P:Rezolver.ITarget.ScopePreference"/> of <see cref="F:Rezolver.ScopePreference.Root" />.
            </summary>
            <param name="context">An expression representing the context on which the method will be called</param>
            <param name="targetId">The <see cref="P:Rezolver.ITarget.Id"/> of the target from which the <paramref name="instanceFactory"/> was compiled.</param>
            <param name="instanceFactory">A lambda expression </param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.CallResolveContext_New_Type(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Emits a <see cref="T:System.Linq.Expressions.MethodCallExpression"/> which represents calling the
            <see cref="M:Rezolver.ResolveContext.ChangeRequestedType(System.Type)"/> method with the
            given arguments.
            </summary>
            <param name="resolveContext">An expression representing the context on which the method will be called</param>
            <param name="serviceType">An expression representing the argument to the newRequestedType parameter</param>
            <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression"/></returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.CallResolveContext_Resolve_Strong_Method(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Emits a <see cref="T:System.Linq.Expressions.MethodCallExpression"/> which represents calling the
            <see cref="M:Rezolver.ResolveContext.Resolve``1"/> method of the context represented
            by the <paramref name="resolveContext"/> expression.
            </summary>
            <param name="resolveContext">Expression representing the context on which the method is to be called.</param>
            <param name="serviceType">A type which will be used to bind the correct generic method.</param>
            <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression"/></returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.GetContextCompiler(Rezolver.Compilation.Expressions.IExpressionCompileContext)">
             <summary>
             Gets the <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompiler"/> to be used for
             the given context, if different from one passed to this class' implementation of
             <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/>.
             </summary>
             <param name="context">The current compile context.</param>
             <remarks>This function is called by <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.BuildCore(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/> which will throw
             an exception if it returns null and no compiler was provided to <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.BuildCore(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/>
             (typically via the explicit implementation of <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/>).
            
             The base implementation uses the <see cref="M:Rezolver.TargetContainerExtensions.GetOption``1(Rezolver.ITargetContainer,``0)"/> method,
             passing the <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompiler"/> type as the option type.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.BuildCore(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
             <summary>
             The core expression build function - takes care of handling mismatched types between the target and
             the requested type in the context - both checking compatibility and producing conversion expressions
             where necessary.
             Also performs cyclic dependency checking and rewriting expressions to take advantage of a target's
             <see cref="P:Rezolver.ITarget.ScopeBehaviour"/> (which can be overriden with <see cref="P:Rezolver.Compilation.ICompileContext.ScopeBehaviourOverride"/>)
             </summary>
             <param name="target">The target to be compiled.</param>
             <param name="context">The context.</param>
             <param name="compiler">The compiler.</param>
             <exception cref="T:System.ArgumentException">targetType doesn't support the context's <see cref="P:Rezolver.Compilation.ICompileContext.TargetType"/></exception>
             <exception cref="T:System.InvalidOperationException">The <paramref name="target"/> is already being compiled.</exception>
             <remarks>This class' implementation of <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" /> calls this,
             as does the derived abstract class <see cref="T:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1" /> for its implementation
             of <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder`1.Build(`0,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" />.
            
            
             It is this function that is responsible for calling the abstract <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" />
             function, which deriving classes implement to actually produce their expression for the <paramref name="target"/>.
             </remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.ApplyScoping(System.Linq.Expressions.Expression,Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
             <summary>
             Called by the <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.BuildCore(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/> method.
            
             Applies the scoping behaviour to the <paramref name="builtExpression"/> such that when it is executed it
             correctly interfaces with the active scope (from the <see cref="T:Rezolver.ResolveContext"/>) if one is present for the
             scope behaviour and preference determined from the <paramref name="context"/> and <paramref name="target"/>.
             </summary>
             <param name="builtExpression">The expression that was built for the <paramref name="target"/>.</param>
             <param name="target">The target that is currently being compiled and from which the <paramref name="builtExpression" />
             was built.</param>
             <param name="context">The current active compilation context - this context's <see cref="P:Rezolver.Compilation.ICompileContext.ScopeBehaviourOverride"/>
             and <see cref="P:Rezolver.Compilation.ICompileContext.ScopePreferenceOverride"/> will be used to override those of the <paramref name="target"/>.</param>
             <param name="compiler">The compiler.</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver#Compilation#Expressions#IExpressionBuilder#Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Explicit implementation of <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" /> -
            ultimately forwards the call to the <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.BuildCore(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" /> function.
            </summary>
            <param name="target">The target for which an expression is to be built</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">Optional. The compiler that's requesting the expression; and which can be used
            to compile other targets within the target.  If not provided, then the implementation attempts to locate
            the context compiler using the <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.GetContextCompiler(Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> method, and will throw
            an <see cref="T:System.InvalidOperationException"/> if it cannot do so.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> is null or <paramref name="context"/> is null</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="compiler"/> is null and an IExpressionCompiler
            couldn't be resolved for the current context (via <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.GetContextCompiler(Rezolver.Compilation.Expressions.IExpressionCompileContext)"/></exception>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Abstract method used as part implementation of the
            <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" />
            It's called by <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.BuildCore(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" />.
            </summary>
            <param name="target">The target.</param>
            <param name="context">The context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target"/>.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided </param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.CanBuild(System.Type)">
            <summary>
            Abstract method (implementation of <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder.CanBuild(System.Type)"/>) which
            determines whether this instance can build an expression for the specified target.
            </summary>
            <param name="targetType">The type of target.</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1">
             <summary>
             Abstract base class for implementations of <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder`1"/>.
            
             Provide an implementation of <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1.Build(`0,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/> and then register
             an instance in an <see cref="T:Rezolver.Targets.ObjectTarget"/> in the active container.
             </summary>
             <typeparam name="TTarget">The type of target for which this builder can build an expression.  This should ideally be
             a type which directly implements <see cref="T:Rezolver.ITarget"/> - however, so long as the runtime type of all the targets which
             are fed to it do implement it, everything is fine.
             </typeparam>
             <seealso cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder`1" />
             <seealso cref="T:Rezolver.Compilation.Expressions.ExpressionBuilderBase"/>
             <remarks>This is a generic extension of the <see cref="T:Rezolver.Compilation.Expressions.ExpressionBuilderBase"/> class,
             designed to simplify the process of implementating the <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder`1"/>
             (and, by extension, <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/>) interface.
            
             This is the class from which most of the built-in expression builders derive, because the
             <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/>, when asked to compile an expression, attempts to resolve
             an <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder`1"/> whose <typeparamref name="TTarget"/>
             is the same type as the target that needs compiling.
            
             Inheriting from <see cref="T:Rezolver.Compilation.Expressions.ExpressionBuilderBase"/> is more appropriate if your builder is capable
             of handling multiple types of <see cref="T:Rezolver.ITarget"/> - a scenario that's much less common.
            
             Note that this class' implementation of <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder`1"/> is entirely explicit and
             non-virtual, the same as with its base class, hence the only way to build an expression via an instance
             of this class without exposing the behaviour to external callers yourself is via the interface.
             </remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Overrides the abstract <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" /> (and seals it from
            further overrides); checks that <paramref name="target" /> is an instance of <typeparamref name="TTarget" />
            (throwing an <see cref="T:System.ArgumentException" /> if not) and then calls this class' <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1.Build(`0,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" />
            abstract function.
            </summary>
            <param name="target">The target for which an expression is to be built.  Must be an instance of <typeparamref name="TTarget" />.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
            <exception cref="T:System.ArgumentException">target must be an instance of { typeof(TTarget) }</exception>
            <exception cref="T:System.ArgumentException">If the passed target is not an instance of <typeparamref name="TTarget" /></exception>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1.Rezolver#Compilation#Expressions#IExpressionBuilder{TTarget}#Build(`0,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds the specified target.
            </summary>
            <param name="target">The target.</param>
            <param name="context">The context.</param>
            <param name="compiler">Optional. The compiler that's requesting the expression; and which can be used
            to compile other targets within the target.  If not provided, then the implementation attempts to locate
            the context compiler using the <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.GetContextCompiler(Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> method, and will throw
            an <see cref="T:System.InvalidOperationException"/> if it cannot do so.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> is null or <paramref name="context"/> is null</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="compiler"/> is null and an IExpressionCompiler
            couldn't be resolved for the current context (via <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase.GetContextCompiler(Rezolver.Compilation.Expressions.IExpressionCompileContext)"/></exception>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1.Build(`0,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
             <summary>
             Builds an expression from the specified target for the given <see cref="T:Rezolver.Compilation.ICompileContext"/>
            
             OVerride this to implement the compilation for your target type.
             </summary>
             <param name="target">The target whose expression is to be built.</param>
             <param name="context">The compilation context.</param>
             <param name="compiler">The expression compiler to be used to build any other expressions for targets
             which might be required by the <paramref name="target"/>.  Note that unlike on the interface, where this
             parameter is optional, this will always be provided </param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1.CanBuild(System.Type)">
             <summary>
             Determines whether this instance can build an expression from the specified target.
            
             This base implementation simply checks that the type of <paramref name="targetType"/> is
             compatible with the type <typeparamref name="TTarget"/>.
             </summary>
             <param name="targetType">The target type.</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionCompilationFilters">
            <summary>
            Delegate-based implementation of <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompilationFilter"/> allowing multiple
            filters to be combined into one.
            </summary>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionCompileContext">
            <summary>
            An implementation of <see cref="T:Rezolver.Compilation.ICompileContext"/> which is specialised for use by an <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompiler"/>.
            </summary>
            <seealso cref="T:Rezolver.Compilation.CompileContext" />
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.DefaultResolveContextParameterExpression">
            <summary>
            The default <see cref="T:Rezolver.ResolveContext"/> parameter expression used by the expression-based code generators
            defined in this library, although it's not used directly for that purpose - instead, the <see cref="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.ResolveContextParameterExpression"/>
            of new contexts is initialised to this if not explicitly provided on  construction and when not being inherited from another
            context.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.ParentContext">
            <summary>
            Gets the parent context.
            </summary>
            <remarks>Note that this property hides the inherited <see cref="P:Rezolver.Compilation.ICompileContext.ParentContext"/> property,
            since an <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext"/> can only be a child of another <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext"/>.</remarks>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.ResolveContextParameterExpression">
            <summary>
            This is the parameter expression which represents the <see cref="T:Rezolver.ResolveContext" /> that is passed to the
            factory delegate at resolve-time.
            </summary>
            <value>The resolve context expression.</value>
            <remarks>If the code produced by the <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder" /> for a given target needs to read or use the
            <see cref="T:Rezolver.ResolveContext" /> that was originally passed to the <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)" /> method,
            then it does it by using this expression, which will be set as the only parameter on the lambda expression which is
            eventually compiled (in the case of the default expression compiler, <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler" />.</remarks>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.SharedExpressions">
            <summary>
            Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context and/or added
            via calls to <see cref="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.GetOrAddSharedExpression(System.Type,System.String,System.Func{System.Type,System.String,System.Linq.Expressions.Expression},System.Type)" /> or
            <see cref="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.GetOrAddSharedLocal(System.Type,System.String,System.Type)" />.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.#ctor(Rezolver.Compilation.Expressions.IExpressionCompileContext,System.Type,System.Boolean,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})">
             <summary>
             Initializes a new instance of the <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompileContext"/> class as a child of another.
            
             Note that the <see cref="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.ResolveContextParameterExpression"/> is always inherited from the source context to ensure 
             consistency across all expressions being built during a particular compilation chain.
             </summary>
             <param name="sourceContext">The source context.</param>
             <param name="useParentSharedExpressions">If <c>true</c> then the <see cref="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.SharedExpressions"/> of the <paramref name="sourceContext"/>
             will be reused by this new context.  If <c>false</c>, then this context will start with a new empty set of shared expressions.</param>
             <param name="scopeBehaviourOverride">Override the scope behaviour to be used for the target that is compiled with this context.</param>
             <param name="targetType">If not null, the type for which expressions are to be compiled.  If null, then the
             <paramref name="sourceContext"/>'s <see cref="P:Rezolver.Compilation.ICompileContext.TargetType"/> will be inherited.</param>
             <param name="scopePreferenceOverride">Allows you to override the scope preference for any target being compiled in this context -
             if not provided, then it is automatically inherited from the parent.</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.#ctor(Rezolver.ResolveContext,Rezolver.ITargetContainer,System.Type,System.Linq.Expressions.ParameterExpression)">
             <summary>
             Initializes a new instance of the <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompileContext"/> class.
             </summary>
             <seealso cref="M:Rezolver.Compilation.CompileContext.#ctor(Rezolver.ResolveContext,Rezolver.ITargetContainer,System.Type)"/>.
             <param name="resolveContext">Required.  The container for which the compilation is being performed.  When compiling in response to
             a call to <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/>, the container which first receives the call should be
             the one passed here.</param>
             <param name="dependencyTargetContainer">Required - target container used for dependency lookups.  As with the base class
             this is actually wrapped in a new <see cref="T:Rezolver.OverridingTargetContainer"/> and used as this class' implementation of
             <see cref="T:Rezolver.ITargetContainer"/>.</param>
             <param name="targetType">Optional. Will be set into the <see cref="P:Rezolver.Compilation.CompileContext.TargetType" /> property.  If null, then any
             <see cref="T:Rezolver.ITarget"/> that is compiled should be compiled for its own <see cref="P:Rezolver.ITarget.DeclaredType"/>.</param>
             <param name="resolveContextExpression">Optional, mapped to <see cref="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.ResolveContextParameterExpression"/> - the default
             for this (i.e. when you leave it as null) is to use the static <see cref="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.DefaultResolveContextParameterExpression"/>
             and generally it should always be left as that.
            
             The <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/>, when building expressions to turn into compiled lambdas, uses this as the main parameter
             on the lambda itself.</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.RegisterExpressionTargets">
            <summary>
            Registers some additional targets into the compile context to support compilation.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.Rezolver#Compilation#Expressions#IExpressionCompileContext#NewContext(System.Type,System.Boolean,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})">
            <summary>
            Creates a new <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext" /> using this one as a seed.  This function is identical to
            <see cref="M:Rezolver.Compilation.ICompileContext.NewContext(System.Type,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})" /> but allows you to control whether the <see cref="P:Rezolver.Compilation.Expressions.ExpressionCompileContext.SharedExpressions" />
            are inherited (the default); and is more convenient because it returns another <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext" />.
            </summary>
            <param name="targetType">Optional.  The type for which the target is to be compiled, if different from this
            context's <see cref="P:Rezolver.Compilation.CompileContext.TargetType" />.</param>
            <param name="useParentSharedExpressions">If <c>true</c> then the shared expressions in this context will be inherited
            by the new context by reference.  That is, when the new context goes out of scope, any new shared expressions it created
            will still be available.
            If false, then the new context will get a brand new, empty, set of shared expressions.</param>
            <param name="scopeBehaviourOverride">Override the <see cref="P:Rezolver.Compilation.CompileContext.ScopeBehaviourOverride"/> to be used for the target that is compiled with the new context.
            This is never inherited automatically from one context to another.</param>
            <param name="scopePreferenceOverride">Sets the <see cref="P:Rezolver.Compilation.CompileContext.ScopePreferenceOverride"/>.  As soon as this is set on one context, it is automatically
            inherited by all its child contexts (i.e. you cannot null it)</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.NewContext(System.Type,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})">
            <summary>
            Used by the explicit implementation of
            <see cref="M:Rezolver.Compilation.ICompileContext.NewContext(System.Type,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})" />.
            This is overriden to ensure that the correct type of context is created when created directly through the
            <see cref="T:Rezolver.Compilation.ICompileContext"/> interface.
            </summary>
            <param name="targetType">Optional.  The type for which the target is to be compiled, if different from this
            context's <see cref="P:Rezolver.Compilation.ICompileContext.TargetType" />.</param>
            <param name="scopeBehaviourOverride">Override the <see cref="P:Rezolver.Compilation.CompileContext.ScopeBehaviourOverride"/> to be used for the target that is compiled with the new context.
            This is never inherited automatically from one context to another.</param>
            <param name="scopePreferenceOverride">Sets the <see cref="P:Rezolver.Compilation.CompileContext.ScopePreferenceOverride"/>.  As soon as this is set on one context, it is automatically
            inherited by all its child contexts (i.e. you cannot null it)</param>
            <remarks>Note all child contexts created through this virtual method will always inherit the parent context's shared expressions.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.GetOrAddSharedLocal(System.Type,System.String,System.Type)">
            <summary>
            Similar to <see cref="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.GetOrAddSharedExpression(System.Type,System.String,System.Func{System.Type,System.String,System.Linq.Expressions.Expression},System.Type)" />, except this is used when expression
            builders want to use local variables in block expressions to store the result of some operation in the expression tree built
            for a particular target.  Reusing one local variable is more efficient than declaring the same local multiple times.
            </summary>
            <param name="type">The type.</param>
            <param name="name">The name.</param>
            <param name="requestingType">Optional - the type of the object requesting this shared expression.  If this is provided,
            then the search for an existing shared expression will only work if the same requesting type was passed previously.</param>
            <exception cref="T:System.InvalidOperationException">Cannot add ParameterExpression: A shared expression of a different type has already been added with the same type and name.</exception>
            <remarks>When multiple expression trees from multiple targets are brought together into one lambda, there will
            often be many duplicate variables which could be shared.  So, if an <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder" /> needs a local variable
            for a block, instead of simply declaring it directly through the <see cref="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" /> function,
            it can use this function instead, which will return a previously created one if available.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompileContext.GetOrAddSharedExpression(System.Type,System.String,System.Func{System.Type,System.String,System.Linq.Expressions.Expression},System.Type)">
            <summary>
            Gets or adds a shared expression (created by the <paramref name="expressionFactory"/> if it's not already cached) with the given name, type, optionally
            for the given <paramref name="requestingType"/>.
            </summary>
            <param name="type">The runtime type of the Expression.</param>
            <param name="name">The runtime name of the Expression - and also the name used to retrieve it later.</param>
            <param name="expressionFactory">The factory method to use to construct the shared expression from scratch, if it's not already cached.</param>
            <param name="requestingType">Optional - to avoid naming clashes with shared expressions created by other targets, you can pass a type here
            (usually the runtime type of your <see cref="T:Rezolver.ITarget"/> implementation).</param>
            <returns>Expression.</returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionCompiler">
            <summary>
            Implementation of the <see cref="T:Rezolver.Compilation.ITargetCompiler" /> interface which produces factory delegates
            by building and compiling expression trees from the <see cref="T:Rezolver.ITarget" /> objects which are registered.
            
            This is the default compiler (see remarks).
            </summary>
            <seealso cref="T:Rezolver.Compilation.Expressions.IExpressionCompiler" />
            <seealso cref="T:Rezolver.Compilation.ITargetCompiler" />
            <remarks>Use of this compiler by a container is enabled by applying the <see cref="T:Rezolver.Configuration.ExpressionCompilation"/>
            <see cref="P:Rezolver.Configuration.ExpressionCompilation.Instance"/> to the container either on construction (for example, via the
            <see cref="M:Rezolver.Container.#ctor(Rezolver.IRootTargetContainer,Rezolver.IContainerConfig)"/> constructor) or via the
            <see cref="P:Rezolver.Container.DefaultConfig"/> - which currently configures this compiler by default anyway.
            </remarks>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.ExpressionCompiler.Default">
            <summary>
            Gets the default expression compiler.  It's this that the <see cref="T:Rezolver.Configuration.ExpressionCompilation"/>
            registers.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompiler.CompileTarget(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)">
            <summary>
            Create the factory for the given <paramref name="target" /> using the <paramref name="context" />
            to inform the type of object that is to be built, and for compile-time dependency resolution.
            </summary>
            <param name="target">Required.  The target to be compiled.</param>
            <param name="context">Required.  The current compilation context.</param>
            <exception cref="T:System.ArgumentException">context must be an instance of IExpressionCompileContext</exception>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompiler.CompileTarget``1(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)">
            <summary>
            Generic, strongly-typed, version of <see cref="M:Rezolver.Compilation.Expressions.ExpressionCompiler.CompileTarget(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)"/> which builds
            a strongly-typed factory for the given <paramref name="target"/>.
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="target">Required.  The target to be compiled.</param>
            <param name="context">Required.  The current compilation context.</param>
            <returns>The compiled delegate.</returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompiler.ResolveBuilder(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)">
             <summary>
             Resolves an expression builder that can build the given target for the given compile context.
            
             Or
            
             Returns null if no builder can be found.
             </summary>
             <param name="target">The target.</param>
             <param name="context">The context.</param>
             <remarks>The function builds a list of all the types in the hierarchy represented
             by the type of the <paramref name="target"/> and, for each of those types which are
             compatible with <see cref="T:Rezolver.ITarget"/>, it looks for an <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder`1"/>
             which is specialised for that type.  If no compatible builder is found, then it attempts
             to find a general purpose <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> which can build the type.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompiler.BuildFactory(Rezolver.ITarget,System.Linq.Expressions.Expression{System.Func{Rezolver.ResolveContext,System.Object}})">
            <summary>
            Creates a factory delegate from the finalised <paramref name="lambda"/> expression which was
            previously built for the <paramref name="target"/>.  This method is typically used by non-generic resolve operations
            (such as the <see cref="T:Rezolver.Container"/> class' implementation of <see cref="M:System.IServiceProvider.GetService(System.Type)"/>)
            </summary>
            <param name="target">The <see cref="T:Rezolver.ITarget"/> from which the passed <paramref name="lambda"/> was built</param>
            <param name="lambda">The lambda expression representing the code to be executed in order to get the underlying
            object which will be resolved.  Typically, this is fed directly from the
            <see cref="M:Rezolver.Compilation.Expressions.ExpressionCompiler.BuildObjectFactoryLambda(System.Linq.Expressions.Expression,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> method.</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompiler.BuildFactory``1(Rezolver.ITarget,System.Linq.Expressions.LambdaExpression)">
            <summary>
            Creates a strongly-typed factory delegate from the finalised <paramref name="lambda"/> expression
            which was previously built for the <paramref name="target"/>.  This method is typically used by the generic
            resolve operations (such as <see cref="M:Rezolver.Container.Resolve``1"/> and similar).
            </summary>
            <typeparam name="TService">The type of object that is expected to be returned by the factory delegate.</typeparam>
            <param name="target">The <see cref="T:Rezolver.ITarget"/> from which the passed <paramref name="lambda"/> was built</param>
            <param name="lambda">The lambda expression representing the code to be executed in order to get the underlying
            object which will be resolved.  Typically, this is fed directly from the 
            <see cref="M:Rezolver.Compilation.Expressions.ExpressionCompiler.BuildStrongFactoryLambda(System.Linq.Expressions.Expression,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> method.</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompiler.BuildObjectFactoryLambda(System.Linq.Expressions.Expression,Rezolver.Compilation.Expressions.IExpressionCompileContext)">
            <summary>
            Takes the unoptimised expression built for a target and optimises it and turns it into a lambda expression ready to
            be compiled into a factory delegate.
            </summary>
            <param name="expression">The expression.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompiler.BuildStrongFactoryLambda(System.Linq.Expressions.Expression,Rezolver.Compilation.Expressions.IExpressionCompileContext)">
            <summary>
            Equivalent to <see cref="M:Rezolver.Compilation.Expressions.ExpressionCompiler.BuildObjectFactoryLambda(System.Linq.Expressions.Expression,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> except this produces a lambda whose delegate
            type is strongly typed for the type of object that's returned (instead of just being 'object').
            </summary>
            <param name="expression">The expression.</param>
            <param name="context">The context.</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompiler.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)">
            <summary>
            Called to build an expression for the specified target for the given <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext" /> - implementation
            of the <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompiler.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> method.
            </summary>
            <param name="target">The target for which an expression is to be built</param>
            <param name="context">The compilation context.</param>
            <exception cref="T:System.ArgumentException">If the compiler is unable to resolve an <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder" /> from
            the <paramref name="context" /> for the <paramref name="target" /></exception>
            <remarks>This implementation first looks for an <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompilationFilter"/> as an option from the 
            <paramref name="context"/>.  If one is obtained, its <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompilationFilter.Intercept(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/>
            method is called and, if it returns a non-null <see cref="T:System.Linq.Expressions.Expression"/>, then that expression is used.
            
            Otherwise, the normal behaviour is to attempt to resolve an <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder`1" /> (with <c>TTarget"</c>
            equal to the runtime type of the <paramref name="target" />) or <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder" /> whose
            <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder.CanBuild(System.Type)" /> function returns <c>true</c> for the given target and context.
            If that lookup fails, then an <see cref="T:System.ArgumentException" /> is raised.  If the lookup succeeds, then the builder's
            <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)" /> function is called, and the expression it
            produces is returned.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompiler.CreateContext(Rezolver.ResolveContext,Rezolver.ITargetContainer)">
            <summary>
            Implementation of <see cref="M:Rezolver.Compilation.ITargetCompiler.CreateContext(Rezolver.ResolveContext,Rezolver.ITargetContainer)"/>
            </summary>
            <param name="resolveContext"></param>
            <param name="targets"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionSwitcher">
             <summary>
             Replaces expressions within an expression tree with others.
            
             Expressions are compared by reference - so the class is most useful for replacing
             expressions like parameters or constants.
            
             When a replacement is deemed necessary, the visitor doesn't visit the replacement, it
             simply returns it in place of visiting the original.
             </summary>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionTargetBuilder">
             <summary>
             An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised for building the expression trees for the <see cref="T:Rezolver.Targets.ExpressionTarget"/>
             target type.
            
             This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard
             <see cref="T:Rezolver.ResolveContext"/> are turned into local variables with injected values), producing an expression which can
             be compiled by an <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompiler"/> after a <see cref="T:Rezolver.Compilation.Expressions.TargetExpressionRewriter"/> has been used to
             expand any targets embedded in the expression.
             </summary>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionTargetBuilder.ExpressionTranslator">
            <summary>
            rewrites the expression from an ExpressionTarget into something we can actually compile and use
            in the context of a call to a container's Resolve method.
            </summary>
            <seealso cref="T:System.Linq.Expressions.ExpressionVisitor" />
        </member>
        <member name="F:Rezolver.Compilation.Expressions.ExpressionTargetBuilder.ExpressionTranslator.RezolveMethods">
             <summary>
             The Resolve* operations which should be rewritten as ResolvedTargets.  Generic methods must have one type argument (which will
             be reused as the type that is resolved), non-generic methods must have a type parameter and the expression's argument MUST be
             a constant type.
            
             Note that these methods are used by index position in the Rewrites array a little further down - so if you change the order,
             be sure that the rewrites aren't affected.
             </summary>
        </member>
        <member name="F:Rezolver.Compilation.Expressions.ExpressionTargetBuilder.ExpressionTranslator.Rewrites">
            <summary>
            The rewrites
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionTargetBuilder.Build(Rezolver.Targets.ExpressionTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression for the given <paramref name="target"/>.
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.FactoryProviderTargetBuilder">
            <summary>
            Special compiler for <see cref="T:Rezolver.ITarget"/> instances which are also <see cref="T:Rezolver.IFactoryProvider"/> instances.
            
            Fetches the <see cref="P:Rezolver.IFactoryProvider.Factory"/> and builds an expression which represents invoking that factory
            with a new resolve context.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.FactoryProviderTargetBuilder.Build(Rezolver.IFactoryProvider,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Implementation of <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1.Build(`0,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/>
            </summary>
            <param name="target">The instance whose <see cref="P:Rezolver.IFactoryProvider.Factory"/> is to be invoked by the returned expression.</param>
            <param name="context">The compilation context</param>
            <param name="compiler">The compiler for which the expression is being built.</param>
            <returns>The created expression.</returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder">
            <summary>
            An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised for building expressions for <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> targets.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.Build(Rezolver.Targets.GenericConstructorTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Obtains the bound target for the <paramref name="target"/> passed (by calling
            <see cref="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/>, and passes it to the
            <paramref name="compiler"/> to have an expression built for it.
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.IExpressionBuilder">
            <summary>
            The interface for an object that produces expressions (which can be compiled to delegates)
            from <see cref="T:Rezolver.ITarget"/> instances.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.IExpressionBuilder.CanBuild(System.Type)">
            <summary>
            Determines whether this instance can build an expression for the specified target type.
            </summary>
            <param name="targetType">The type of target.</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression for the specified target.
            </summary>
            <param name="target">The target for which an expression is to be built</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">Optional. The compiler that's requesting the expression; and which can be used
            to compile other targets within the target.  If not provided, then the builder should attempt to
            fetch the compiler from the context; or throw an exception if it is required but not provided and
            cannot be resolved fromm the context.
            </param>
            <remarks>When invoked by the <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/> class, the <paramref name="compiler"/>
            parameter will always be provided.</remarks>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.IExpressionBuilder`1">
             <summary>
             Interface for an object that produces expressions from instances of <typeparamref name="TTarget"/>.
            
             This is a generic extension to the <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> interface.
             </summary>
             <typeparam name="TTarget">The type of the target.</typeparam>
             <seealso cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder" />
        </member>
        <member name="M:Rezolver.Compilation.Expressions.IExpressionBuilder`1.Build(`0,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression from the specified target.
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">Optional. The compiler that's requesting the expression; and which can be used
            to compile other targets within the target.  If not provided, then the builder should attempt to
            fetch the compiler from the context; or throw an exception if it is required but not provided and
            cannot be resolved fromm the context.
            </param>
            <remarks>When invoked by the <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/> class, the <paramref name="compiler"/>
            parameter will always be provided.</remarks>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.IExpressionCompilationFilter">
            <summary>
            When the <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/> is asked to compile a given target for the given context,
            the compiler will first attempt to obtain an instance of this type as an option from the context.
            
            If one is set, then it will be consulted to see if it can offer up an expression for the given target
            instead of the compiler doing its normal process.
            </summary>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.IExpressionCompileContext">
            <summary>
            Extension to the <see cref="T:Rezolver.Compilation.ICompileContext"/> interface which provides additional state
            and functionality for the <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompiler"/> and the <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> implementations
            which are used by the default expression compiler, the <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/> class.
            </summary>
            <seealso cref="T:Rezolver.Compilation.ICompileContext" />
        </member>
        <member name="P:Rezolver.Compilation.Expressions.IExpressionCompileContext.ParentContext">
            <summary>
            Gets the parent context.
            </summary>
            <remarks>Note that this property hides the inherited <see cref="P:Rezolver.Compilation.ICompileContext.ParentContext"/> property,
            since an <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext"/> can only be a child of another <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext"/>.</remarks>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.IExpressionCompileContext.ResolveContextParameterExpression">
            <summary>
            This is the parameter expression which represents the <see cref="T:Rezolver.ResolveContext" /> that is passed to the
            factory delegate at resolve-time.
            </summary>
            <remarks>If the code produced by the <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> for a given target needs to read or use the
            <see cref="T:Rezolver.ResolveContext"/> that was originally passed to the <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> method,
            then it does it by using this expression, which will be set as the only parameter on the lambda expression which is
            eventually compiled (in the case of the default expression compiler, <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/>.</remarks>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.IExpressionCompileContext.SharedExpressions">
            <summary>
            Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context or added
            via calls to <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompileContext.GetOrAddSharedExpression(System.Type,System.String,System.Func{System.Type,System.String,System.Linq.Expressions.Expression},System.Type)"/> or
            <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompileContext.GetOrAddSharedLocal(System.Type,System.String,System.Type)"/>.
            </summary>
            <value>The shared expressions.</value>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.IExpressionCompileContext.NewContext(System.Type,System.Boolean,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})">
            <summary>
            Creates a new <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext"/> using this one as a seed.  This function is identical to
            <see cref="M:Rezolver.Compilation.ICompileContext.NewContext(System.Type,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})"/> but allows you to control whether the <see cref="P:Rezolver.Compilation.Expressions.IExpressionCompileContext.SharedExpressions"/>
            are inherited (the default); and is more convenient because it returns another <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext"/>.
            </summary>
            <param name="targetType">Optional.  The type for which the target is to be compiled, if different from this
            context's <see cref="P:Rezolver.Compilation.CompileContext.TargetType"/>.</param>
            <param name="inheritSharedExpressions">If <c>true</c> then the shared expressions in this context will be inherited
            by the new context by reference.  That is, when the new context goes out of scope, any new shared expressions it created
            will still be available.
            If false, then the new context will get a brand new, empty, set of shared expressions.</param>
            <param name="scopeBehaviourOverride">Override the <see cref="P:Rezolver.Compilation.CompileContext.ScopeBehaviourOverride"/> to be used for the target that is compiled with the new context.
            This is never inherited automatically from one context to another.</param>
            <param name="scopePreferenceOverride">Sets the <see cref="P:Rezolver.Compilation.ICompileContext.ScopePreferenceOverride"/>.  As soon as this is set on one context, it is automatically
            inherited by all its child contexts (i.e. you cannot null it)</param>
            <remarks>When you have a reference to an <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompileContext"/> the compiler will favour this method to
            the one defined on the <see cref="T:Rezolver.Compilation.ICompileContext"/> interface because it is 'closer', even if you do not explicitly provide
            an argument for the <paramref name="inheritSharedExpressions"/> parameter.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.IExpressionCompileContext.GetOrAddSharedExpression(System.Type,System.String,System.Func{System.Type,System.String,System.Linq.Expressions.Expression},System.Type)">
            <summary>
            Gets or adds an expression which is potentially shared between multiple targets' expression trees.
            </summary>
            <param name="type">Required - the type of the expression.</param>
            <param name="name">Required - the caller-defined name for this expression.</param>
            <param name="expressionFactory">Required - Delegate to call to create the expression if it does not already exist.</param>
            <param name="requestingType">Optional - the type of the object requesting this shared expression.  If this is provided,
            then the search for an existing shared expression will only work if the same requesting type was passed previously.</param>
            <remarks>Using shared expressions opens the door to potentially multiple optimisations, depending on the type of
            expression in question.  For example, conditional expressions which share the same operand and comparand can all be
            merged into one with all the 'true' and 'false' branches being combined into one of each, thus saving multiple identical
            comparisons.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.IExpressionCompileContext.GetOrAddSharedLocal(System.Type,System.String,System.Type)">
            <summary>
            Similar to <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompileContext.GetOrAddSharedExpression(System.Type,System.String,System.Func{System.Type,System.String,System.Linq.Expressions.Expression},System.Type)"/>, except this is used when expression
            builders want to use local variables in block expressions to store the result of some operation in the expression tree built
            for a particular target.  Reusing one local variable is more efficient than declaring the same local multiple times.
            </summary>
            <param name="type">The type.</param>
            <param name="name">The name.</param>
            <param name="requestingType">Optional - the type of the object requesting this shared expression.  If this is provided,
            then the search for an existing shared expression will only work if the same requesting type was passed previously.</param>
            <remarks>When multiple expression trees from multiple targets are brought together into one lambda, there will
            often be many duplicate variables which could be shared.  So, if an <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> needs a local variable
            for a block, instead of simply declaring it directly through the <see cref="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)"/> function,
            it can use this function instead, which will return a previously created one if available.</remarks>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions">
            <summary>
            Extensions for <see cref="T:Rezolver.Compilation.Expressions.IExpressionCompiler"/>.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.BuildResolveLambda(Rezolver.Compilation.Expressions.IExpressionCompiler,Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)">
            <summary>
            This method is a shortcut for building a lambda expression directly from an <see cref="T:Rezolver.ITarget" />.
            It calls <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompiler.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)" /> and passes the result to
            <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompiler.BuildObjectFactoryLambda(System.Linq.Expressions.Expression,Rezolver.Compilation.Expressions.IExpressionCompileContext)" />, which should yield an
            optimised lambda expression for the expression produced from the target which can then be
            compiled and used as the factory for that target.
            </summary>
            <param name="compiler">The compiler.</param>
            <param name="target">The target.</param>
            <param name="context">The current compilation context.</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.BuildResolveLambdaStrong(Rezolver.Compilation.Expressions.IExpressionCompiler,Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)">
            <summary>
            Similar to <see cref="M:Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.BuildResolveLambda(Rezolver.Compilation.Expressions.IExpressionCompiler,Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/>, except this builds a
            lambda whose type is a strongly-typed delegate instead of object - i.e. Func{ResolveContext, T}
            </summary>
            <param name="compiler"></param>
            <param name="target"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.IExpressionCompiler">
             <summary>
             Interface for an object which is responsible for coordinating the production of expressions for targets
             during the compilation phase.
            
             Objects implementing this are expected to be implementations of <see cref="T:Rezolver.Compilation.ITargetCompiler"/>; this library
             provides the one implementation, too: <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/>.
             </summary>
             <remarks>
             All expressions are built to be called by a container's <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/>.
            
             Note that the <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompiler.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> method declared here is effectively an
             analogue to the <see cref="M:Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/>.  Indeed, the default
             implementation resolves <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> instances to delegate the building of expressions.
             </remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.IExpressionCompiler.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)">
             <summary>
             Gets an unoptimised expression containing the logic required to create or fetch an instance of the <paramref name="target"/>'s
             <see cref="P:Rezolver.ITarget.DeclaredType"/> when invoked for a particular <see cref="T:Rezolver.ResolveContext"/>.
            
             Use this method if you want the raw expression for a target (possibly when integrating it into your own expressions during custom
             compilation).
             </summary>
             <param name="target">The target.</param>
             <param name="context">Contains the supporting expressions (shared locals, shared expressions,
             ResolveContext expression etc) that have been used in the generation of the expression.</param>
             <remarks>
            
             If you want to build the optimised code for the passed target, you should use the
             <see cref="M:Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.BuildResolveLambda(Rezolver.Compilation.Expressions.IExpressionCompiler,Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/>
             extension method, which uses this method and then passes the result to the
             <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompiler.BuildObjectFactoryLambda(System.Linq.Expressions.Expression,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> function also defined on
             this interface.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.IExpressionCompiler.BuildObjectFactoryLambda(System.Linq.Expressions.Expression,Rezolver.Compilation.Expressions.IExpressionCompileContext)">
             <summary>
             This function optimises and prepares an expression that's (most likely) previously been
             produced by the <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompiler.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> function into a
             lambda expression which can be compiled into a delegate and executed; or quoted inside
             another expression as a callback.
            
             The <see cref="P:Rezolver.Compilation.Expressions.IExpressionCompileContext.ResolveContextParameterExpression"/> of the
             <paramref name="context"/> will be used to define the single parameter for the lambda that
             is created.
             </summary>
             <param name="expression">Expression to be optimised and used as the body of the lambda.
             Any expression produced by the <see cref="M:Rezolver.Compilation.Expressions.IExpressionCompiler.Build(Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext)"/> method
             must be compatible with this.</param>
             <param name="context">Contains the supporting expressions (shared locals, shared expressions,
             ResolveContext expression etc) that have been used in the generation of the expression.</param>
             <returns>A lambda expression which, when compiled and executed, will produce an object
             consistent with the <see cref="T:Rezolver.ITarget"/> from which the code was produced.</returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.IExpressionCompiler.BuildStrongFactoryLambda(System.Linq.Expressions.Expression,Rezolver.Compilation.Expressions.IExpressionCompileContext)">
            <summary>
            Builds a delegate whose type is `Func{<see cref="T:Rezolver.ResolveContext"/>, {Type}}` where `{Type}` is equal
            to the static <see cref="P:System.Linq.Expressions.Expression.Type"/> of the <paramref name="expression"/>
            </summary>
            <param name="expression">Expression to be optimised and used as the body of the lambda.</param>
            <param name="context">Contains the supporting expressions (shared locals, shared expressions,
            ResolveContext expression etc) that have been used in the generation of the expression.</param>
            <returns>A lambda expression which is strongly type for <see cref="T:System.Func`2"/> with `TResult`
            equal to the type of the input expression; and `T` equal to <see cref="T:Rezolver.ResolveContext"/>.</returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.InstanceProviderTargetBuilder">
            <summary>
            Special compiler for instances of <see cref="T:Rezolver.IInstanceProvider"/> which binds to the <see cref="M:Rezolver.IInstanceProvider.GetInstance(Rezolver.ResolveContext)"/>
            method in the expression.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.InstanceProviderTargetBuilder.Build(Rezolver.IInstanceProvider,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Implementation of <see cref="M:Rezolver.Compilation.Expressions.ExpressionBuilderBase`1.Build(`0,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/>
            </summary>
            <param name="target">The instance whose <see cref="M:Rezolver.IInstanceProvider.GetInstance(Rezolver.ResolveContext)"/> method is to be called
            by the returned expression.</param>
            <param name="context">The compilation context</param>
            <param name="compiler">The compiler for which the expression is being built.</param>
            <returns>The created expression</returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ListTargetBuilder">
            <summary>
            An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised for building expressions for the <see cref="T:Rezolver.Targets.ListTarget"/> target.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ListTargetBuilder.Build(Rezolver.Targets.ListTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
             <summary>
             Builds an expression which either represents creating an array or a list of objects using an
             enumerable of targets from the <paramref name="target"/>'s <see cref="P:Rezolver.Targets.ListTarget.Items"/>.
            
             The target's <see cref="P:Rezolver.Targets.ListTarget.AsArray"/> flag is used to determine which expression to build.
             </summary>
             <param name="target">The target whose expression is to be built.</param>
             <param name="context">The compilation context.</param>
             <param name="compiler">The expression compiler to be used to build any other expressions for targets
             which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
             parameter is optional, this will always be provided</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.NewExpressionMemberInitRewriter">
            <summary>
            Rewrites the first NewExpression found for a particular type into a <see cref="T:System.Linq.Expressions.MemberInitExpression"/>
            with the given bindings.  If no type is specified on construction, then the first NewExpression that
            is encountered will be used.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.NewExpressionMemberInitRewriter.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
             <summary>
            
             </summary>
             <param name="ctorType"></param>
             <param name="newBindings"></param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ObjectTargetBuilder">
            <summary>
            An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised to build expressions for the <see cref="T:Rezolver.Targets.ObjectTarget"/> target.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ObjectTargetBuilder.Build(Rezolver.Targets.ObjectTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            returns a ConstantExpression wrapped around the <see cref="P:Rezolver.Targets.ObjectTarget.Value"/> reference.
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder">
            <summary>
            An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised for building an expression for the <see cref="T:Rezolver.Targets.OptionalParameterTarget"/> target.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.Build(Rezolver.Targets.OptionalParameterTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Always returns a <see cref="T:System.Linq.Expressions.ConstantExpression"/> which contains the <see cref="P:Rezolver.Targets.OptionalParameterTarget.Value"/>.
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ProjectionTargetBuilder">
            <summary>
            Specialised expression builder for the <see cref="T:Rezolver.Targets.ProjectionTarget"/> target type.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ProjectionTargetBuilder.Build(Rezolver.Targets.ProjectionTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression for the passed <paramref name="target"/>
            </summary>
            <param name="target"></param>
            <param name="context"></param>
            <param name="compiler"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.RedundantConvertRewriter">
             <summary>
             Removes unnecessary convert expressions from an expression.
            
             An unnecessary conversion is one where the target type is equal to, or a base of, the source type.
            
             Only boxing/unboxing conversions or upcasts are left intact.
             </summary>
             <seealso cref="T:System.Linq.Expressions.ExpressionVisitor" />
        </member>
        <member name="M:Rezolver.Compilation.Expressions.RedundantConvertRewriter.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            Visits the children of the <see cref="T:System.Linq.Expressions.UnaryExpression" />.
            </summary>
            <param name="node">The expression to visit.</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.RezolvedTargetBuilder">
            <summary>
            An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised for building the expression for the <see cref="T:Rezolver.Targets.ResolvedTarget"/> target.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.RezolvedTargetBuilder.Build(Rezolver.Targets.ResolvedTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression for the given <paramref name="target"/>.
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.ScopedTargetBuilder">
            <summary>
            An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised for building expressions for <see cref="T:Rezolver.Targets.ScopedTarget"/> targets.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.ScopedTargetBuilder.Build(Rezolver.Targets.ScopedTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression for the given <paramref name="target"/>.
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.SharedExpressionKey">
            <summary>
            Key for a shared expression used during expression tree generation.  As a consumer of this library, you
            are unlikely ever to need to use it.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.SharedExpressionKey.RequestingType">
            <summary>
            Gets the type that registered the shared expression
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.SharedExpressionKey.TargetType">
            <summary>
            The intended type of the expression that is cached by this key.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.SharedExpressionKey.Name">
            <summary>
            Gets the name used for expressions that are cached using this key.
            </summary>
            <value>The name.</value>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.SharedExpressionKey.#ctor(System.Type,System.String,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Compilation.Expressions.SharedExpressionKey"/> class.
            </summary>
            <param name="targetType">Required. Eventual runtime type of the object produced by the expression that will be cached using this key.</param>
            <param name="name">Required. The name used for storing and retrieving expressions cached with this key.</param>
            <param name="requestingType">The type (e.g. the runtime type of an <see cref="T:Rezolver.ITarget"/> implementation) whose compilation requires the cached expression.</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.SharedExpressionKey.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.SharedExpressionKey.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.SharedExpressionKey.Equals(Rezolver.Compilation.Expressions.SharedExpressionKey)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.SingletonTargetBuilder">
            <summary>
            An <see cref="T:Rezolver.Compilation.Expressions.IExpressionBuilder"/> specialised for the building the expression for a <see cref="T:Rezolver.Targets.SingletonTarget"/> target.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.SingletonTargetBuilder.Build(Rezolver.Targets.SingletonTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression for the given <paramref name="target"/>.
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.SingletonTargetBuilder.ApplyScoping(System.Linq.Expressions.Expression,Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Overrides the base to prevent additional scoping information being added to the expression returned by <see cref="M:Rezolver.Compilation.Expressions.SingletonTargetBuilder.Build(Rezolver.Targets.SingletonTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)"/>
            </summary>
            <param name="builtExpression"></param>
            <param name="target"></param>
            <param name="context"></param>
            <param name="compiler"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.TargetExpression">
             <summary>
             An expression which represents an <see cref="T:Rezolver.ITarget" />, allowing a target with a particular <see cref="P:Rezolver.ITarget.DeclaredType"/> to be
             used in place of a traditional expression.
             </summary>
             <remarks>The <see cref="T:Rezolver.Compilation.Expressions.ExpressionTargetBuilder"/> uses this class extensively when translating expressions
             into targets and back again.  It's *highly* unlikely you'll need to use it in your code.
            
             It acts as a placeholder for targets until the point at which the expression compiler wants to build a
             complete expression tree for a target.</remarks>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.TargetExpression.Target">
            <summary>
            Gets the target whose expression will be subsituted for this TargetExpression in the final expression tree.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.TargetExpression.Type">
            <summary>
            Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.
            </summary>
            <remarks>Always returns the type referenced by the <see cref="P:Rezolver.ITarget.DeclaredType"/> property
            of <see cref="P:Rezolver.Compilation.Expressions.TargetExpression.Target"/>.</remarks>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.TargetExpression.NodeType">
            <summary>
            Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.
            </summary>
            <value>Always returns <see cref="F:System.Linq.Expressions.ExpressionType.Extension"/>.</value>
        </member>
        <member name="P:Rezolver.Compilation.Expressions.TargetExpression.CanReduce">
            <summary>
            Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.
            </summary>
            <value><c>true</c> if this instance can reduce; otherwise, <c>false</c>.</value>
            <remarks>The implementation always returns <c>true</c>; although the <see cref="M:Rezolver.Compilation.Expressions.TargetExpression.Reduce"/> methodd is not implemented.</remarks>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.TargetExpression.Reduce">
            <summary>
            Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.
            </summary>
            <exception cref="T:System.NotSupportedException">RezolveTargetExpression must be rewritten as a bona-fide expression before walking the expression tree for any other purpose</exception>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.TargetExpression.#ctor(Rezolver.ITarget)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Compilation.Expressions.TargetExpression"/> class.
            </summary>
            <param name="target">The target.</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.UnscopedTargetBuilder">
            <summary>
            Builder for the <see cref="T:Rezolver.Targets.UnscopedTarget"/>.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.UnscopedTargetBuilder.ApplyScoping(System.Linq.Expressions.Expression,Rezolver.ITarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            overrides the base method to block all automatic scoping code from the expression being built.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.UnscopedTargetBuilder.Build(Rezolver.Targets.UnscopedTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds an expression for the given <paramref name="target"/>.
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.  Note that unlike on the interface, where this
            parameter is optional, this will always be provided</param>
        </member>
        <member name="T:Rezolver.Compilation.Expressions.VariantMatchTargetBuilder">
            <summary>
            Expression builder for the <see cref="T:Rezolver.Targets.VariantMatchTarget"/>
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.Expressions.VariantMatchTargetBuilder.Build(Rezolver.Targets.VariantMatchTarget,Rezolver.Compilation.Expressions.IExpressionCompileContext,Rezolver.Compilation.Expressions.IExpressionCompiler)">
            <summary>
            Builds the conversion expression represented by the <paramref name="target"/>
            </summary>
            <param name="target">The target whose expression is to be built.</param>
            <param name="context">The compilation context.</param>
            <param name="compiler">The expression compiler to be used to build any other expressions for targets
            which might be required by the <paramref name="target" />.</param>
        </member>
        <member name="T:Rezolver.Compilation.ICompileContext">
             <summary>
             Tracks state and provides services during the compilation phase in which <see cref="T:Rezolver.ITarget"/> targets
             are compiled into <see cref="T:System.Func`2"/> factories.
            
             Instances of this interface are created by calling the
             <see cref="M:Rezolver.Compilation.ITargetCompiler.CreateContext(Rezolver.ResolveContext,Rezolver.ITargetContainer)"/> method of the <see cref="T:Rezolver.Compilation.ITargetCompiler"/>
             which is registered in a container.
             </summary>
             <seealso cref="T:Rezolver.ITargetContainer" />
             <remarks>
             Implementations must also implement the <see cref="T:Rezolver.ITargetContainer"/> so the compile context can be used for
             dependency lookups during compilation time.  Indeed, if you are developing your own compilation component (possibly
             for a custom <see cref="T:Rezolver.ITarget"/> implementation) and need to resolve any dependencies from an <see cref="T:Rezolver.ITargetContainer"/>
             during compilation, it should be done through the context's implementation of <see cref="T:Rezolver.ITargetContainer"/>.</remarks>
        </member>
        <member name="P:Rezolver.Compilation.ICompileContext.ParentContext">
            <summary>
            Gets the parent context from which this context was created, if applicable.
            </summary>
            <value>The parent context.</value>
        </member>
        <member name="P:Rezolver.Compilation.ICompileContext.ScopeBehaviourOverride">
             <summary>
             If not <c>null</c> then this overrides the <see cref="P:Rezolver.ITarget.ScopeBehaviour"/> of the <see cref="T:Rezolver.ITarget"/>
             that's currently being compiled.
            
             Note that this is not automatically inherited from one context to another
             </summary>
        </member>
        <member name="P:Rezolver.Compilation.ICompileContext.ScopePreferenceOverride">
             <summary>
             Same as <see cref="P:Rezolver.Compilation.ICompileContext.ScopeBehaviourOverride"/> but this is used to override currently compiling target's
             <see cref="P:Rezolver.ITarget.ScopePreference"/>.
            
             Typically used, for example, when a singleton is compiling other targets.
             </summary>
        </member>
        <member name="P:Rezolver.Compilation.ICompileContext.TargetType">
            <summary>
            Any factory built for a <see cref="T:Rezolver.ITarget"/> with this context should target this type.
            If null, then the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the target being compiled should be used.
            </summary>
        </member>
        <member name="P:Rezolver.Compilation.ICompileContext.CompileStack">
            <summary>
            Gets the stack entries for all the targets that are being compiled.
            </summary>
            <value>The compile stack.</value>
        </member>
        <member name="P:Rezolver.Compilation.ICompileContext.ResolveContext">
             <summary>
             The context for which this compilation context was created.
            
             Provides access to the current container, scope and more besides
             </summary>
        </member>
        <member name="M:Rezolver.Compilation.ICompileContext.NewContext(System.Type,System.Nullable{Rezolver.ScopeBehaviour},System.Nullable{Rezolver.ScopePreference})">
             <summary>
             Creates a new child context from this one, except the <see cref="P:Rezolver.Compilation.ICompileContext.TargetType"/> and
             <see cref="P:Rezolver.Compilation.ICompileContext.ScopeBehaviourOverride"/> properties can be overriden if required.
            
             Implementations must make sure that the <see cref="P:Rezolver.Compilation.ICompileContext.ScopeBehaviourOverride"/>
             is *never* inherited.
             </summary>
             <param name="targetType">Optional.  The type for which the target is to be compiled, if different from this context's <see cref="P:Rezolver.Compilation.ICompileContext.TargetType"/>.</param>
             <param name="scopeBehaviourOverride">Value for the <see cref="P:Rezolver.Compilation.ICompileContext.ScopeBehaviourOverride"/> to be used for the target that is compiled with the new context.
             This is never inherited automatically from one context to another.</param>
             <param name="scopePreferenceOverride">Sets the <see cref="P:Rezolver.Compilation.ICompileContext.ScopePreferenceOverride"/>.  As soon as this is set on one context, it is automatically
             inherited by all its child contexts (i.e. you cannot null it)</param>
             <returns>A new <see cref="T:Rezolver.Compilation.ICompileContext" />.</returns>
        </member>
        <member name="M:Rezolver.Compilation.ICompileContext.PopCompileStack">
            <summary>
            Pops the compile stack, returning the entry that was popped.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.ICompileContext.PushCompileStack(Rezolver.ITarget,System.Type)">
            <summary>
            Pushes the passed target on to the compile stack if it's not already on it for the same <see cref="P:Rezolver.Compilation.ICompileContext.TargetType" />
            Compilers should consult the return value and abort compilation if it's <c>true</c> - since that implies a cyclic
            dependency graph.
            </summary>
            <param name="toCompile">To compile.</param>
            <param name="targetType">The type for which the target is being compiled, if different from <see cref="P:Rezolver.ITarget.DeclaredType"/></param>
            <remarks>Targets can appear on the compilation stack more than once for different types, since the factory
            produced for a target for one type can be different than it is for another.  Ultimately, if a target does in fact have a
            cyclic dependency graph, then this method will detect that.</remarks>
        </member>
        <member name="T:Rezolver.Compilation.ITargetCompiler">
            <summary>
            An object that produces factories from <see cref="T:Rezolver.ITarget"/>s given a
            particular <see cref="T:Rezolver.Compilation.ICompileContext"/> - for which it also acts as a factory.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.ITargetCompiler.CompileTarget(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)">
            <summary>
            Create the factory for the given <paramref name="target"/> using the <paramref name="context"/>
            to inform the type of object that is to be built, and for compile-time dependency resolution.
            </summary>
            <param name="target">Required.  The target to be compiled.</param>
            <param name="context">Required.  The compilation context to use for compilation.  Obtain this by calling
            <see cref="M:Rezolver.Compilation.ITargetCompiler.CreateContext(Rezolver.ResolveContext,Rezolver.ITargetContainer)"/>.</param>
            <returns>A factory which can then be used to get instances represented by the <paramref name="target"/>.</returns>
        </member>
        <member name="M:Rezolver.Compilation.ITargetCompiler.CompileTarget``1(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)">
            <summary>
            Creates a strongly-types generic factory for the given <paramref name="target"/> using the
            <paramref name="context"/>.
            </summary>
            <typeparam name="TService">The type of instance to be produced by the resulting factory.</typeparam>
            <param name="target">Required. The target to be compiled.</param>
            <param name="context">Required. The compilation context to use for compilation. Obtain this by calling
            <see cref="M:Rezolver.Compilation.ITargetCompiler.CreateContext(Rezolver.ResolveContext,Rezolver.ITargetContainer)"/>.</param>
            <returns>A strongly-typed factory which can then be used to get instances represented by the <paramref name="target"/>.</returns>
        </member>
        <member name="M:Rezolver.Compilation.ITargetCompiler.CreateContext(Rezolver.ResolveContext,Rezolver.ITargetContainer)">
            <summary>
            Creates a compilation context for the given <paramref name="resolveContext"/> - which is used to determine
            the <see cref="P:Rezolver.ResolveContext.RequestedType"/> that the factory which is eventually compiled should return
            (through either the <see cref="M:Rezolver.Compilation.ITargetCompiler.CompileTarget(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)"/> or <see cref="M:Rezolver.Compilation.ITargetCompiler.CompileTarget``1(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)"/> methods).
            </summary>
            <param name="resolveContext">The resolve context - used to get the <see cref="P:Rezolver.ResolveContext.RequestedType"/>
            and the <see cref="P:Rezolver.ResolveContext.Container"/>, and will be set on the <see cref="P:Rezolver.Compilation.ICompileContext.ResolveContext"/>
            property of the returned context.</param>
            <param name="targets">The target container that should be used to lookup other non-compiled targets.</param>
        </member>
        <member name="T:Rezolver.Compilation.TargetCompilerExtensions">
            <summary>
            Extensions for the <see cref="T:Rezolver.Compilation.ITargetCompiler"/> interface.
            </summary>
        </member>
        <member name="M:Rezolver.Compilation.TargetCompilerExtensions.CompileTargetStrong(Rezolver.Compilation.ITargetCompiler,Rezolver.ITarget,Rezolver.Compilation.ICompileContext)">
            <summary>
            Performs a late-bound compilation of a strongly-typed delegate for the <paramref name="target" />.
            The type of the returned delegate will be <see cref="T:System.Func`2" />, with `TResult` equal to
            the <see cref="P:Rezolver.Compilation.ICompileContext.TargetType" /> of the <paramref name="context" />.
            </summary>
            <param name="compiler">The compiler.</param>
            <param name="target">The target.</param>
            <param name="context">The context.</param>
            <returns>A compiled delegate</returns>
            <exception cref="T:System.ArgumentNullException">If any of <paramref name="compiler"/>, <paramref name="context"/> or <paramref name="target"/> are null.</exception>
        </member>
        <member name="M:Rezolver.Compilation.TargetCompilerExtensions.CompileTarget(Rezolver.Compilation.ITargetCompiler,Rezolver.ITarget,Rezolver.ResolveContext,Rezolver.ITargetContainer)">
            <summary>
            Compiles the <paramref name="target"/> by calling the
            <see cref="M:Rezolver.Compilation.ITargetCompiler.CompileTarget(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)"/> method of the passed
            <paramref name="compiler"/>, passing an <see cref="T:Rezolver.Compilation.ICompileContext"/> created first by calling
            its <see cref="M:Rezolver.Compilation.ITargetCompiler.CreateContext(Rezolver.ResolveContext,Rezolver.ITargetContainer)"/> method.
            </summary>
            <param name="compiler">Required.  The compiler which will carry out the compilation</param>
            <param name="target">Required.  The target to be compiled.</param>
            <param name="resolveContext">Required.  The current <see cref="T:Rezolver.ResolveContext"/>.</param>
            <param name="targets">Required.  Used to locate dependencies during compilation.</param>
            <returns>A delegate representing the passed <paramref name="target"/>, ready to be executed
            to obtain an object which satisfies the <see cref="P:Rezolver.ResolveContext.RequestedType"/> in the
            <paramref name="resolveContext"/>.</returns>
        </member>
        <member name="M:Rezolver.Compilation.TargetCompilerExtensions.CompileTarget``1(Rezolver.Compilation.ITargetCompiler,Rezolver.ITarget,Rezolver.ResolveContext,Rezolver.ITargetContainer)">
            <summary>
            Strongly-typed version of <see cref="M:Rezolver.Compilation.TargetCompilerExtensions.CompileTarget(Rezolver.Compilation.ITargetCompiler,Rezolver.ITarget,Rezolver.ResolveContext,Rezolver.ITargetContainer)"/> when the
            <typeparamref name="TService"/> is known at compile-time.
            </summary>
            <typeparam name="TService">The type of object to be returned by the factory.S</typeparam>
            <param name="compiler">Required.  The compiler.</param>
            <param name="target">Required.  The target to be compiled.</param>
            <param name="resolveContext">Required.  The current <see cref="T:Rezolver.ResolveContext"/></param>
            <param name="targets">Required.  Used to locate dependencies during compilation.</param>
            <returns>A strongly-typed delegate representing the passed <paramref name="target"/>.
            Invoking this delegate should produce an instance of the type <typeparamref name="TService"/>.</returns>
        </member>
        <member name="T:Rezolver.WellKnownFactories">
            <summary>
            Contains an extension to test the validity of factories.
            </summary>
        </member>
        <member name="M:Rezolver.WellKnownFactories.IsUnresolved(System.Func{Rezolver.ResolveContext,System.Object})">
            <summary>
            Returns true if <paramref name="factory"/> represents a failed dependency lookup.
            </summary>
            <param name="factory">Required.  The factory to be checked.</param>
        </member>
        <member name="T:Rezolver.Configuration.Configure">
            <summary>
            Provides factory methods for the <see cref="T:Rezolver.Configuration.Configure`1"/> generic class for when you need to
            create a configuration object for a specific option outside of the functionality provided by the
            <see cref="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,``0)"/> function and
            its various overloads.
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.Configure.Option``1(``0,System.Type)">
            <summary>
            Wraps the <see cref="M:Rezolver.Configuration.Configure`1.#ctor(`0,System.Type)"/> constructor.
            </summary>
            <typeparam name="TOption">The type of option to be set.</typeparam>
            <param name="value">The value that the option is to be set to.</param>
            <param name="serviceType">If the option is to be configured for a specific type of service in the target container,
            pass it here.</param>
            <returns>A new <see cref="T:Rezolver.Configuration.Configure`1"/> instance</returns>
        </member>
        <member name="M:Rezolver.Configuration.Configure.Option``2(``0)">
            <summary>
            Wraps the <see cref="M:Rezolver.Configuration.Configure`1.#ctor(`0,System.Type)"/> constructor, passing
            <typeparamref name="TService"/> as the argument to the <c>serviceType</c> parameter.
            </summary>
            <typeparam name="TOption">The type of option to be set</typeparam>
            <typeparam name="TService">The type of service against which the option will be set.</typeparam>
            <param name="value">The value the option is to be set to.</param>
            <returns>A new <see cref="T:Rezolver.Configuration.Configure`1"/> instance</returns>
        </member>
        <member name="M:Rezolver.Configuration.Configure.Option``1(System.Func{Rezolver.ITargetContainer,System.Type,``0},System.Type)">
            <summary>
            Wraps the <see cref="M:Rezolver.Configuration.Configure`1.#ctor(System.Func{Rezolver.ITargetContainer,System.Type,`0},System.Type)"/>.
            </summary>
            <typeparam name="TOption">The type of option to be set</typeparam>
            <param name="optionFactory">A callback that will be used to obtain the option value to be set.</param>
            <param name="serviceType">If the option is to be configured for a specific type of service in the target container,
            pass it here.</param>
            <returns>A new <see cref="T:Rezolver.Configuration.Configure`1"/> instance</returns>
        </member>
        <member name="M:Rezolver.Configuration.Configure.Option``2(System.Func{Rezolver.ITargetContainer,System.Type,``0})">
            <summary>
            Wraps the <see cref="M:Rezolver.Configuration.Configure`1.#ctor(System.Func{Rezolver.ITargetContainer,System.Type,`0},System.Type)"/> constructor,
            passing <typeparamref name="TService"/> as the argument to the <c>serviceType</c> parameter.
            </summary>
            <typeparam name="TOption">The type of option to be set</typeparam>
            <typeparam name="TService">The type of service against which the option will be set.</typeparam>
            <param name="optionFactory">A callback that will be used to obtain the option value to be set.</param>
            <returns>A new <see cref="T:Rezolver.Configuration.Configure`1"/> instance</returns>
        </member>
        <member name="T:Rezolver.Configuration.Configure`1">
             <summary>
             An <see cref="T:Rezolver.ITargetContainerConfig"/> implementation specialised for setting options in an <see cref="T:Rezolver.ITargetContainer"/> when
             <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/> is called.
            
             This class' implementation of that method is actually handled by the <see cref="M:Rezolver.Configuration.Configure`1.ConfigureOption(Rezolver.ITargetContainer)"/> method.
             </summary>
             <typeparam name="TOption">The type of option to be set.  Will ultimately be passed through to the
             <see cref="M:Rezolver.TargetContainerExtensions.SetOption``1(Rezolver.ITargetContainer,``0,System.Type)"/> method when the option is set.</typeparam>
             <remarks>This class is most often used to modify the options which are set in the <see cref="P:Rezolver.TargetContainer.DefaultConfig"/> of the
             <see cref="T:Rezolver.TargetContainer"/> class - but can, of course, be used to configure any <see cref="T:Rezolver.ITargetContainer"/>.
            
             The class implements the generic <see cref="T:Rezolver.ITargetContainerConfig`1"/> interface, so that it's possible for other configuration
             objects to declare a (required or optional) dependency on anything which configures that option - so that it can ensure that those
             options are set beforehand.
            
             The <see cref="T:Rezolver.Configuration.InjectEnumerables"/> configuration type, for example, expresses an optional dependency on an <see cref="T:Rezolver.ITargetContainerConfig`1"/>
             which has a <typeparamref name="TOption"/> type equal to <see cref="T:Rezolver.Options.EnableEnumerableInjection"/>.</remarks>
        </member>
        <member name="M:Rezolver.Configuration.Configure`1.#ctor(`0,System.Type)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Configuration.Configure`1"/> class which, when
            <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/> is called with a particular <see cref="T:Rezolver.ITargetContainer"/>,
            will set the option to the <paramref name="optionValue"/>, optionally for the given <paramref name="serviceType"/>
            </summary>
            <param name="optionValue">The value to set the option to when the configuration is applied to the target container</param>
            <param name="serviceType">Optional - service type for which the option is to be set (use of this is option-dependent - not all options
            are read in a service-specific manner)</param>
        </member>
        <member name="M:Rezolver.Configuration.Configure`1.#ctor(System.Func{Rezolver.ITargetContainer,System.Type,`0},System.Type)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Configuration.Configure`1"/> class which, when
            <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/> is called with a particular <see cref="T:Rezolver.ITargetContainer"/>,
            will set the option to the value returned by <paramref name="optionFactory"/>, optionally for the given <paramref name="serviceType"/>
            </summary>
            <param name="optionFactory">The factory to be executed to obtain the option value</param>
            <param name="serviceType">Optional - service type for which the option is to be set (use of this is option-dependent - not all options
            are read in a service-specific manner)</param>
        </member>
        <member name="M:Rezolver.Configuration.Configure`1.Rezolver#ITargetContainerConfig#Configure(Rezolver.IRootTargetContainer)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/> - uses the
            <see cref="M:Rezolver.Configuration.Configure`1.ConfigureOption(Rezolver.ITargetContainer)"/> method.
            </summary>
            <param name="targets">The target container into which the option is to be set.</param>
        </member>
        <member name="M:Rezolver.Configuration.Configure`1.ConfigureOption(Rezolver.ITargetContainer)">
             <summary>
             Sets the option value (either passed as a constant
             reference on construction, or obtained via a callback) in the <paramref name="targets"/> target container.
            
             This is used as the implementation of <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/>.
             </summary>
             <param name="targets">The target container into which the option is to be set.</param>
        </member>
        <member name="T:Rezolver.Configuration.ExpressionCompilation">
             <summary>
             Implementation of <see cref="T:Rezolver.IContainerConfig"/> which configures expression-based compilation for targets in containers.
            
             The implementation sets all options and registers all the targets necessary to use the expression tree-based compilation provided by
             the <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/>
            
             This is included in the <see cref="P:Rezolver.Container.DefaultConfig"/>, meaning that all containers
             created without a specific config will automatically be configured to use the <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/>.</summary>
        </member>
        <member name="P:Rezolver.Configuration.ExpressionCompilation.Instance">
            <summary>
            The one and only instance of <see cref="T:Rezolver.Configuration.ExpressionCompilation"/>
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.ExpressionCompilation.Configure(Rezolver.Container,Rezolver.IRootTargetContainer)">
            <summary>
            Implements the <see cref="M:Rezolver.IContainerConfig.Configure(Rezolver.Container,Rezolver.IRootTargetContainer)"/> method,
            registering all the targets necessary to use expression-based compilation for all the standard targets
            defined in the <c>Rezolver</c> core library.
            </summary>
            <param name="container">The container - ignored.</param>
            <param name="targets">Required - the target container into which the various targets will be registered.</param>
            <remarks>All targets registered by this function are <see cref="T:Rezolver.Targets.ObjectTarget"/> targets backed by concrete instances
            of the various components (compiler etc).</remarks>
        </member>
        <member name="T:Rezolver.Configuration.InjectArrays">
            <summary>
            Configuration (enabled by default in the <see cref="P:Rezolver.TargetContainer.DefaultConfig"/> configuration collection)
            which enables the automatic injection of arrays by converting automatically injected enumerables into array
            instances via the <see cref="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})"/> method from Linq.
            </summary>
            <remarks>Note that this configuration requires that the <see cref="T:Rezolver.Configuration.InjectEnumerables"/> configuration is
            also applied.</remarks>
        </member>
        <member name="P:Rezolver.Configuration.InjectArrays.Instance">
            <summary>
            The one and only instance of the <see cref="T:Rezolver.Configuration.InjectArrays"/> configuration object
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.InjectArrays.GetDependenciesBase">
            <summary>
            Overrides the abstract base method to return dependencies on the <see cref="T:Rezolver.Options.EnableArrayInjection"/> option
            and the 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Configuration.InjectArrays.Configure(Rezolver.IRootTargetContainer)">
             <summary>
             Implements the <see cref="M:Rezolver.Configuration.OptionDependentConfigBase.Configure(Rezolver.IRootTargetContainer)"/> abstract method
             by configuring the passed <paramref name="targets"/> so it can produce targets for any array type, regardless
             of whether a single object has been registered for the array's element type.
            
             After enabling, the ability to register specific targets for concrete array types will still be present.
             </summary>
             <param name="targets"></param>
        </member>
        <member name="T:Rezolver.Configuration.InjectAutoFuncs">
            <summary>
            Controls whether the injection of <see cref="T:System.Func`1"/> will automatically be
            available *without* having to use the <see cref="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``1(Rezolver.IRootTargetContainer)"/>
            method or explicitly register <see cref="T:Rezolver.Targets.AutoFactoryTarget"/> targets.
            </summary>
            <remarks>
            If this is applied to an <see cref="T:Rezolver.IRootTargetContainer"/> and the <see cref="T:Rezolver.Options.EnableAutoFuncInjection"/>
            option has been configured to be <c>true</c> (**NOTE**: The default is <c>false</c>), then whenever a target is 
            registered against a particular service type, a second registration will automatically be made against 
            a <see cref="T:System.Func`1"/> type with TResult equal to the registered service type.
            
            Also, if the <see cref="T:Rezolver.Options.EnableEnumerableInjection"/> option is <c>true</c>, then an additional registration
            will be made for the same type for <see cref="T:System.Func`1"/> where TResult is equal to <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            specialised for the registered type.</remarks>
        </member>
        <member name="P:Rezolver.Configuration.InjectAutoFuncs.Instance">
            <summary>
            The one and only <see cref="T:Rezolver.Configuration.InjectAutoFuncs"/> instance.
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.InjectAutoFuncs.Configure(Rezolver.IRootTargetContainer)">
            <summary>
            Called to apply this configuration to the passed <paramref name="targets"/> target container.
            </summary>
            <param name="targets"></param>
        </member>
        <member name="M:Rezolver.Configuration.InjectAutoFuncs.GetDependenciesBase">
            <summary>
            Overrides <see cref="M:Rezolver.Configuration.OptionDependentConfigBase.GetDependenciesBase"/> by returning dependencies on:
            
            - <see cref="T:Rezolver.Options.EnableAutoFuncInjection"/> (via <see cref="T:Rezolver.Configuration.Configure`1"/>)
            - <see cref="T:Rezolver.Options.EnableEnumerableInjection"/> (also via <see cref="T:Rezolver.Configuration.Configure`1"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Configuration.InjectAutoLazies">
            <summary>
            Configuration which, if the <see cref="T:Rezolver.Options.EnableAutoLazyInjection"/>, option is
            configured to <c>true</c>, will auto-register a target container for <see cref="T:System.Lazy`1"/>
            that will, in turn, automatically enable the injection of lazy instances - rather than
            requiring explicit registration.
            </summary>
            <remarks>Note - successful injection relies on the lazy being able to resolve a <see cref="T:System.Func`1"/>
            which will be used as the instance factory.  Typically, if you're enabling automatic lazy injection,
            then you'll also have enabled automatic <see cref="T:System.Func`1"/> injection via the 
            <see cref="T:Rezolver.Configuration.InjectAutoFuncs"/> configuration and its associated option: <see cref="T:Rezolver.Options.EnableAutoFuncInjection"/>.</remarks>
        </member>
        <member name="P:Rezolver.Configuration.InjectAutoLazies.Instance">
            <summary>
            The one and only instance of this configuration.
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.InjectAutoLazies.Configure(Rezolver.IRootTargetContainer)">
            <summary>
            Adds the necessary registration to the passed root target container
            for <see cref="T:System.Lazy`1"/> so long as no <see cref="T:Rezolver.ITargetContainer"/> is already
            registered.
            </summary>
            <param name="targets">The root target container to which this configuation will be applied.</param>
        </member>
        <member name="M:Rezolver.Configuration.InjectAutoLazies.GetDependenciesBase">
            <summary>
            Implementation of the <see cref="M:Rezolver.Configuration.OptionDependentConfigBase.GetDependenciesBase"/>
            method which returns optional dependencies on the <see cref="T:Rezolver.Options.EnableAutoLazyInjection"/>
            and <see cref="T:Rezolver.Options.EnableAutoFuncInjection"/> options.
            </summary>
            <returns>The dependencies for this configuration.</returns>
        </member>
        <member name="T:Rezolver.Configuration.InjectCollections">
             <summary>
             Applying this configuration to an <see cref="T:Rezolver.ITargetContainer"/> will enable automatic injection of collection types such as
             <see cref="T:System.Collections.ObjectModel.Collection`1"/>, <see cref="T:System.Collections.Generic.ICollection`1"/>, <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/>
             and <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> (so long as there are no registrations for these types in the target container when the configuration is applied).
            
             Out of the box, such collections will be seeded by any objects that have been registered against the element type.
             </summary>
             <remarks>As with <see cref="T:Rezolver.Configuration.InjectLists"/> this configuration object has a partner option - <see cref="T:Rezolver.Options.EnableCollectionInjection"/> - which can be used
             to control whether collection injection is actually enabled by this configuration.
            
             In normal operation, this configuration is applied by default to <see cref="T:Rezolver.TargetContainer"/> and <see cref="T:Rezolver.OverridingTargetContainer"/> instances via the
             <see cref="P:Rezolver.TargetContainer.DefaultConfig"/> combined config.  To use the <see cref="T:Rezolver.Options.EnableCollectionInjection"/> option to disable it, you can use
             the <see cref="T:Rezolver.Configuration.Configure`1"/> configuration to configure the <see cref="T:Rezolver.Options.EnableCollectionInjection"/> option to <c>false</c>.  The easiest way to do
             that is via the <see cref="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,``0)"/> extension method or
             one of its overloads.
            
             ## Requires List Injection
            
             Note that because <see cref="T:System.Collections.ObjectModel.Collection`1"/> and <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> *both* require an instance of <see cref="T:System.Collections.Generic.IList`1"/> in their constructor,
             the target container MUST also be able to inject an instance of <see cref="T:System.Collections.Generic.IList`1"/>.  The best way to do this is to ensure the <see cref="T:Rezolver.Configuration.InjectLists"/> and
             <see cref="T:Rezolver.Configuration.InjectEnumerables"/> are both enabled (which they are, by default).
             </remarks>
        </member>
        <member name="P:Rezolver.Configuration.InjectCollections.Instance">
            <summary>
            The one and only instance of the <see cref="T:Rezolver.Configuration.InjectCollections"/> configuration.
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.InjectCollections.Configure(Rezolver.IRootTargetContainer)">
            <summary>
            Adds registrations for <see cref="T:System.Collections.ObjectModel.Collection`1"/> and <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> to the <paramref name="targets"/> (including
            their primary interfaces) so long as none of the types are already registered.
            </summary>
            <param name="targets"></param>
        </member>
        <member name="T:Rezolver.Configuration.InjectEnumerables">
             <summary>
             An <see cref="T:Rezolver.ITargetContainerConfig"/> which enables automatic handling of fetching
             targets for <see cref="T:System.Collections.Generic.IEnumerable`1"/> based on all the targets registered for a given <c>T</c>
             in an <see cref="T:Rezolver.ITargetContainer"/>.
             </summary>
             <remarks>This behaviour is added to the default configuration for all <see cref="T:Rezolver.TargetContainer"/>-derived
             objects via the <see cref="P:Rezolver.TargetContainer.DefaultConfig"/>.
            
             To disable it, you can either remove it from that configuration object (which then disables it for all)
             or you can add an option configuration to it (via
             <see cref="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,``0)"/>
             or similar) for the <see cref="T:Rezolver.Options.EnableEnumerableInjection"/> option, setting it to <c>false</c>.
            
             If this behaviour is not attached to an <see cref="T:Rezolver.ITargetContainer"/>, or is disabled via the
             <see cref="T:Rezolver.Options.EnableEnumerableInjection"/> option, then only explicitly
             registered enumerables will be able to be resolved by any <see cref="T:Rezolver.Container"/> built from that
             target container.
            
             #### Lazy vs Eager evaluation
            
             The enumerables created by Rezolver can be lazy or eager.  Lazy enumerables create instances as you
             enumerate them, and will create a unique set of instances *each time* they are enumerated (assuming
             no Singleton or Scoped lifetimes are in play).  Eager enumerables create all their instances up-front,
             and remain constant for the life of that enumerable.
            
             The <see cref="T:Rezolver.Options.LazyEnumerables"/> option (default <c>true</c>) is used to control this behaviour,
             and can be applied on a per-enumerable-type basis to an <see cref="T:Rezolver.ITargetContainer"/>.
            
             E.g. you can set the option to <c>false</c> for
             <c>IEnumerable&lt;Foo&gt;</c> - thus ensuring that all enumerables of <c>Foo</c> are eager, but leave
             it at its default of <c>true</c> for all other enumerable types.
             </remarks>
        </member>
        <member name="P:Rezolver.Configuration.InjectEnumerables.Instance">
            <summary>
            The one and only instance of the <see cref="T:Rezolver.Configuration.InjectEnumerables"/> type.
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.InjectEnumerables.Configure(Rezolver.IRootTargetContainer)">
             <summary>
             Implementation of <see cref="M:Rezolver.Configuration.OptionDependentConfigBase.Configure(Rezolver.IRootTargetContainer)"/>
             </summary>
             <param name="targets"></param>
             <remarks>
             This implementation registers a special target container (via <see cref="M:Rezolver.ITargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)"/>)
             for <see cref="T:System.Collections.Generic.IEnumerable`1"/> in passed <paramref name="targets"/>
             if the <see cref="T:Rezolver.Options.EnableEnumerableInjection"/> option evaluates to <c>true</c> when read from <paramref name="targets"/>.
            
             This is the default value for that option anyway, so, as the remarks section on the class states, all that's required to enable
             the enumerable resolving behaviour is simply to make sure this configuration object is applied to an <see cref="T:Rezolver.IRootTargetContainer"/></remarks>
        </member>
        <member name="T:Rezolver.Configuration.InjectLists">
             <summary>
             This configuration will enable automatic injection of <see cref="T:System.Collections.Generic.List`1"/>, <see cref="T:System.Collections.Generic.IList`1"/> and <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>
             when applied to an <see cref="T:Rezolver.ITargetContainer"/>, *so long as there aren't already registrations for those types*.
             </summary>
             <remarks>
             If this configuration is added to a <see cref="T:Rezolver.CombinedTargetContainerConfig"/>, it can be disabled by adding
             another configuration to set the <see cref="T:Rezolver.Options.EnableListInjection"/> option to <c>false</c> - typically via
             the <see cref="M:Rezolver.CombinedTargetContainerConfigExtensions.ConfigureOption``1(Rezolver.CombinedTargetContainerConfig,``0)"/>
             method (note - the order that the configs are added doesn't matter).
            
             The underlying behaviour relies on registrations of <see cref="T:System.Collections.Generic.IEnumerable`1"/> to be present when
             the constructor for the list type is bound, as it expects to bind to the <see cref="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})"/> constructor.
            
             The easiest way to achieve this is also to ensure that the
             <see cref="T:Rezolver.Configuration.InjectEnumerables"/> configuration is enabled (which it is, by default) - which guarantees that any
             <see cref="T:System.Collections.Generic.IEnumerable`1"/> can be resolved - even if empty.</remarks>
             <seealso cref="T:Rezolver.Options.EnableListInjection"/>
             <seealso cref="T:Rezolver.Configuration.InjectEnumerables"/>
        </member>
        <member name="P:Rezolver.Configuration.InjectLists.Instance">
            <summary>
            The one and only instance of <see cref="T:Rezolver.Configuration.InjectLists"/>
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.InjectLists.Configure(Rezolver.IRootTargetContainer)">
            <summary>
            Configures the passed <paramref name="targets"/> to enable auto injection of <see cref="T:System.Collections.Generic.List`1"/>, <see cref="T:System.Collections.Generic.IList`1"/>
            and <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> by registering a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> for
            <see cref="T:System.Collections.Generic.List`1"/> for all three types - so long as none of them already have a registration.
            </summary>
            <param name="targets"></param>
        </member>
        <member name="T:Rezolver.Configuration.InjectResolveContext">
            <summary>
            An <see cref="T:Rezolver.ITargetContainerConfig"/> that enables automatic resolving of the
            <see cref="T:Rezolver.ResolveContext"/> created for a <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> operation.
            </summary>
            <remarks>The implementation registers a special internal target type which implements <see cref="T:Rezolver.IFactoryProvider"/>
            and <see cref="T:Rezolver.IFactoryProvider`1"/> by returning delegates that return the context that's passed
            as an argument to those factories.
            
            This configuration is applied to the <see cref="P:Rezolver.TargetContainer.DefaultConfig"/> automatically, and cannot be disabled
            through the use of options.  Either it's in the configuration, or its not.</remarks>
        </member>
        <member name="P:Rezolver.Configuration.InjectResolveContext.Instance">
            <summary>
            The one and only instance of <see cref="T:Rezolver.Configuration.InjectResolveContext"/>
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.InjectResolveContext.Configure(Rezolver.IRootTargetContainer)">
             <summary>
             Attaches this behaviour to the target container, adding a registration to the <paramref name="targets"/>
             for the type <see cref="T:Rezolver.ResolveContext"/>.
            
             Note - if the <paramref name="targets"/> already has a registration for <see cref="T:Rezolver.ResolveContext"/>,
             then the behaviour DOES NOT overwrite it.
             </summary>
             <param name="targets"></param>
        </member>
        <member name="T:Rezolver.Configuration.OptionDependentConfig`1">
             <summary>
             Abstract base class for an <see cref="T:Rezolver.ITargetContainerConfig"/> that is dependent upon a particular type of option
             having been set in an <see cref="T:Rezolver.ITargetContainer"/> before being able to <see cref="M:Rezolver.Configuration.OptionDependentConfigBase.Configure(Rezolver.IRootTargetContainer)"/>
             that target container.
             </summary>
             <typeparam name="TOption">The type of option upon which this config object depends.  The default dependency created and
             returned by the <see cref="P:Rezolver.Configuration.OptionDependentConfigBase.Dependencies"/> will actually be dependent upon the config type
             <see cref="T:Rezolver.Configuration.Configure`1"/>, which is the standard contract expected by a configuration object that configures
             a particular option.</typeparam>
             <remarks>If you are developing an <see cref="T:Rezolver.ITargetContainerConfig"/> that you want to be configurable via the use of
             a single option type then inheriting from this
             abstract class instead of directly implementing <see cref="T:Rezolver.ITargetContainerConfig"/> and <see cref="T:Rezolver.Sdk.IDependant"/> is a good idea.
            
             The default implementation of <see cref="M:Rezolver.Configuration.OptionDependentConfig`1.GetDependenciesBase"/> will return a single dependency on the type <see cref="T:Rezolver.Configuration.Configure`1"/>
             specialised for the option type <typeparamref name="TOption"/>.
            
             You can also specify that the dependency is not *required* in cases where an option has a reasonable default value - thus allowing
             applications to omit any up-front configuration for that option except where absolutely necessary.
            
             The <see cref="T:Rezolver.Configuration.InjectEnumerables"/> config inherits from this class - passing <see cref="T:Rezolver.Options.EnableEnumerableInjection"/> as
             <typeparamref name="TOption"/>, with the constructor marking the dependency as optional. This ensures that it is executed after the option
             has been configured by any <see cref="T:Rezolver.ITargetContainerConfig`1"/> objects specialised for the option type.</remarks>
        </member>
        <member name="M:Rezolver.Configuration.OptionDependentConfig`1.#ctor(System.Boolean)">
            <summary>
            Constructs a new instance of the type <see cref="T:Rezolver.Configuration.OptionDependentConfig`1"/> which starts off with a required or optional
            dependency (controlled by the argument passed <paramref name="optionConfigurationRequired"/> parameter)
            </summary>
            <param name="optionConfigurationRequired"></param>
        </member>
        <member name="M:Rezolver.Configuration.OptionDependentConfig`1.GetDependenciesBase">
            <summary>
            The base implementation returns an enumerable containing a single dependency on the type <see cref="T:Rezolver.ITargetContainerConfig`1"/>
            specialised for the type <typeparamref name="TOption" />.
            </summary>
        </member>
        <member name="T:Rezolver.Configuration.OptionDependentConfig`2">
            <summary>
            Extension to the <see cref="T:Rezolver.Configuration.OptionDependentConfig`1"/> generic which can be used by config types which also want to target
            a specific type for configuration (<typeparamref name="T"/>)
            </summary>
            <typeparam name="T">The type of service/behaviour/option being configured</typeparam>
            <typeparam name="TOption">The type of option upon which this config object depends.  The default dependency created and
            returned by this class' implementation of <see cref="P:Rezolver.Sdk.IDependant.Dependencies"/> will actually be dependent upon the config type
            <see cref="T:Rezolver.ITargetContainerConfig`1"/>, which is the standard contract expected by a configuration object that configures
            a particular option.</typeparam>
        </member>
        <member name="M:Rezolver.Configuration.OptionDependentConfig`2.#ctor(System.Boolean)">
            <summary>
            Constructs a new instance of the type <see cref="T:Rezolver.Configuration.OptionDependentConfig`2"/> which starts off with a required or optional
            dependency (controlled by the argument passed <paramref name="optionConfigurationRequired"/> parameter)
            </summary>
            <param name="optionConfigurationRequired"></param>
        </member>
        <member name="T:Rezolver.Configuration.OptionDependentConfigBase">
            <summary>
            Abstract base class for <see cref="T:Rezolver.ITargetContainerConfig"/> implementations which are dependent upon
            one or more configuration objects having been applied before being applied themselves.
            </summary>
            <remarks>Implement this type directly if your config object has dependencies on multiple config types/objects.
            
            Your implementation of <see cref="M:Rezolver.Configuration.OptionDependentConfigBase.GetDependenciesBase"/> should return metadata which describes those
            dependencies.  The easiest way to create these is through one of:
            
            - <see cref="M:Rezolver.Configuration.OptionDependentConfigBase.CreateOptionDependency``1(System.Boolean)"/>
            - <see cref="M:Rezolver.Sdk.DependantExtensions.CreateTypeDependency``1(Rezolver.Sdk.IDependant,System.Boolean)"/>
            - <see cref="M:Rezolver.Sdk.DependantExtensions.CreateObjectDependency``1(Rezolver.Sdk.IDependant,``0,System.Boolean)"/></remarks>
        </member>
        <member name="P:Rezolver.Configuration.OptionDependentConfigBase.Dependencies">
            <summary>
            Gets the dependencies for this in instance.  Implementation of <see cref="P:Rezolver.Sdk.IDependant.Dependencies"/>
            </summary>
        </member>
        <member name="M:Rezolver.Configuration.OptionDependentConfigBase.GetDependenciesBase">
            <summary>
            Implement this to provide your dependency logic.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Configuration.OptionDependentConfigBase.Configure(Rezolver.IRootTargetContainer)">
            <summary>
            Abstract implementation of <see cref="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)"/>
            </summary>
            <param name="targets">The root target container to which this configuration is to be applied.</param>
        </member>
        <member name="M:Rezolver.Configuration.OptionDependentConfigBase.CreateOptionDependency``1(System.Boolean)">
            <summary>
            Use this to create a <see cref="T:Rezolver.Sdk.TypeDependency"/> on an option of type <typeparamref name="TOption"/>
            being set with the <see cref="T:Rezolver.Configuration.Configure`1"/> <see cref="T:Rezolver.ITargetContainerConfig"/> configuration.
            
            This enables your config to take a dependency on an option being set before being applied, thus enabling
            it to take decisions based on that option value.
            </summary>
            <typeparam name="TOption"></typeparam>
            <param name="required"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.ConstructorBinding">
            <summary>
            Represents a binding specifically to a class constructor, optionally with an additional
            set of <see cref="P:Rezolver.ConstructorBinding.MemberBindings"/> to be used to initialise a new instance's properties
            or fields directly.
            </summary>
            <seealso cref="T:Rezolver.MethodBinding" />
        </member>
        <member name="F:Rezolver.ConstructorBinding.NoBoundMembers">
            <summary>
            An empty array of <see cref="T:Rezolver.MemberBinding"/> objects used to represent a
            constructor binding with no bound members.  The <see cref="P:Rezolver.ConstructorBinding.MemberBindings"/> property
            will be set to this if the constructor is called with a null <c>memberBindings</c> argument.
            </summary>
        </member>
        <member name="P:Rezolver.ConstructorBinding.Constructor">
            <summary>
            Gets the constructor to be invoked. Note that this simply returns the
            base <see cref="P:Rezolver.MethodBinding.Method"/> property cast to <see cref="T:System.Reflection.ConstructorInfo"/>.
            </summary>
            <value>The constructor.</value>
        </member>
        <member name="P:Rezolver.ConstructorBinding.MemberBindings">
            <summary>
            Gets the member bindings to be applied to the new instance created by the <see cref="P:Rezolver.ConstructorBinding.Constructor"/>
            </summary>
            <value>The member bindings.</value>
            <remarks>Member bindings represent the inline initialisation of writable properties or fields
            immediately after constructing a new instance of a type.</remarks>
        </member>
        <member name="M:Rezolver.ConstructorBinding.#ctor(System.Reflection.ConstructorInfo,Rezolver.ParameterBinding[],Rezolver.MemberBinding[])">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.ConstructorBinding" /> class.
            </summary>
            <param name="constructor">The constructor to be used .</param>
            <param name="boundArgs">Optional.  The bound arguments.  Can be null or empty.</param>
            <param name="memberBindings">Optional.  The bindings for the members of the new instance created by the constructor.</param>
        </member>
        <member name="T:Rezolver.Container">
             <summary>
             Container through which objects can be resolved.
             </summary>
             <remarks>This class also implements <see cref="T:Rezolver.IRootTargetContainer"/> by proxying the <see cref="P:Rezolver.Container.Targets"/> that are
             provided to it on construction (or created anew if not supplied).  All of those interface methods are implemented
             explicitly except the <see cref="M:Rezolver.Container.Register(Rezolver.ITarget,System.Type)"/> method,  which is available through the class' public
             API.
            
             This makes it easier to create a new container and to register targets into it without
             having to worry about managing a separate <see cref="T:Rezolver.IRootTargetContainer"/> instance in your application root -
             because all the registration extension methods in <see cref="T:Rezolver.RootTargetContainerExtensions"/>, 
             and <see cref="T:Rezolver.TargetContainerExtensions"/> will be available to developers in code which has a reference to this 
             class, or one derived from it.
            
             Note also that calling <see cref="M:Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer,System.Type)"/> on an instance of this
             type will always cause a <see cref="T:System.NotSupportedException"/> to be thrown, thus preventing containers from being
             registered as sub target containers within an <see cref="T:Rezolver.ITargetContainer"/> via its
             <see cref="M:Rezolver.ITargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)"/> method.
             </remarks>
        </member>
        <member name="P:Rezolver.Container.DefaultConfig">
            <summary>
            The default container config used by all new containers.  You can add/remove configurations from this collection
            to change the defaults which are applied to new container instances; or you can supply an explicit configuration
            when creating your container.
            </summary>
            <remarks>
            The configurations present in this collection by default will set up the expression target compiler and extend
            the automatic enumerable injection functionality so that the <see cref="T:Rezolver.OverridingContainer"/> class can produce
            enumerables which are made up of targets registered in both the overriding container and its inner container.</remarks>
        </member>
        <member name="P:Rezolver.Container.Targets">
             <summary>
             Provides the <see cref="T:Rezolver.ITarget"/> instances that will be compiled into factories.
             instances.
             </summary>
             <remarks>This class implements the <see cref="T:Rezolver.ITargetContainer"/> interface by wrapping around this instance so that
             an application can create an instance of <see cref="T:Rezolver.Container"/> and directly register targets into it;
             rather than having to create and setup the target container first.
            
             You can add registrations to this target container at any point in the lifetime of any
             <see cref="T:Rezolver.Container"/> instances which are attached to it.
            
             In reality, however, if any <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> operations have been performed prior to
             adding more registrations, then there's no guarantee that new dependencies will be picked up - especially
             if the <see cref="T:Rezolver.Container"/> is being used as your application's container (which it nearly
             always will be).</remarks>
        </member>
        <member name="M:Rezolver.Container.#ctor(Rezolver.IRootTargetContainer)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Container"/> class.
            </summary>
            <param name="targets">Optional.  The target container whose registrations will be used for dependency lookup
            when <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> (and other operations) is called.  If not provided, a new
            <see cref="T:Rezolver.TargetContainer"/> instance is constructed.  This will ultimately be available to inherited types,
            after construction, through the <see cref="P:Rezolver.Container.Targets"/> property.</param>
        </member>
        <member name="M:Rezolver.Container.#ctor(Rezolver.IRootTargetContainer,Rezolver.IContainerConfig)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Container"/> class.
            </summary>
            <param name="targets">Optional.  The target container whose registrations will be used for dependency lookup when
            <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> (and other operations) is called.  If not provided, a new
            <see cref="T:Rezolver.TargetContainer"/> instance is constructed.  This will ultimately be available
            to derived types, after construction, through the <see cref="P:Rezolver.Container.Targets"/> property.</param>
            <param name="config">Can be null.  Configuration to apply to this container (and, potentially its <see cref="P:Rezolver.Container.Targets"/>).
            If not provided, then the <see cref="P:Rezolver.Container.DefaultConfig"/> will be used.</param>
            <remarks>Note to inheritors - this constructor throws an <see cref="T:System.InvalidOperationException"/> if used by a derived class,
            because the application of configuration to the container will likely cause virtual methods to be called.  Instead, you
            should declare your own constructor with the same signature which chains instead to the <see cref="M:Rezolver.Container.#ctor(Rezolver.IRootTargetContainer)"/>
            protected constructor; and then you should apply the configuration yourself in that constructor (falling back to
            <see cref="P:Rezolver.Container.DefaultConfig"/> if null).</remarks>
        </member>
        <member name="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)">
            <summary>
            Gets an instance of the <see cref="P:Rezolver.ResolveContext.RequestedType"/> from the container,
            using the scope from the <paramref name="context"/>.
            </summary>
            <param name="context">The resolve context</param>
            <returns>An instance of the type that was requested.</returns>
        </member>
        <member name="M:Rezolver.Container.Resolve(System.Type)">
            <summary>
            Resolves an instance of the given <paramref name="serviceType"/> using this context's scope.
            </summary>
            <param name="serviceType">The type of service required.</param>
            <returns>An object compatible with the <paramref name="serviceType"/></returns>
        </member>
        <member name="M:Rezolver.Container.Resolve(System.Type,Rezolver.ContainerScope)">
            <summary>
            Resolves an instance of the given <paramref name="serviceType"/> for the given <paramref name="scope"/>.
            </summary>
            <param name="serviceType">The type of service required.</param>
            <param name="scope">The scope to be used for the operation.  Will be used for all scoping for the
            created object and any dependencies created for it.</param>
            <returns>An object compatible with the <paramref name="serviceType"/></returns>
        </member>
        <member name="M:Rezolver.Container.Resolve``1">
            <summary>
            Resolves an instance of <typeparamref name="TService"/> using the current container and scope.
            </summary>
            <typeparam name="TService">The type of object required.</typeparam>
            <returns>The instance.</returns>
        </member>
        <member name="M:Rezolver.Container.Resolve``1(Rezolver.ContainerScope)">
            <summary>
            Resolves an instance of <typeparamref name="TService"/> using the current container but the 
            supplied <paramref name="scope"/>.
            </summary>
            <typeparam name="TService">The type of object required.</typeparam>
            /// <param name="scope">The scope to be used for the operation.  Will be used for all scoping for the
            created object and any dependencies created for it.</param>
            <returns>The instance.</returns>
        </member>
        <member name="M:Rezolver.Container.ResolveMany(System.Type)">
            <summary>
            Resolves an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of the <paramref name="serviceType"/> using the current container
            and scope.
            </summary>
            <param name="serviceType">The type of object required.</param>
            <returns>An enumerable containing zero or more instances of services compatible with <paramref name="serviceType"/></returns>
        </member>
        <member name="M:Rezolver.Container.ResolveMany``1">
            <summary>
            Resolves an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of the <typeparamref name="TService"/> using the current container
            and scope.
            </summary>
            <typeparam name="TService">the type of object required.</typeparam>
            <returns>A strongly-typed enumerable containing zero or more instances of services compatible with <typeparamref name="TService"/></returns>
        </member>
        <member name="M:Rezolver.Container.TryResolve(Rezolver.ResolveContext,System.Object@)">
            <summary>
            Attempts to resolve the requested type (given on the <paramref name="context"/>, returning a boolean
            indicating whether the operation was successful.  If successful, then <paramref name="result"/> receives
            a reference to the resolved object.
            </summary>
            <param name="context">The context containing the type that's requested, any active scope and so on.</param>
            <param name="result">Receives a reference to the object that was resolved, if successful, or <c>null</c>
            if not.</param>
            <returns>A boolean indicating whether the operation completed successfully.</returns>
        </member>
        <member name="M:Rezolver.Container.CreateScope">
             <summary>
             Implementation of the <see cref="M:Rezolver.IScopeFactory.CreateScope"/> method.
            
             The base definition creates a <see cref="T:Rezolver.ContainerScope"/> with this container passed as the scope's container.
            
             Thus, the new scope is a 'root' scope.
             </summary>
        </member>
        <member name="M:Rezolver.Container.CanResolve(System.Type)">
            <summary>
            Returns <c>true</c> if a service registration can be found for the given <paramref name="serviceType"/>
            </summary>
            <param name="serviceType">The type of service</param>
            <returns>A boolean indicating whether the service can be resolved</returns>
        </member>
        <member name="M:Rezolver.Container.CanResolve``1">
            <summary>
            Returns <c>true</c> if a service registration can be found for the given <typeparamref name="TService"/>
            </summary>
            <typeparam name="TService">The type of service</typeparam>
            <returns>A boolean indicating whether the service can be resolved</returns>
        </member>
        <member name="M:Rezolver.Container.Register(Rezolver.ITarget,System.Type)">
             <summary>
             Implementation of <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/> - simply proxies the
             call to the target container referenced by the <see cref="P:Rezolver.Container.Targets"/> property.
             </summary>
             <param name="target"></param>
             <param name="serviceType"></param>
             <remarks>Remember: registering new targets into an <see cref="T:Rezolver.ITargetContainer"/> after an
             <see cref="T:Rezolver.Container"/> has started compiling targets within it can yield unpredictable results.
            
             If you create a new container and perform all your registrations before you use it, however, then everything
             will work as expected.
            
             Note also the other <see cref="T:Rezolver.ITargetContainer"/> interface methods are implemented explicitly so as to hide them from the
             list of class members.
             </remarks>
        </member>
        <member name="M:Rezolver.Container.GetFallbackCompiledTarget(Rezolver.ResolveContext)">
            <summary>
            Called by <see cref="M:Rezolver.Container.GetFactory(Rezolver.ResolveContext)"/> if no valid <see cref="T:Rezolver.ITarget"/> can be
            found for the <paramref name="context"/> or if the one found has its <see cref="P:Rezolver.ITarget.UseFallback"/> property
            set to <c>true</c>.
            </summary>
            <param name="context"></param>
            <returns>A factory delegate to be used as the result of a <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/>
            operation where the search for a valid target either fails or is inconclusive (e.g. - empty enumerables).
            </returns>
            <remarks>The base implementation always returns an instance of the <see cref="T:Rezolver.UnresolvedTypeCompiledTarget"/>.</remarks>
        </member>
        <member name="M:Rezolver.Container.GetFallbackFactory``1(Rezolver.ResolveContext)">
            <summary>
            
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Container.GetFactory(Rezolver.ResolveContext)">
            <summary>
            Gets the factory which will create an instance of the type indicated by <see cref="P:Rezolver.ResolveContext.RequestedType"/>
            of the passed <paramref name="context"/>.
            </summary>
            <param name="context">The context containing the requested type and any scope which is currently in force.</param>
            <returns>Always returns a reference to a delegate - but note that if
            <see cref="M:Rezolver.Container.CanResolve(System.Type)"/> returns false for the same context, then the target's
            delegate will likely throw an exception.</returns>
        </member>
        <member name="T:Rezolver.ContainerScope">
            <summary>
            Base class for scopes.
            
            This type cannot be inherited by user types.
            </summary>
        </member>
        <member name="P:Rezolver.ContainerScope.Container">
            <summary>
            The container that this scope uses by default to resolve instances.
            </summary>
        </member>
        <member name="P:Rezolver.ContainerScope.Root">
            <summary>
            Root scope to be used for 'top-level' object tracking.
            
            Note - when a <see cref="P:Rezolver.ContainerScope.Container"/> is used, this should be the first scope
            created via the <see cref="M:Rezolver.Container.CreateScope"/> method.
            
            With <see cref="T:Rezolver.ScopedContainer"/> it will be the scope that lives inside that container.
            
            So, as a result of this, this property could point to a scope that's not actually
            a parent of <see cref="P:Rezolver.ContainerScope.Parent"/>
            </summary>
        </member>
        <member name="P:Rezolver.ContainerScope.Parent">
            <summary>
            The scope from which this scope was created.
            </summary>
        </member>
        <member name="M:Rezolver.ContainerScope.#ctor(Rezolver.Container)">
            <summary>
            Creates a new Root scope whose container is set to <paramref name="container"/>
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:Rezolver.ContainerScope.#ctor(Rezolver.ContainerScope,System.Boolean)">
            <summary>
            Creates a new child scope whose container is inherited from the <paramref name="parent"/>
            </summary>
            <param name="parent"></param>
            <param name="isRoot"></param>
        </member>
        <member name="M:Rezolver.ContainerScope.CreateScope">
            <summary>
            Creates a new scope from which instances can be resolved, isolated from the current scope.
            </summary>
            <returns>A new scope.</returns>
        </member>
        <member name="M:Rezolver.ContainerScope.Dispose">
            <summary>
            Disposes this scope and any of its child scopes.
            </summary>
        </member>
        <member name="M:Rezolver.ContainerScope.Resolve(System.Type)">
            <summary>
            Resolves an instance of the <paramref name="serviceType"/> from the container.
            </summary>
            <param name="serviceType">The type of object to resolve.</param>
            <returns>An instance of the type <paramref name="serviceType"/> built according to the 
            registrations in this container.</returns>
        </member>
        <member name="M:Rezolver.ContainerScope.Resolve``1">
            <summary>
            Resolves an instance of <typeparamref name="TService"/> from the container.
            </summary>
            <typeparam name="TService">The type of object to resolve.</typeparam>
            <returns>An instance of the type <typeparamref name="TService"/> built according to the
            registrations in this container.</returns>
        </member>
        <member name="M:Rezolver.ContainerScope.ResolveMany(System.Type)">
            <summary>
            Resolves an enumerable of zero or more instances of <paramref name="serviceType"/> from the
            container.
            </summary>
            <param name="serviceType">Type of objects to resolve.</param>
            <returns>An enumerable containing zero or more instances of the type <paramref name="serviceType"/>.</returns>
        </member>
        <member name="M:Rezolver.ContainerScope.ResolveMany``1">
            <summary>
            Resolves an enumerable of zero or more instances of <typeparamref name="TService"/> from the
            container.
            </summary>
            <typeparam name="TService">Type of objects to resolve.</typeparam>
            <returns>An enumerable containing zero or more instances of the type <typeparamref name="TService"/>.</returns>
        </member>
        <member name="T:Rezolver.ContainerScopeProxy">
            <summary>
            A scope which proxies another, but with a different Container
            </summary>
        </member>
        <member name="T:Rezolver.CovariantTypeIndex">
            <summary>
            Implementation of <see cref="T:Rezolver.ICovariantTypeIndex"/> used internally by <see cref="T:Rezolver.TargetContainer"/>
            and <see cref="T:Rezolver.OverridingTargetContainer"/> in their implementation of the same interface.
            </summary>
        </member>
        <member name="M:Rezolver.CovariantTypeIndex.AddKnownType(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ICovariantTypeIndex.AddKnownType(System.Type)"/>
            </summary>
            <param name="serviceType"></param>
        </member>
        <member name="M:Rezolver.CovariantTypeIndex.GetKnownCovariantTypes(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ICovariantTypeIndex.GetKnownCovariantTypes(System.Type)"/>
            </summary>
            <param name="serviceType"></param>
        </member>
        <member name="M:Rezolver.CovariantTypeIndex.GetKnownCompatibleTypes(System.Type)">
            <summary>
            Implementatino of <see cref="M:Rezolver.ICovariantTypeIndex.GetKnownCompatibleTypes(System.Type)"/>
            </summary>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.CovariantTypeIndex.GetGenericCovariants(System.Type,System.Collections.Generic.Stack{System.Type})">
             <summary>
             Produces an enumerable containing all the types that <paramref name="type"/> is compatible with
             via generic covariance.  That is - if the type is a generic, then it is processed and each covariant
             type argument is processed, with a new generic type created for each base or interface (or similarly covariant
             type) baked in.
             </summary>
             <param name="type"></param>
             <param name="derivedTypeStack">A stack of derived types through which the recursion has passed.
            
             Used to prevent recursion into a derived type through a generic type argument supplied to a base
             or interface of that same type.</param>
             <returns></returns>
             <remarks>If type is a Func&lt;string&gt; then you will get something like:
             Func&lt;object&gt;
             Func&lt;IEnumerable&lt;char&gt;&gt;
             Func&lt;IEnumerable&lt;IComparable&lt;char&gt;&gt;&gt;
            
             and so on.</remarks>
        </member>
        <member name="M:Rezolver.CovariantTypeIndex.GetAllCompatibleTypes(System.Type,System.Collections.Generic.Stack{System.Type})">
            <summary>
            Returns an enumerable that contains every type that an instance of <paramref name="type"/>
            can be assigned to, taking into account bases, interfaces and, in the case of generics,
            variants of the same generic which use more derived types for any covariant generic parameters.
            </summary>
            <param name="type"></param>
            <param name="derivedTypeStack">A state stack which is used to prevent descending into the type
            hierarchies of type arguments to covariant type parameters which are equal to a type that is
            inheriting/implementing the generic.</param>
            <returns></returns>
            <remarks><code>class MyClass : IEnumerable&lt;MyClass&gt;</code> is an example of a type for which
            the <paramref name="derivedTypeStack"/> parameter is required.</remarks>
        </member>
        <member name="M:Rezolver.CovariantTypeIndex.SelectTypes(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ICovariantTypeIndex.SelectTypes(System.Type)"/>
            </summary>
            <param name="type">The type for which a search is to be run.</param>
            <returns>A <see cref="T:Rezolver.TargetTypeSelector"/></returns>
        </member>
        <member name="T:Rezolver.DecoratingTargetContainer">
             <summary>
             Implements service decoration in an <see cref="T:Rezolver.ITargetContainer"/>, producing instances of the
             <see cref="T:Rezolver.Targets.DecoratorTarget"/> when <see cref="M:Rezolver.DecoratingTargetContainer.Fetch(System.Type)"/> or <see cref="M:Rezolver.DecoratingTargetContainer.FetchAll(System.Type)"/> are called.
            
             The best way to add a decorator to your target container is to use the extension methods like
             <see cref="M:Rezolver.RootTargetContainerExtensions.RegisterDecorator``2(Rezolver.IRootTargetContainer)"/> 
             and its overloads.
             </summary>
             <remarks>This class does not implement <see cref="T:Rezolver.ITarget"/>, rather
             it's an <see cref="T:Rezolver.ITargetContainer"/> into which other targets can be added,
             and when <see cref="M:Rezolver.DecoratingTargetContainer.Fetch(System.Type)"/> or <see cref="M:Rezolver.DecoratingTargetContainer.FetchAll(System.Type)"/> are called, a temporary
             <see cref="T:Rezolver.Targets.DecoratorTarget"/> is created which wraps around the targets that have been registered within and
             which will ultimately execute the decoration.
            
             Currently, it is possible to decorate with:
            
             - An auto-injected instance of a decorator type
             - A decorator delegate which both receives and returns an instance of the decorated type.
             </remarks>
        </member>
        <member name="P:Rezolver.DecoratingTargetContainer.DecoratedType">
            <summary>
            Gets the type that's being decorated - is also the type under which this decorating container is registered
            in the <see cref="P:Rezolver.DecoratingTargetContainer.Root"/>
            </summary>
        </member>
        <member name="P:Rezolver.DecoratingTargetContainer.Root">
            <summary>
            Implementation of <see cref="P:Rezolver.ITargetContainer.Root"/>
            </summary>
        </member>
        <member name="M:Rezolver.DecoratingTargetContainer.#ctor(Rezolver.IRootTargetContainer,System.Type,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.DecoratingTargetContainer"/> class to decorate instances
            of <paramref name="decoratedType"/> with new instances of <paramref name="decoratorType"/> which are
            created via constructor injection.
            </summary>
            <param name="root">Required.  The root <see cref="T:Rezolver.ITargetContainer"/> to which this decorating
            container will be registered.</param>
            <param name="decoratorType">Type of the decorator.</param>
            <param name="decoratedType">Type being decorated.</param>
        </member>
        <member name="M:Rezolver.DecoratingTargetContainer.#ctor(Rezolver.IRootTargetContainer,Rezolver.ITarget,System.Type)">
            <summary>
            Create a new instance of the <see cref="T:Rezolver.DecoratingTargetContainer"/> class to decorate
            instances of <paramref name="decoratedType"/> with instances produced by the <paramref name="decoratorTarget"/>.
            </summary>
            <param name="root">Required.  The root <see cref="T:Rezolver.ITargetContainer"/> to which this decorating
            container will be registered.</param>
            <param name="decoratorTarget"></param>
            <param name="decoratedType"></param>
        </member>
        <member name="M:Rezolver.DecoratingTargetContainer.#ctor(Rezolver.IRootTargetContainer,Rezolver.Targets.DecoratingTargetFactory,System.Type)">
             <summary>
            
             </summary>
             <param name="root"></param>
             <param name="factory"></param>
             <param name="decoratedType"></param>
        </member>
        <member name="M:Rezolver.DecoratingTargetContainer.CombineWith(Rezolver.ITargetContainer,System.Type)">
             <summary>
             Implements <see cref="M:Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer,System.Type)"/> by wrapping the
             <paramref name="existing"/> container and returning itself.
            
             This allows decorators to be applied on top of decorators; and decorators to be added after types
             have begun to be registered in another target container.
             </summary>
             <param name="existing">The existing <see cref="T:Rezolver.ITargetContainer" /> instance that this instance is to be combined with</param>
             <param name="type">The type that the combined container owner will be registered under.</param>
             <exception cref="T:System.InvalidOperationException">If this target container is already decorating another container</exception>
        </member>
        <member name="M:Rezolver.DecoratingTargetContainer.Fetch(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainer.Fetch(System.Type)"/> - wraps a special target around
            the target returned by the target container that's decorated by this one.
            </summary>
            <param name="type">Required.  The type for which an <see cref="T:Rezolver.ITarget" /> is to be retrieved.</param>
            <remarks>If the inner container returns null, then so does this one.</remarks>
        </member>
        <member name="M:Rezolver.DecoratingTargetContainer.FetchAll(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)"/> - passes the call on to the inner
            container that's decorated by this one, and then wraps each of those targets in a <see cref="T:Rezolver.Targets.DecoratorTarget"/> which
            represents the decoration logic for each instance.
            </summary>
            <param name="type">Required.  The type for which the <see cref="T:Rezolver.ITarget" /> instances are to be retrieved.</param>
        </member>
        <member name="M:Rezolver.DecoratingTargetContainer.Register(Rezolver.ITarget,System.Type)">
            <summary>
            Registers a target, either for the <paramref name="serviceType" /> specified or, if null, the <see cref="P:Rezolver.ITarget.DeclaredType" />
            of the <paramref name="target" />.  Implementation of <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/>.
            </summary>
            <param name="target">Required.  The target to be registered</param>
            <param name="serviceType">Optional.  The type the target is to be registered against, if different
            from the <see cref="P:Rezolver.ITarget.DeclaredType" /> of the <paramref name="target" />.  If provided, then the <paramref name="target" />
            must be compatible with this type.</param>
            <remarks>The decorator target does not accept registrations directly; rather it passes the call on to its
            inner container which could be a <see cref="T:Rezolver.TargetListContainer"/>, or <see cref="T:Rezolver.GenericTargetContainer"/> in
            the most basic cases; or it could be another <see cref="T:Rezolver.DecoratingTargetContainer"/> in situations where a type has had
            multiple decorators registered against it.</remarks>
        </member>
        <member name="M:Rezolver.DecoratingTargetContainer.FetchContainer(System.Type)">
            <summary>
            Retrieves an existing container registered against the given <paramref name="type" />, or null if not found.
            </summary>
            <param name="type">The type.</param>
            <remarks>This is an implementation of <see cref="M:Rezolver.ITargetContainer.FetchContainer(System.Type)"/> which wraps
            around the inner target container and passes the call on to that.</remarks>
        </member>
        <member name="M:Rezolver.DecoratingTargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)"/> - the call is
            automatically forwarded on to the inner target container that's being decorated, since decorator targets don't support
            direct registration of targets or containers.
            </summary>
            <param name="type">The type.</param>
            <param name="container">The container.</param>
        </member>
        <member name="T:Rezolver.DisposingContainerScope">
            <summary>
            Fully functional container scope.  Supports tracking of implicitly and explicitly scoped objects to enable disposal.
            </summary>
        </member>
        <member name="F:Rezolver.DisposingContainerScope._explicitlyScopedObjects">
            <summary>
            Explicitly scoped objects can be a mixture of disposable and non-disposable objects
            </summary>
        </member>
        <member name="F:Rezolver.DisposingContainerScope._implicitlyScopedObjects">
            <summary>
            implicitly scoped objects will always be IDisposable
            </summary>
        </member>
        <member name="M:Rezolver.DisposingContainerScope.#ctor(Rezolver.Container)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.DisposingContainerScope"/> class.
            </summary>
            <param name="container">The container that this scope will use to resolve instances.</param>
        </member>
        <member name="M:Rezolver.DisposingContainerScope.#ctor(Rezolver.ContainerScope,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.DisposingContainerScope"/> class that
            is optionally treated as a root scope.
            </summary>
            <param name="parent"></param>
            <param name="isRoot"></param>
        </member>
        <member name="T:Rezolver.Events.TargetContainerRegisteredEventArgs">
            <summary>
            Represents the arguments passed to the <see cref="E:Rezolver.IRootTargetContainer.TargetContainerRegistered"/>
            event exposed by the <see cref="T:Rezolver.IRootTargetContainer"/> interface.
            </summary>
        </member>
        <member name="P:Rezolver.Events.TargetContainerRegisteredEventArgs.Container">
            <summary>
            The target container that was registered.
            </summary>
        </member>
        <member name="P:Rezolver.Events.TargetContainerRegisteredEventArgs.Type">
            <summary>
            The type against which the target container was registered.  Note that this type
            could be an open generic.
            </summary>
        </member>
        <member name="M:Rezolver.Events.TargetContainerRegisteredEventArgs.#ctor(Rezolver.ITargetContainer,System.Type)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Events.TargetContainerRegisteredEventArgs"/>
            </summary>
            <param name="container">The target container that was registered</param>
            <param name="type">The type against which the target container was registered</param>
        </member>
        <member name="T:Rezolver.Events.TargetRegisteredEventArgs">
            <summary>
            Contains the arguments for the <see cref="E:Rezolver.IRootTargetContainer.TargetRegistered"/> event exposed
            by the <see cref="T:Rezolver.IRootTargetContainer"/>
            </summary>
        </member>
        <member name="P:Rezolver.Events.TargetRegisteredEventArgs.Target">
            <summary>
            The target that was registered
            </summary>
        </member>
        <member name="P:Rezolver.Events.TargetRegisteredEventArgs.Type">
            <summary>
            The type against which the target was registered.
            </summary>
        </member>
        <member name="M:Rezolver.Events.TargetRegisteredEventArgs.#ctor(Rezolver.ITarget,System.Type)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Events.TargetRegisteredEventArgs"/>
            </summary>
            <param name="target"></param>
            <param name="type"></param>
        </member>
        <member name="T:Rezolver.ExpressionFunctions">
             <summary>
             This type is only used when using expressions as targets(via the <see cref = "T:Rezolver.Targets.ExpressionTarget" /> type) - it's
             functions serve no actual purpose other than to act as hooks to create specific <see cref="T:Rezolver.ITarget"/> objects
             in place of static code.
            
             All the functions will throw a <see cref="T:System.NotImplementedException"/> if called at runtime.
             </summary>
        </member>
        <member name="M:Rezolver.ExpressionFunctions.Resolve``1">
            <summary>
            Provides a way to emit a <see cref="M:Rezolver.ResolveContext.Resolve``1"/> call to the <see cref="T:Rezolver.ResolveContext"/>
            which is active when an expression is compiled and executed when resolving an object.
            </summary>
            <typeparam name="T">The type to be resolved.</typeparam>
            <exception cref="T:System.NotImplementedException">Always.  The method is not intended to be used outside of an expression, instead
            it should be rewritten either to a <see cref="T:Rezolver.Targets.ResolvedTarget"/> or another <see cref="T:System.Linq.Expressions.MethodCallExpression"/> bound
            to the <see cref="M:Rezolver.ResolveContext.Resolve``1"/> method of a <see cref="T:Rezolver.ResolveContext"/>.</exception>
            <remarks>Use of this function in a Lambda expression is not required if you can add a <see cref="T:Rezolver.ResolveContext"/>
            parameter to the Lambda - since you can simply call its <see cref="M:Rezolver.ResolveContext.Resolve``1"/> method in your
            lambda body.  This is primarily provided instead for non-lambda expressions which require services from the
            container (e.g. if manually building a <see cref="T:System.Linq.Expressions.NewExpression"/> or <see cref="T:System.Linq.Expressions.MethodCallExpression"/> and you
            want to explicitly inject one or more constructor/method arguments).</remarks>
        </member>
        <member name="M:Rezolver.ExpressionFunctions.Resolve(System.Type)">
            <summary>
            Provides a way to emit a <see cref="M:Rezolver.ResolveContext.Resolve(System.Type)"/> call to the <see cref="T:Rezolver.ResolveContext"/>
            which is active when an expression is compiled and executed when resolving an object.
            </summary>
            <param name="_">The type to be resolved.</param>
            <exception cref="T:System.NotImplementedException">Always.  The method is not intended to be used outside of an expression, instead
            it should be rewritten either to a <see cref="T:Rezolver.Targets.ResolvedTarget"/> or another <see cref="T:System.Linq.Expressions.MethodCallExpression"/> bound
            to the <see cref="M:Rezolver.ResolveContext.Resolve(System.Type)"/> method of a <see cref="T:Rezolver.ResolveContext"/>.</exception>
        </member>
        <member name="T:Rezolver.GenericTargetContainer">
            <summary>
            A special type of <see cref="T:Rezolver.ITargetContainer"/> which stores targets (and potentially other containers)
            which are specifically keyed either to a particular open generic type or a closed generic built from it.
            </summary>
            <seealso cref="T:Rezolver.TargetDictionaryContainer" />
            <remarks>You don't typically use this container directly - it is implicitly added to an <see cref="T:Rezolver.ITargetContainer"/>
            when generic types are registered.  Indeed the <see cref="T:Rezolver.TargetContainer"/> and <see cref="T:Rezolver.DecoratingTargetContainer"/> both
            create instances of this; and the <see cref="T:Rezolver.EnumerableTargetContainer"/> (understandably) inherits from it.</remarks>
        </member>
        <member name="P:Rezolver.GenericTargetContainer.GenericType">
            <summary>
            Gets the open generic type definition which is common to all targets and containers within this container.
            </summary>
        </member>
        <member name="M:Rezolver.GenericTargetContainer.#ctor(Rezolver.IRootTargetContainer,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.GenericTargetContainer"/> class.
            </summary>
            <param name="root">Required.  The root <see cref="T:Rezolver.ITargetContainer"/> in which the new generic target container
            will be registered.</param>
            <param name="genericType">Required. The generic type definition that all targets and subcontainers registered
            to the new container will have in common.</param>
        </member>
        <member name="M:Rezolver.GenericTargetContainer.Register(Rezolver.ITarget,System.Type)">
            <summary>
            Overrides the <see cref="M:Rezolver.TargetDictionaryContainer.Register(Rezolver.ITarget,System.Type)"/> method to support registering
            both targets against the open generic type <see cref="P:Rezolver.GenericTargetContainer.GenericType"/> and against specific closed versions of that
            open generic type.
            </summary>
            <param name="target">The target to be registered</param>
            <param name="serviceType">Service type against which the registration will be made.  If null, then it
            will be assumed to be equal to <see cref="P:Rezolver.GenericTargetContainer.GenericType"/>.  Only types equal to <see cref="P:Rezolver.GenericTargetContainer.GenericType"/> or
            generic types whose generic type definition is equal to <see cref="P:Rezolver.GenericTargetContainer.GenericType"/> are supported.</param>
            <exception cref="T:System.ArgumentException">If <paramref name="serviceType"/> is not equal to <see cref="P:Rezolver.GenericTargetContainer.GenericType"/>
            or is not a closed generic type whose generic type definition is <see cref="P:Rezolver.GenericTargetContainer.GenericType"/>.</exception>
            <remarks>Notes to overriders: When <paramref name="serviceType"/> is a closed generic type, this function
            creates an <see cref="T:Rezolver.ITargetContainer" /> for that <paramref name="serviceType" />
            by calling the protected method <see cref="M:Rezolver.TargetDictionaryContainer.AutoRegisterContainer(System.Type)" /> if one doesn't exist
            (it calls <see cref="M:Rezolver.TargetDictionaryContainer.FetchContainer(System.Type)" /> to check for existence),
            and then chains to its <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)" /> method.</remarks>
        </member>
        <member name="M:Rezolver.GenericTargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)">
             <summary>
             Override of the <see cref="M:Rezolver.TargetDictionaryContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)"/> method.
            
             Doesn't do anything different, except invalidate some internal caches.
             </summary>
             <param name="type"></param>
             <param name="container"></param>
        </member>
        <member name="M:Rezolver.GenericTargetContainer.Fetch(System.Type)">
            <summary>
            Gets the target which can be used to build an instance of <paramref name="type"/>.
            </summary>
            <param name="type">Required.  The type for which a target is to be obtained.  Because of the
            restrictions placed on the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the targets that can actually
            be registered into this container, the function will only ever return anything if <paramref name="type"/>
            is a closed generic type whose definition equals <see cref="P:Rezolver.GenericTargetContainer.GenericType"/>.</param>
            <remarks>Targets which have been registered specifically against the exact closed generic type
            represented by <paramref name="type"/> take precedence over any targets which have been registered
            against the open generic type <see cref="P:Rezolver.GenericTargetContainer.GenericType"/>.</remarks>
        </member>
        <member name="M:Rezolver.GenericTargetContainer.FetchAll(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)" />
            </summary>
            <param name="type">The type whose targets are to be retrieved.</param>
        </member>
        <member name="T:Rezolver.IContainerConfig">
             <summary>
             A configuration callback for instances of <see cref="T:Rezolver.Container"/> (which also use <see cref="T:Rezolver.ITargetContainer"/>
             as the source of their registrations).
             </summary>
             <remarks>While similar to <see cref="T:Rezolver.ITargetContainerConfig"/>, this is specifically used
             for new container instances - since some configuration (setting of options etc) only applies to
             <see cref="T:Rezolver.Container"/> and not <see cref="T:Rezolver.ITargetContainer"/>.
            
             A configuration instance can be passed to any of the provided <see cref="T:Rezolver.Container"/>-derived types on
             construction (see the <see cref="M:Rezolver.Container.#ctor(Rezolver.IRootTargetContainer,Rezolver.IContainerConfig)"/>
             constructor).  If one is not passed then the <see cref="P:Rezolver.Container.DefaultConfig"/> is used.
            
             The built-in config implementations register services or set options in the target container passed
             to <see cref="M:Rezolver.IContainerConfig.Configure(Rezolver.Container,Rezolver.IRootTargetContainer)"/>.
             </remarks>
             <seealso cref="T:Rezolver.ITargetContainerConfig"/>
             <seealso cref="T:Rezolver.Configuration.ExpressionCompilation"/>
        </member>
        <member name="M:Rezolver.IContainerConfig.Configure(Rezolver.Container,Rezolver.IRootTargetContainer)">
            <summary>
            Performs the configuration represented by this insteance on the <paramref name="container"/> and its
            <paramref name="targets"/>.
            </summary>
            <param name="container">The container to which the configuration is to be applied.</param>
            <param name="targets">The <see cref="T:Rezolver.ITargetContainer"/> that is being used by the <paramref name="container"/>
            for its registrations and options.</param>
        </member>
        <member name="T:Rezolver.IContainerConfig`1">
             <summary>
             Marker interface for an <see cref="T:Rezolver.ITargetContainerConfig"/> which is responsible for configuring a specific type
             of object/behaviour/service/option for <see cref="T:Rezolver.Container"/> instances. (Determined by <typeparamref name="T"/>).
             </summary>
             <typeparam name="T">Implementation-dependent.  The type of option or service used by the container that is configured
             by this configuration object.</typeparam>
             <remarks>As with <see cref="T:Rezolver.ITargetContainerConfig`1"/>, this marker interface is included specifically to provide
             a convenient way to expression dependencies for container-related configuration objects which depend on, or which
             must be configured after, others of a specific type.
            
             The type parameter is completely free-form - it could be a specific service type, an option type, or something else
             entirely.
            
             Use of this interface is entirely optional; and you'll only implement it yourself (as with <see cref="T:Rezolver.IContainerConfig"/>)
             if you are extending Rezolver.
             </remarks>
        </member>
        <member name="M:Rezolver.IDirectTarget.GetValue">
            <summary>
            Gets the object
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rezolver.IFactoryProvider">
            <summary>
            Interface for an object (usually an <see cref="T:Rezolver.ITarget"/> which can provide a factory which a <see cref="T:Rezolver.Container"/>
            can use to get an instance. 
            </summary>
        </member>
        <member name="P:Rezolver.IFactoryProvider.Factory">
            <summary>
            Gets a factory delegate for the object to be used by a <see cref="T:Rezolver.Container"/>
            </summary>
            <returns>A delegate which, when invoked with a <see cref="T:Rezolver.ResolveContext"/>, produces the object</returns>
        </member>
        <member name="T:Rezolver.IFactoryProvider`1">
            <summary>
            Interface for an object (usually an <see cref="T:Rezolver.ITarget"/> which can provide its own strongly-typed
            factory which a <see cref="T:Rezolver.Container"/> can use to get an instance.
            </summary>
            <typeparam name="TService">The type of instance that will be produced by the <see cref="P:Rezolver.IFactoryProvider`1.Factory"/></typeparam>
        </member>
        <member name="P:Rezolver.IFactoryProvider`1.Factory">
            <summary>
            Gets a strongly-typed delegate for the object to be used by a <see cref="T:Rezolver.Container"/>
            </summary>
            <returns>A delegate which, when invoked with a <see cref="T:Rezolver.ResolveContext"/>, produces the object</returns>
        </member>
        <member name="T:Rezolver.IInstanceProvider">
            <summary>
            Interface for an object (usually a <see cref="T:Rezolver.ITarget"/> implementation) which can provide an instance
            for a given <see cref="T:Rezolver.ResolveContext"/> without needing to be compiled.
            </summary>
        </member>
        <member name="M:Rezolver.IInstanceProvider.GetInstance(Rezolver.ResolveContext)">
            <summary>
            Method to call to get an instance for a particular <see cref="T:Rezolver.ResolveContext"/>
            </summary>
            <param name="context">The context</param>
            <returns>The object</returns>
        </member>
        <member name="T:Rezolver.IInstanceProvider`1">
            <summary>
            Strongly-typed version of <see cref="T:Rezolver.IInstanceProvider"/>
            </summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:Rezolver.IInstanceProvider`1.GetInstance(Rezolver.ResolveContext)">
            <summary>
            Gets an instance of <typeparamref name="TService"/> 
            </summary>
            <param name="context">The context</param>
            <returns>An instance of <typeparamref name="TService"/></returns>
        </member>
        <member name="T:Rezolver.IMemberBindingBehaviour">
            <summary>
            Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance.
            </summary>
            <seealso cref="T:Rezolver.BindNoMembersBehaviour"/>
            <seealso cref="T:Rezolver.BindAllMembersBehaviour"/>
            <seealso cref="T:Rezolver.MemberBindingBehaviour"/>
            <remarks>
            See the [member binding guide](/developers/docs/member-injection/index.html) for more.
            </remarks>
        </member>
        <member name="M:Rezolver.IMemberBindingBehaviour.GetMemberBindings(Rezolver.Compilation.ICompileContext,System.Type)">
            <summary>
            Retrieves the property and/or field bindings for the given <paramref name="type"/> based on the given <paramref name="context"/>.
            </summary>
            <param name="context">The current compilation context (will be used to look up <see cref="T:Rezolver.ITarget"/> references from its
            implementation of <see cref="T:Rezolver.ITargetContainer"/></param>
            <param name="type">The type whose writable members are to be probed.</param>
            <returns>Zero or more bindings for the members of the <paramref name="type"/>.</returns>
        </member>
        <member name="T:Rezolver.IMemberBindingBehaviourBuilder`1">
            <summary>
            An object responsible for building an <see cref="T:Rezolver.IMemberBindingBehaviour"/> for instances of the type <typeparamref name="TInstance"/>
            </summary>
            <typeparam name="TInstance">The type of object for which a member binding behaviour is to be built.</typeparam>
            <remarks>This interface is part of [the fluent API](/developers/docs/member-injection/fluent-api.html) which drastically 
            simplifies the way in which you can configure custom member bindings for objects of different types.
            The <see cref="M:Rezolver.MemberBindingBehaviour.For``1"/> method is the easiest way to get an instance of this to work with.</remarks>
        </member>
        <member name="M:Rezolver.IMemberBindingBehaviourBuilder`1.Bind``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Adds a member binding to the builder - the <paramref name="memberBindingExpression"/> identifies the member to
            be built.  The returned <see cref="T:Rezolver.MemberBindingBuilder`2"/> can then be used to customise
            how the member will be bound.
            </summary>
            <typeparam name="TMember">The type of member to be bound.</typeparam>
            <param name="memberBindingExpression">An expression which identifies the member to be bound.  The expression *must*
            be a direct member access, otherwise an <see cref="T:System.ArgumentException"/> will be thrown.</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.IMemberBindingBehaviourBuilder`1.BuildBehaviour">
            <summary>
            Builds an <see cref="T:Rezolver.IMemberBindingBehaviour"/> which, when applied to the object produced by a <see cref="T:Rezolver.Targets.ConstructorTarget"/>, will
            bind the members of the new instance according to the way it has been configured through calls to the
            <see cref="M:Rezolver.IMemberBindingBehaviourBuilder`1.Bind``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})"/> method.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rezolver.INotifyRegistrationTarget">
            <summary>
            A target which receives a notification from an <see cref="T:Rezolver.ITargetContainer"/>
            when it is registered in an <see cref="T:Rezolver.ITargetContainer"/>.  Targets which implement
            this interface will typically be looking to perform some additional post-registration 
            configuration or additional registrations.
            </summary>
        </member>
        <member name="T:Rezolver.IRootTargetContainer">
             <summary>
             Interface for the root-most target container, which typically 'owns' all the top-level registrations
             required by an application.
            
             This builds on the <see cref="T:Rezolver.ITargetContainer"/> interface by adding the <see cref="T:Rezolver.ICovariantTypeIndex"/>
             interface too, as well as events which allow an application to listen for target and target container registrations
             within the root.
             </summary>
        </member>
        <member name="E:Rezolver.IRootTargetContainer.TargetRegistered">
            <summary>
            Raised when a target has been registered in this root container (possibly as a child within a
            target container that was previously registered).
            </summary>
            <remarks>
            Please note - this event is only guaranteed to fire for targets that are
            directly registered through this instance.</remarks>
        </member>
        <member name="E:Rezolver.IRootTargetContainer.TargetContainerRegistered">
            <summary>
            Raised when a child target container (e.g. a <see cref="T:Rezolver.DecoratingTargetContainer"/>)
            is registered in this root container, or when any container is automatically created and
            registered in this root container.
            </summary>
            <remarks>Please note - this event is only guaranteed to fire for target containers that are
            directly registered through this instance.</remarks>
        </member>
        <member name="M:Rezolver.IRootTargetContainer.CreateTargetContainer(System.Type)">
            <summary>
            Creates an instance of <see cref="T:Rezolver.ITargetContainer"/> whose <see cref="P:Rezolver.ITargetContainer.Root"/>
            will be set to this instance and which will ultimately own all registrations for the given
            <paramref name="forContainerRegistrationType"/>.
            
            Note - the container is not automatically registered - it can be registered with a call to 
            this instance's <see cref="M:Rezolver.ITargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)"/> implementation.
            </summary>
            <param name="forContainerRegistrationType"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.IRootTargetContainer.GetContainerRegistrationType(System.Type)">
            <summary>
            Gets the type under which the <see cref="T:Rezolver.ITargetContainer"/> that will 'own' registrations
            for the given <paramref name="serviceType"/> will be registered in this root container.
            </summary>
            <param name="serviceType"></param>
            <returns></returns>
            <remarks>Use of this API is exclusive to code that is extending Rezolver.
            
            All targets that are registered in an <see cref="T:Rezolver.IRootTargetContainer"/> are ultimately stored
            inside another <see cref="T:Rezolver.ITargetContainer"/> that will be registered with the
            <see cref="M:Rezolver.ITargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)"/> API and retrieved
            with the <see cref="M:Rezolver.ITargetContainer.FetchContainer(System.Type)"/> methods.  When registering
            targets, both this method and the <see cref="M:Rezolver.IRootTargetContainer.CreateTargetContainer(System.Type)"/> methods are used
            to ensure that the correct <see cref="T:Rezolver.ITargetContainer"/> is created to hold a given target.
            
            This method is specifically used to identify the type that should be used to fetch a target 
            container (or indeed register it) for a given service type.  Most of the time, the two types
            are the same; however, there are special cases where they're not.
            
            For example, in the standard implementation of this interface (<see cref="T:Rezolver.TargetContainer"/>),
            if you pass a generic type to this method, it will return the definition of that generic type - 
            which then allows the <see cref="T:Rezolver.GenericTargetContainer"/> class to ultimately 'own' all the 
            registrations against all generic types - open or closed.
            
            Therefore, the system uses this method both to locate existing target containers and when 
            auto-creating and registering new target containers to hold new registrations.</remarks>
        </member>
        <member name="T:Rezolver.ITarget">
            <summary>
            Represents an action to be performed in order to obtain an object to satisfy a call to <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/>.
            </summary>
            <remarks>
            The framework's many implementations of this interface - e.g. <see cref="T:Rezolver.Targets.ConstructorTarget"/>, <see cref="T:Rezolver.Targets.SingletonTarget"/>,
            <see cref="T:Rezolver.Targets.ResolvedTarget"/> plus many others - then define the behaviour and any additional data required in order for a compiler
            to produce a factory which matches the target's intent.  E.g, the <see cref="T:Rezolver.Targets.ConstructorTarget"/>, which
            represents creating a new instance via a constructor, provides all the necessary information to bind to the correct constructor
            (including parameter bindings etc) - and the compiler's job (<see cref="T:Rezolver.Compilation.Expressions.ConstructorTargetBuilder"/>) is 
            to translate that into code that can be compiled into a factory which executes that constructor, returning the result.
            </remarks>
        </member>
        <member name="P:Rezolver.ITarget.Id">
            <summary>
            Unique Id for this target
            </summary>
        </member>
        <member name="P:Rezolver.ITarget.UseFallback">
            <summary>
            If <c>true</c>, then the consumer should consider falling back to a more suitable target if available, as
            the object produced from this target is most likely a default of some kind - e.g. empty enumerable, default
            parameter value.
            </summary>
        </member>
        <member name="P:Rezolver.ITarget.DeclaredType">
            <summary>
            Gets the static type of the object produced from this target.  For example, if this target represents executing
            a constructor on a type, then this property should equal the type to which that constructor belongs.
            </summary>
        </member>
        <member name="P:Rezolver.ITarget.ScopeBehaviour">
            <summary>
            Gets the scoping behaviour for instances that will ultimately be produced by this target.
            </summary>
            <value>The scope behaviour.</value>
        </member>
        <member name="P:Rezolver.ITarget.ScopePreference">
            <summary>
            Get the preferred scope in which an object produced from this target should be tracked.
            </summary>
        </member>
        <member name="M:Rezolver.ITarget.SupportsType(System.Type)">
             <summary>
             Returns a boolean indicating whether the target is able to produce an instance of, or an instance
             that is compatible with, the passed <paramref name="type"/>.
             </summary>
             <param name="type">The type.</param>
             <returns><c>true</c> if <paramref name="type"/> is supported, <c>false</c> otherwise.</returns>
             <remarks>It is strongly suggested that you use this method to check whether the target can construct
             an instance of a given type rather than performing any type checking yourself on the
             <see cref="P:Rezolver.ITarget.DeclaredType"/>, because an <see cref="T:Rezolver.ITarget"/> might be able to support a much wider
             range of types other than just those which are directly compatible with its <see cref="P:Rezolver.ITarget.DeclaredType"/>.
            
             For example, the <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> is statically bound to an open generic, so therefore
             traditional type checks on the <see cref="P:Rezolver.ITarget.DeclaredType"/> do not work.  That class' implementation of this
             method, however, contains the complex logic necessary to determine if the open generic can be closed into a
             generic type which is compatible with the given <paramref name="type"/>.
            
             Implementations of <see cref="T:Rezolver.Compilation.ITargetCompiler"/> should always consult this function in their
             implementation of <see cref="M:Rezolver.Compilation.ITargetCompiler.CompileTarget(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)"/>
             to determine if the target is compatible with the <see cref="P:Rezolver.Compilation.CompileContext.TargetType"/> of the
             <see cref="T:Rezolver.Compilation.CompileContext"/>
            
             Please note that any <paramref name="type"/> that's a generic type definition will always yield a false result,
             because it's impossible to build an instance of an open generic type.
             </remarks>
        </member>
        <member name="T:Rezolver.ITargetContainer">
             <summary>
             Stores and retrieves <see cref="T:Rezolver.ITarget"/> instances, keyed by the type of service
             that the targets are registered against.
            
             This is where all your service registrations will ultimately go.
            
             </summary>
             <remarks>You do not resolve objects from a target container, instead, it holds the <see cref="T:Rezolver.ITarget"/>s which will
             later be compiled to produce the objects.
            
             A target container is considered mutable for its entire lifetime, because it's only a glorified dictionary
             of targets from which multiple <see cref="T:Rezolver.Container"/> objects can be built (when using the types provided
             in the framework).
            
             As an example, the <see cref="T:Rezolver.Container"/> class uses this as the source of the registrations that it uses to resolve objects
             in its <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> implementation.
            
             Note that there are multiple implementations of this interface in the framework, however the two you will use most commonly
             are <see cref="T:Rezolver.TargetContainer"/> and <see cref="T:Rezolver.OverridingTargetContainer"/>.</remarks>
        </member>
        <member name="P:Rezolver.ITargetContainer.Root">
            <summary>
            The <see cref="T:Rezolver.IRootTargetContainer"/> in which this target container is registered.
            </summary>
        </member>
        <member name="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)">
             <summary>
             Registers a target, either for the <paramref name="serviceType"/> specified or, if null, the <see cref="P:Rezolver.ITarget.DeclaredType"/>
             of the <paramref name="target"/>.
             </summary>
             <param name="target">Required.  The target to be registered</param>
             <param name="serviceType">Optional.  The type the target is to be registered against, if different
             from the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the <paramref name="target"/>.  If provided, then the <paramref name="target"/>
             must be compatible with this type.</param>
             <remarks>The interface does not define the behaviour for when multiple targets are registered against the same type - although
             the default behaviour of the framework (via the <see cref="T:Rezolver.TargetContainer"/> class) is to allow this, with the last registered target
             being treated as the 'default' for that type.
            
             The only guarantee expected by the framework from implementations of this interface is that if a target is registered against
             a given type with this method, then a <see cref="M:Rezolver.ITargetContainer.Fetch(System.Type)"/> operation with the same type should return a valid target,
             and a <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)"/> operation should return a non-empty enumerable of targets.</remarks>
             <exception cref="T:System.ArgumentException">If <paramref name="serviceType"/> is non-null and the <paramref name="target"/>'s
             <see cref="M:Rezolver.ITarget.SupportsType(System.Type)"/> method returns <c>false</c> for that type.</exception>
        </member>
        <member name="M:Rezolver.ITargetContainer.Fetch(System.Type)">
             <summary>
             Retrieves a target for a particular type, or null if no target is registered against that type.
             </summary>
             <param name="type">Required.  The type for which an <see cref="T:Rezolver.ITarget"/> is to be retrieved.</param>
             <returns>The target for the given <paramref name="type"/>, or null if no target is found.</returns>
             <remarks>The target you receive from this method depends entirely on the implementation.
            
             It could be the last target to be registered against the <paramref name="type"/> or the first, or
             another target entirely.
            
             As mentioned in the documentation for the <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/> method - the only guarantee is that if
             at least one target has been registered for the same type, then this method should return a valid target.</remarks>
        </member>
        <member name="M:Rezolver.ITargetContainer.FetchAll(System.Type)">
            <summary>
            Retrieves an enumerable of all targets that have been registered for a particular <paramref name="type"/>.
            </summary>
            <param name="type">Required.  The type for which the <see cref="T:Rezolver.ITarget"/>s are to be retrieved.</param>
            <returns>An enumerable containing all the targets that have been registered against the given <paramref name="type"/>, or,
            an empty enumerable if no targets have been registered.</returns>
            <remarks>As with <see cref="M:Rezolver.ITargetContainer.Fetch(System.Type)"/>, the only guarantee is that if a target has been registered for the <paramref name="type"/>
            through a call to <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/>, then the returned enumerable will contain at least one valid target.</remarks>
        </member>
        <member name="M:Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer,System.Type)">
            <summary>
            If supported by the implementation, this gets the container built from combining this container with
            an <paramref name="existing"/> container as part of a registration inside another <see cref="T:Rezolver.ITargetContainer"/>.
            </summary>
            <param name="existing">The existing <see cref="T:Rezolver.ITargetContainer"/> instance that this instance is to be combined with</param>
            <param name="type">The type that the combined container owner will be registered under.</param>
            <returns></returns>
            <remarks>Used most frequently in implementations of <see cref="M:Rezolver.ITargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)"/>
            when a container owner is already registered against the type, and a new container owner is then registered against the
            same type.  This behaviour is used to implement open generics and decorators, and can be used to implement more besides.</remarks>
            <exception cref="T:System.NotSupportedException">If this container doesn't support being combined with another.</exception>
        </member>
        <member name="M:Rezolver.ITargetContainer.FetchContainer(System.Type)">
            <summary>
            Retrieves an existing container registered against the given <paramref name="type"/>, or null if not found.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.ITargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)">
             <summary>
             Registers a container against a given <paramref name="type"/>.
            
             If a container already exists against this type, then the existing container's
             <see cref="M:Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer,System.Type)"/> method is called with the <paramref name="container"/> as the
             argument, and the resulting container will replace the existing one.
             </summary>
             <param name="type"></param>
             <param name="container"></param>
        </member>
        <member name="T:Rezolver.ITargetContainerConfig">
             <summary>
             A configuration callback for instances of <see cref="T:Rezolver.IRootTargetContainer"/>.
             </summary>
             <remarks>
             Clearly, this callback interface can be used to perform any action on an <see cref="T:Rezolver.IRootTargetContainer"/>,
             but the intention is to use it either to pre-register targets or target containers for specific types,
             or to set options on a target container.
            
             The automatic injection of enumerables, for example, is enabled by applying the <see cref="T:Rezolver.Configuration.InjectEnumerables"/>
             to a target container.
            
             Different target containers also have their own statically available default configuration collections,
             of the type <see cref="T:Rezolver.CombinedTargetContainerConfig"/>, which also implements this interface by
             applying multiple configurations to a target container - providing an easy way to combine multiple configurations
             as one.  The most commonly used and modified of these is the <see cref="P:Rezolver.TargetContainer.DefaultConfig"/>
             collection.
             </remarks>
             <seealso cref="P:Rezolver.TargetContainer.DefaultConfig"/>
             <seealso cref="T:Rezolver.CombinedTargetContainerConfig"/>
             <seealso cref="T:Rezolver.Configuration.InjectEnumerables"/>
             <seealso cref="T:Rezolver.Configuration.InjectResolveContext"/>
        </member>
        <member name="M:Rezolver.ITargetContainerConfig.Configure(Rezolver.IRootTargetContainer)">
            <summary>
            Called to apply this configuration to the given <paramref name="rootTargets"/>.
            </summary>
            <param name="rootTargets">The target container to which the configuration is to be applied - will not be
            null when called by the framework.</param>
        </member>
        <member name="T:Rezolver.ITargetContainerConfig`1">
             <summary>
             Marker interface for an <see cref="T:Rezolver.ITargetContainerConfig"/> which is responsible for configuring a specific type
             of object/behaviour/service/option. (Determined by <typeparamref name="T"/>).
             </summary>
             <typeparam name="T">Implementation-dependent.  Type of object that is configured/set/registered by this config.</typeparam>
             <remarks>As with <see cref="T:Rezolver.IContainerConfig`1"/>, this marker interface is included specifically to provide a convenient way
             to express dependencies for configuration objects which depend on, or which must be configured after, others of a specific type.
            
             The type parameter is completely free-form - it could be a specific service type, an option type
             (see <see cref="T:Rezolver.Configuration.Configure`1"/>), or something else entirely.
            
             Use of this interface is entirely optional; and you'll only implement it yourself (as with <see cref="T:Rezolver.ITargetContainerConfig"/>)
             if you are extending Rezolver.</remarks>
             <seealso cref="T:Rezolver.IContainerConfig`1"/>
        </member>
        <member name="T:Rezolver.ITargetContainerEventHandler`1">
            <summary>
            Interface for an object which handles an event of a particular type (<typeparamref name="TEvent"/>)
            raised from an <see cref="T:Rezolver.ITargetContainer"/>.
            </summary>
            <typeparam name="TEvent">The type of event being handled.</typeparam>
        </member>
        <member name="M:Rezolver.ITargetContainerEventHandler`1.Handle(Rezolver.ITargetContainer,`0)">
            <summary>
            Fires the event handler for the event <paramref name="e"/> raised from the
            target container <paramref name="source"/>.
            </summary>
            <param name="source">The target container which is raising the event</param>
            <param name="e">The event payload.</param>
        </member>
        <member name="T:Rezolver.ITargetContainerFactory">
            <summary>
            A target container option used by <see cref="T:Rezolver.TargetContainer"/> to create a new instance of
            an <see cref="T:Rezolver.ITargetContainer"/> to store target registrations for a specific type (or types
            relating to a specific type).
            </summary>
        </member>
        <member name="M:Rezolver.ITargetContainerFactory.CreateContainer(System.Type,Rezolver.ITargetContainer)">
            <summary>
            Creates an <see cref="T:Rezolver.ITargetContainer"/> suitable for registration in the <paramref name="targets"/>
            parent container for targets whose <see cref="P:Rezolver.ITarget.DeclaredType"/> is equal, or otherwise related,
            to the passed <paramref name="type"/>.
            </summary>
            <param name="type">A type that is, in some way, common to all targets or child target containers that will
            be registered in the required container.</param>
            <param name="targets">The target container into which the returned target container will be registered.</param>
            <returns>An <see cref="T:Rezolver.ITargetContainer"/> to be added to the <paramref name="targets"/> into which targets
            will be registered.  Or <c>null</c> if this factory doesn't handle the passed <paramref name="type"/>.</returns>
        </member>
        <member name="T:Rezolver.ITargetContainerTypeResolver">
            <summary>
            An interface used by <see cref="T:Rezolver.TargetContainer"/> (via the options API)
            to identify the container type for targets with a specific <see cref="P:Rezolver.ITarget.DeclaredType"/>.
            </summary>
        </member>
        <member name="M:Rezolver.ITargetContainerTypeResolver.GetContainerType(System.Type)">
            <summary>
            For operations such as <see cref="M:Rezolver.TargetDictionaryContainer.Fetch(System.Type)"/> and
            <see cref="M:Rezolver.TargetDictionaryContainer.FetchContainer(System.Type)"/>, the type requested might sometimes
            need to be redirected to another for the purposes of fetching the correct <see cref="T:Rezolver.ITargetContainer"/>
            for a given type of service.  If this method returns a non-null type, then the calling container
            will use that type instead of the original one passed when trying to locate a container for the
            service type.
            </summary>
            <param name="serviceType">The service type (equal to the <see cref="P:Rezolver.ITarget.DeclaredType"/> of
            any <see cref="T:Rezolver.ITarget"/> objects that might have been registered).</param>
            <returns>A type that should be used to look up a container, if different from the <paramref name="serviceType"/>,
            otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Rezolver.ICovariantTypeIndex">
             <summary>
             For any type `T`, there exists a list of zero or more other types with which
             it is compatible when covariance is supported.  This index provides the mechanism
             by which Rezolver can perform this reverse lookup.
             </summary>
             <remarks>
             In an IOC container, contravariance is signficantly easier to support since the only knowledge
             required is the type you want to retrieve - e.g. Action&lt;Derived&gt;.  To build a list of all
             the generic versions of Action&lt;&gt; which will be assignment-compatible to that type simply
             requires walking 'up' the type hierarchy of `Derived`.
            
             Covariance, on the other hand, is the opposite problem.  The caller requests a concrete generic
             type - e.g. Func&lt;Base&gt; - where one or more of the arguments is passed to a covariant type
             parameter.  In this case, there is a theoretically infinite set of types which might be assignment
             compatible to `Base`, so how do you determine which versions of Func&lt;&gt; to search for if there
             is no registration for the exact type?
            
             One way would be iterate all the registrations and filter out only those which are compatible, however
             this would take up quite a lot of time.  Rezolver, instead, uses this index, into which you add concrete
             types that you *know* have got at least one registered <see cref="T:Rezolver.ITarget"/>.  Later, when a generic type is
             sought, you can call that type up from this index, and it'll return a list of all the known types that have
             been added which are assignment compatible to that type by virtue of covariance.
            
             This index provides two lookups based on types that are registered: pure covariant-compatible types (e.g.
             IEnumerable&lt;Derived&gt; can be assigned to a reference of type IEnumerable&lt;Base&gt;) and
             assignment-compatible types (e.g IEnumerable&lt;Base&gt; can be assigned to a reference of type `IEnumerable`.
            
             When searching for a generic type that matches one in-hand - the covariant compatibility lookup is the one you
             need.  If you are conducting a search for a generic type which has a covariant type parameter (e.g. such as
             IEnumerable&lt;&gt; then you want the full assignment-compatibility lookup which does covariance as well as
             base/interface compatibility.
             </remarks>
        </member>
        <member name="M:Rezolver.ICovariantTypeIndex.AddKnownType(System.Type)">
             <summary>
             Called to add a new known service type to the index which is then mapped back to all the types with which it
             is assignment compatible via covariance and via base class or interface inheritance.
            
             The <see cref="M:Rezolver.ICovariantTypeIndex.GetKnownCovariantTypes(System.Type)"/> will then return the <paramref name="serviceType"/>
             when called with one of these compatible types.
             </summary>
             <param name="serviceType">The type to be added to the index.</param>
        </member>
        <member name="M:Rezolver.ICovariantTypeIndex.GetKnownCovariantTypes(System.Type)">
            <summary>
            This method returns all types, in order of most to least recently added - that have been added via the
            <see cref="M:Rezolver.ICovariantTypeIndex.AddKnownType(System.Type)"/> method and which are of the same generic type but which have one or
            more type arguments that are reference compatible to those in the passed <paramref name="serviceType"/>.
            So, if you pass Func&lt;Base&gt; then you might get back Func&lt;Derived&gt;
            if it has been added.
            </summary>
            <param name="serviceType">The type for which covariantly compatible known types are sought.</param>
            <returns>A non-null (possibly empty) enumerable of types which have been previously been added to the index
            via a call to <see cref="M:Rezolver.ICovariantTypeIndex.AddKnownType(System.Type)"/> and which are covariantly compatible with <paramref name="serviceType"/>.</returns>
        </member>
        <member name="M:Rezolver.ICovariantTypeIndex.GetKnownCompatibleTypes(System.Type)">
             <summary>
             This method returns the same types as <see cref="M:Rezolver.ICovariantTypeIndex.GetKnownCovariantTypes(System.Type)"/> but also adds any other types which are
             assignment compatible with the <paramref name="serviceType"/>.  This includes derived types or types which implement the
             interface, or other generics which are covariantly compatible via implemented interfaces.
            
             This method is suited for use when you are searching for targets for a covariant type parameter - such as looking for
             targets which can be included in an IEnumerable&lt;T&gt; (which is exactly what Rezolver does for enumerables).
            
             In this case, the order is most to least recent covariants, followed by most to least recent
             derived types.
             </summary>
             <param name="serviceType">The type for which all assignment-compatible known types are sought.</param>
             <returns>A non-null (possibly empty) enumerable of types which have been previously been added to the index
             via a call to <see cref="M:Rezolver.ICovariantTypeIndex.AddKnownType(System.Type)"/> and which are covariantly compatible with <paramref name="serviceType"/>
             either directly or by inheritance.</returns>
        </member>
        <member name="M:Rezolver.ICovariantTypeIndex.SelectTypes(System.Type)">
            <summary>
            Returns a <see cref="T:Rezolver.TargetTypeSelector"/> which will return the types to be sought, in order of most specific to
            least specific, which are compatible with the <paramref name="type"/>
            </summary>
            <param name="type">The type for which matches are sought.</param>
            <returns>A <see cref="T:Rezolver.TargetTypeSelector"/> which will generate a series of types to be sought.</returns>
        </member>
        <member name="T:Rezolver.ListMemberBinding">
            <summary>
            Represents a binding (i.e. like that produced by <see cref="T:Rezolver.IMemberBindingBehaviour"/>) to a collection-like
            property via dynamic collection initialiser.
            </summary>
        </member>
        <member name="P:Rezolver.ListMemberBinding.ElementType">
            <summary>
            Gets the element type of the enumerable (from the <see cref="P:Rezolver.MemberBinding.Target"/> whose contents will
            be added to the collection represented by the <see cref="P:Rezolver.MemberBinding.Member"/>.
            </summary>
        </member>
        <member name="P:Rezolver.ListMemberBinding.AddMethod">
            <summary>
            Gets the method to be called on the object exposed by the <see cref="P:Rezolver.MemberBinding.Member"/> which will add
            elements to the collection.  Expected to be a void instance method accepting one parameter of the type
            <see cref="P:Rezolver.ListMemberBinding.ElementType"/>
            </summary>
        </member>
        <member name="M:Rezolver.ListMemberBinding.#ctor(System.Reflection.MemberInfo,Rezolver.ITarget,System.Type,System.Reflection.MethodInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.ListMemberBinding"/> class.
            </summary>
            <param name="member">Required. The member to be bound with a collection initialiser.</param>
            <param name="target">Required. The target whose elements (it must be an enumerable with element type equal
            to <paramref name="elementType"/>) will be added to the <paramref name="member"/> when an instance
            is bound.</param>
            <param name="elementType">Required. The type of objects to be added to the collection exposed through the
            <paramref name="member"/></param>
            <param name="addMethod">Required. The method to call on the <paramref name="member"/> that will be used
            to add elements to the collection when initialisation occurs.</param>
        </member>
        <member name="T:Rezolver.MemberBinding">
             <summary>
             Represents the binding of an <see cref="T:Rezolver.ITarget"/> to a property or field of a given type.
            
             Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although
             they are technically equivalent.
             </summary>
             <remarks>You typically don't create this type directly - instead, other targets such as <see cref="T:Rezolver.Targets.ConstructorTarget"/>
             will create it as needed through the use of an <see cref="T:Rezolver.IMemberBindingBehaviour"/> object.
            
             However, the two constructors allow you either to create a binding to a specific target, or to
             create a binding that will automatically resolve the member type from the container.
             </remarks>
        </member>
        <member name="F:Rezolver.MemberBinding.None">
            <summary>
            Empty bindings.
            </summary>
        </member>
        <member name="P:Rezolver.MemberBinding.Member">
            <summary>
            Gets the member against which this binding is to be applied.
            </summary>
            <value>The member.</value>
        </member>
        <member name="P:Rezolver.MemberBinding.Target">
            <summary>
            Gets the target whose value when resolved will be written to the <see cref="P:Rezolver.MemberBinding.Member"/>
            </summary>
            <value>The target.</value>
        </member>
        <member name="P:Rezolver.MemberBinding.MemberType">
             <summary>
             Gets the type of the <see cref="P:Rezolver.MemberBinding.Member"/>.  E.g. if the member represents a String property
             on the declaring type, then this will return the <see cref="T:System.String"/> type.
            
             If the member represents an integer field, this it will return the <see cref="T:System.Int32"/> type.
             </summary>
             <value>The type of the member.</value>
        </member>
        <member name="M:Rezolver.MemberBinding.#ctor(System.Reflection.MemberInfo,Rezolver.ITarget)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.MemberBinding"/> class which will seek to bind
            the given <paramref name="member"/> with the result of the given <paramref name="target"/>.
            </summary>
            <param name="member">The member to be bound.</param>
            <param name="target">The target whose value will be written to the member.</param>
        </member>
        <member name="M:Rezolver.MemberBinding.#ctor(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.MemberBinding"/> class which will auto-bind
            the <paramref name="member"/> by resolving an instance of the member's type, or
            to the type passed in the <paramref name="resolveType"/> parameter.
            </summary>
            <param name="member">The member to be bound.</param>
            <param name="resolveType">If not <c>null</c> then this will be the type that'll
            be resolved from the container.  Otherwise, the member's type will be resolved from the
            container.</param>
        </member>
        <member name="T:Rezolver.MemberBindingBehaviour">
            <summary>
            Static accessor for the common member binding behaviours provided by Rezolver, also provides
            an entry point to build custom binding behaviours using the fluent API exposed by
            <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> and <see cref="T:Rezolver.MemberBindingBuilder`2"/> -
            via the <see cref="M:Rezolver.MemberBindingBehaviour.For``1"/> method.
            </summary>
            <remarks>The <see cref="T:Rezolver.Targets.ConstructorTarget"/> and <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> classes can be provided
            with an <see cref="T:Rezolver.IMemberBindingBehaviour"/> when created.  If one is not set, then instead they will attempt to
            get their behaviour via the options API (e.g. <see cref="M:Rezolver.TargetContainerExtensions.GetOption``1(Rezolver.ITargetContainer,``0)"/>
            and <see cref="M:Rezolver.TargetContainerExtensions.SetOption``1(Rezolver.ITargetContainer,``0)"/>) from the
            <see cref="T:Rezolver.ITargetContainer"/> in which they have been registered.
            </remarks>
        </member>
        <member name="P:Rezolver.MemberBindingBehaviour.BindAll">
            <summary>
            A behaviour that binds all publicly writeable properties and fields on an object after construction,
            include all read-only properties which can be initialised as collections via a public Add method.
            </summary>
            <remarks>The implementation is an instance of the <see cref="T:Rezolver.BindAllMembersBehaviour"/></remarks>
        </member>
        <member name="P:Rezolver.MemberBindingBehaviour.BindNone">
             <summary>
             A behaviour that doesn't bind any properties or fields on an object.
            
             This is also the
             </summary>
             <remarks>The implementation is an instance of the <see cref="T:Rezolver.BindNoMembersBehaviour"/></remarks>
        </member>
        <member name="P:Rezolver.MemberBindingBehaviour.BindProperties">
            <summary>
            A behaviour which binds only publicly writeable properties, and read-only collection properties,
            on an object after construction.
            </summary>
        </member>
        <member name="P:Rezolver.MemberBindingBehaviour.BindFields">
            <summary>
            A behaviour which binds only public fields on an object after construction.
            </summary>
        </member>
        <member name="M:Rezolver.MemberBindingBehaviour.For``1">
            <summary>
            Creates a new <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> which provides a way to build your own custom
            binding behaviour via a fluent API.
            </summary>
            <typeparam name="TInstance">The type for which you want to build a custom member binding behaviour.</typeparam>
            <returns></returns>
        </member>
        <member name="T:Rezolver.MemberBindingBuilder`2">
             <summary>
             Builds individual <see cref="T:Rezolver.MemberBinding"/> objects for the <see cref="T:Rezolver.MemberBindingBehaviourBuilder`1"/> class.
            
             Created through the <see cref="M:Rezolver.MemberBindingBehaviourBuilder`1.Bind``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})"/>.
             </summary>
             <typeparam name="TInstance">The type of object whose member is to be bound during construction by the container.</typeparam>
             <typeparam name="TMember">The type of the member that is to be bound.</typeparam>
             <remarks>The class also implements the <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/></remarks>
        </member>
        <member name="P:Rezolver.MemberBindingBuilder`2.Member">
            <summary>
            Gets the member that will be bound by the <see cref="T:Rezolver.MemberBinding"/>
            </summary>
        </member>
        <member name="P:Rezolver.MemberBindingBuilder`2.Parent">
            <summary>
            Gets the behaviour builder to which this belongs
            </summary>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.BuildBehaviour">
             <summary>
             Creates the <see cref="T:Rezolver.IMemberBindingBehaviour"/> represented by the current set of bindings
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.ToType``1">
            <summary>
            Sets the binding for the member to a particular type - so when the member is bound, an
            instance of <typeparamref name="TTarget"/> is resolved.
            </summary>
            <typeparam name="TTarget">The type to be resolved.</typeparam>
            <returns>The bindings builder, in order that another member binding can be created and configured.</returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.ToType(System.Type)">
            <summary>
            Sets the binding for the member to a particular type - so when the member is bound, an
            instance of <paramref name="type"/> is resolved.
            </summary>
            <param name="type">The type to be resolved.</param>
            <returns>The bindings builder, in order that another member binding can be created and configured.</returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.ToTarget(Rezolver.ITarget)">
            <summary>
            Sets the binding for the member to a particular target.
            </summary>
            <param name="target">The target that is to be used to bind the member.</param>
            <returns>The bindings builder, in order that another member binding can be created and configured.</returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.ToObject(`1)">
            <summary>
            Sets the binding for the member to a constant service - equivalent to
            calling <see cref="M:Rezolver.MemberBindingBuilder`2.ToTarget(Rezolver.ITarget)"/> with an <see cref="T:Rezolver.Targets.ObjectTarget"/>
            </summary>
            <param name="obj">The value to be bound to the member</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.AsCollection">
             <summary>
             Explicitly sets the member to be bound as a collection initialiser - i.e. instead of resolving an
             instance of the member type, Rezolver will resolve an enumerable of an element type, which is then
             added to the collection after construction using a publicly available `Add` method on the member type.
            
             Use this when a member is of a type which satisfies the usual requirements for collection
             initialisation, but is read/write (since collection initialisation only kicks in automatically for read-only
             collection properties).
            
             The element type of the collection will be determined from the type's implementation of <see cref="T:System.Collections.Generic.IEnumerable`1"/>
             </summary>
             <returns>The bindings builder, in order that another member binding can be created and configured.</returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.AsCollection(Rezolver.ITarget[])">
             <summary>
             Explicitly sets the member to be bound as a collection initialiser using the targets passed in
             the <paramref name="elementTargets"/> argument.
            
             </summary>
             <param name="elementTargets"></param>
             <returns></returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.AsCollection(System.Type[])">
            <summary>
            This binds a collection member to an enumerable whose elements are resolved at resolve-time
            via the types provided.  In effect, multiple resolve operations are performed and the results
            are then fed into the collection.
            </summary>
            <param name="elementTypes">The types of each individual element</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.AsCollection``1">
             <summary>
             Explicitly sets the member to be bound as a collection initialiser - i.e. instead of resolving an
             instance of the member type, Rezolver will resolve an enumerable of the type <typeparamref name="TElement"/>,
             which is then added to the collection after construction using a publicly available `Add` method on the
             member type.
            
             Use this when a member is of a type which satisfies the usual requirements for collection
             initialisation, but is read/write (since collection initialisation only kicks in automatically for read-only
             collection properties.  Or when you want to fill a collection with elements of a particular type.
             </summary>
             <typeparam name="TElement">The element type of the enumerable that will be used to initialise the collection
             represented by the member.</typeparam>
             <returns>The bindings builder, in order that another member binding can be created and configured.</returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.AsCollection(System.Type)">
            <summary>
            Non-generic version of the <see cref="M:Rezolver.MemberBindingBuilder`2.AsCollection``1"/> method.
            </summary>
            <param name="elementType">The element type of the enumerable that will be used to initialise the collection
            represented by the member.</param>
            <returns>The bindings builder, in order that another member binding can be created and configured.</returns>
        </member>
        <member name="M:Rezolver.MemberBindingBuilder`2.Bind``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Called to commence building a binding for another member belonging to the type <typeparamref name="TInstance"/>.
            </summary>
            <typeparam name="TNextMember">Type of the member represented by the expression <paramref name="memberBindingExpression"/>.</typeparam>
            <param name="memberBindingExpression">An expression that represents reading the member to be bound.  The body of the
            expression must be a <see cref="T:System.Linq.Expressions.MemberExpression"/> with the <see cref="P:System.Linq.Expressions.Expression.Type"/> of the
            <see cref="P:System.Linq.Expressions.MemberExpression.Expression"/> equal to <typeparamref name="TInstance" />.</param>
            <returns>A builder that can be used to customise the binding for the member represented by the expression
            <paramref name="memberBindingExpression"/></returns>
        </member>
        <member name="T:Rezolver.MemberBindingBehaviourBuilder`1">
             <summary>
             Class for building custom <see cref="T:Rezolver.IMemberBindingBehaviour"/> for instances of <typeparamref name="TInstance"/>,
             default implementation of <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/>.
             </summary>
             <typeparam name="TInstance"></typeparam>
             <remarks>
             To create custom bindings for individual members, use the <see cref="M:Rezolver.MemberBindingBehaviourBuilder`1.Bind``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})"/>
             method to create a <see cref="T:Rezolver.MemberBindingBuilder`2"/> which contains methods for controlling how a
             property or field will be bound.  Calls to that class will return an <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> which then
             allow you to chain further member customisations via a fluent API.
            
             You can't create an instance of this class directly - the framework creates an instance for you, either returning it (in the case
             of <see cref="M:Rezolver.MemberBindingBehaviour.For``1"/>) or passing it as an argument to a callback (in the case of
             <see cref="M:Rezolver.Target.ForType``1(System.Action{Rezolver.IMemberBindingBehaviourBuilder{``0}})"/>, for example.
             </remarks>
        </member>
        <member name="M:Rezolver.MemberBindingBehaviourBuilder`1.BuildBehaviour">
             <summary>
             Implementation of <see cref="M:Rezolver.IMemberBindingBehaviourBuilder`1.BuildBehaviour"/>.
            
             Creates a new member binding behaviour that can, for example, be passed to a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or other .
             </summary>
             <returns>A new <see cref="T:Rezolver.IMemberBindingBehaviour"/> which will bind only the members which you've identified with
             one or more calls to the <see cref="M:Rezolver.MemberBindingBehaviourBuilder`1.Bind``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})"/> method of this or
             the <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> returned by the <see cref="T:Rezolver.MemberBindingBuilder`2"/>
             returned by the `Bind` method.</returns>
        </member>
        <member name="M:Rezolver.MemberBindingBehaviourBuilder`1.Bind``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Marks a member of the type <typeparamref name="TInstance"/> to be bound.  The returned <see cref="T:Rezolver.MemberBindingBuilder`2"/>
            can be used to customise the binding; and/or it can be used to continue marking other members to be bound.
            </summary>
            <typeparam name="TMember">Type of the member represented by the expression <paramref name="memberBindingExpression"/>.</typeparam>
            <param name="memberBindingExpression">An expression that represents reading the member to be bound.  The body of the
            expression must be a <see cref="T:System.Linq.Expressions.MemberExpression"/> with the <see cref="P:System.Linq.Expressions.Expression.Type"/> of the
            <see cref="P:System.Linq.Expressions.MemberExpression.Expression"/> equal to <typeparamref name="TInstance" />.</param>
            <returns>A builder that can be used to customise the binding for the member represented by the expression
            <paramref name="memberBindingExpression"/></returns>
        </member>
        <member name="T:Rezolver.MethodBinding">
            <summary>
            Represents a binding to a method whose arguments will be supplied by <see cref="T:Rezolver.ITarget" /> instances.
            </summary>
        </member>
        <member name="P:Rezolver.MethodBinding.Method">
            <summary>
            Gets the method to be invoked.
            </summary>
            <value>The method.</value>
        </member>
        <member name="P:Rezolver.MethodBinding.BoundArguments">
             <summary>
             Gets the argument bindings for the method call.
            
             Never null but can be empty.
             </summary>
             <value>The bound arguments.</value>
        </member>
        <member name="M:Rezolver.MethodBinding.#ctor(System.Reflection.MethodBase,Rezolver.ParameterBinding[])">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.MethodBinding"/> class.
            </summary>
            <param name="method">The method.</param>
            <param name="boundArgs">Optional.  The bound arguments.  Can be null or empty.</param>
        </member>
        <member name="T:Rezolver.NonTrackingContainerScope">
            <summary>
            Default scope object used by the<see cref="T:Rezolver.Container"/> - performs no actual lifetime management
            of objects at all, but can create child scopes and track them for disposal when it is disposed.
            
            In order to get object lifetime management from a container whose scope is set to an instance of this type,
            a new scope must be created from this one.
            </summary>
        </member>
        <member name="M:Rezolver.NonTrackingContainerScope.CreateScope">
            <summary>
            Creates a new child scope from this scope.  The new scope will use the same container as this one,
            but will have its own lifetime, and will track its own instances of any 'scoped' objects.
            
            When this scope is disposed, the new scope will be disposed also - unless it has already been disposed.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rezolver.IResolveContext">
            <summary>
            This interface is now obsolete in v2.0
            </summary>
        </member>
        <member name="P:Rezolver.IResolveContext.Previous">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Rezolver.IResolveContext.RequestedType">
            <summary>
            Obsolete, use <see cref="P:Rezolver.ResolveContext.RequestedType"/>
            </summary>
        </member>
        <member name="P:Rezolver.IResolveContext.Container">
            <summary>
            Obsolete"/>
            </summary>
        </member>
        <member name="P:Rezolver.IResolveContext.Scope">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Rezolver.IResolveContext.Resolve(System.Type)">
            <summary>
            Obsolete, use <see cref="M:Rezolver.ResolveContext.Resolve(System.Type)"/>
            </summary>
        </member>
        <member name="M:Rezolver.IResolveContext.Resolve``1">
            <summary>
            Obsolete, use <see cref="M:Rezolver.ResolveContext.Resolve``1"/>
            </summary>
        </member>
        <member name="M:Rezolver.IResolveContext.TryResolve(System.Type,System.Object@)">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Rezolver.IResolveContext.TryResolve``1(``0@)">
            <summary>
            Obsolete"/>
            </summary>
        </member>
        <member name="M:Rezolver.IResolveContext.New(System.Type,Rezolver.IContainer,Rezolver.IContainerScope)">
            <summary>
            Obsolete, use <see cref="M:Rezolver.ResolveContext.ChangeRequestedType(System.Type)"/> or <see cref="M:Rezolver.ResolveContext.ChangeContainer(Rezolver.Container)"/>
            </summary>
        </member>
        <member name="T:Rezolver.IContainer">
            <summary>
            Obsolete interface - now use the <see cref="T:Rezolver.Container"/> class
            </summary>
        </member>
        <member name="M:Rezolver.IContainer.CanResolve(Rezolver.ResolveContext)">
            <summary>
            Obsolete, use <see cref="M:Rezolver.Container.CanResolve(System.Type)"/>
            </summary>
        </member>
        <member name="M:Rezolver.IContainer.Resolve(Rezolver.ResolveContext)">
            <summary>
            Obsolete, use <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/>
            </summary>
        </member>
        <member name="M:Rezolver.IContainer.TryResolve(Rezolver.ResolveContext,System.Object@)">
            <summary>
            Obsolete, use <see cref="M:Rezolver.Container.TryResolve(Rezolver.ResolveContext,System.Object@)"/>
            </summary>
        </member>
        <member name="M:Rezolver.IContainer.GetCompiledTarget(Rezolver.ResolveContext)">
            <summary>
            Obsolete, use <see cref="M:Rezolver.Container.GetFactory(Rezolver.ResolveContext)"/>
            </summary>
        </member>
        <member name="T:Rezolver.IScopedContainer">
            <summary>
            Obsolete - use <see cref="T:Rezolver.ScopedContainer"/>
            </summary>
        </member>
        <member name="P:Rezolver.IScopedContainer.Scope">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="T:Rezolver.IContainerScope">
            <summary>
            Obsolete in v2 use <see cref="T:Rezolver.ContainerScope"/>
            </summary>
        </member>
        <member name="P:Rezolver.IContainerScope.Parent">
            <summary>
            Obsolete, use <see cref="P:Rezolver.ContainerScope.Parent"/>
            </summary>
        </member>
        <member name="P:Rezolver.IContainerScope.Container">
            <summary>
            Obsolete, use <see cref="P:Rezolver.ContainerScope.Container"/>
            </summary>
        </member>
        <member name="M:Rezolver.IContainerScope.ChildScopeDisposed(Rezolver.IContainerScope)">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Rezolver.IContainerScope.Resolve(Rezolver.ResolveContext,System.Int32,System.Func{Rezolver.ResolveContext,System.Object},Rezolver.ScopeBehaviour)">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="T:Rezolver.IScopeFactory">
            <summary>
            Represents an object from which a scope can be created
            </summary>
        </member>
        <member name="M:Rezolver.IScopeFactory.CreateScope">
            <summary>
            Creates a new scope.  If the implementing object is also a scope, then the new scope must be
            created as a child scope of that scope.
            </summary>
        </member>
        <member name="T:Rezolver.ContainerScopeExtensions">
            <summary>
            Obsolete - container scope is available directly from <see cref="P:Rezolver.ContainerScope.Root"/>
            </summary>
        </member>
        <member name="M:Rezolver.ContainerScopeExtensions.GetRootScope(Rezolver.IContainerScope)">
            <summary>
            Obsolete - container scope is available directly from <see cref="P:Rezolver.ContainerScope.Root"/>
            </summary>
        </member>
        <member name="T:Rezolver.ContainerScopeResolveExtensions">
            <summary>
            The extension methods in this class are no longer required.  Use ContainerScope directly
            </summary>
        </member>
        <member name="M:Rezolver.ContainerScopeResolveExtensions.Resolve``1(Rezolver.IContainerScope)">
            <summary>
            Obsolete - use the direct resolve operations declared directly on the <see cref="T:Rezolver.ContainerScope"/> class
            </summary>
        </member>
        <member name="M:Rezolver.ContainerScopeResolveExtensions.Resolve(Rezolver.IContainerScope,System.Type)">
            <summary>
            Obsolete - use the direct resolve operations declared directly on the <see cref="T:Rezolver.ContainerScope"/> class
            </summary>
        </member>
        <member name="M:Rezolver.ContainerScopeResolveExtensions.ResolveMany(Rezolver.IContainerScope,System.Type)">
            <summary>
            Obsolete - use the direct resolve operations declared directly on the <see cref="T:Rezolver.ContainerScope"/> class
            </summary>
        </member>
        <member name="M:Rezolver.ContainerScopeResolveExtensions.ResolveMany``1(Rezolver.IContainerScope)">
            <summary>
            Obsolete - use the direct resolve operations declared directly on the <see cref="T:Rezolver.ContainerScope"/> class
            </summary>
        </member>
        <member name="T:Rezolver.ICompiledTarget">
             <summary>
             Provides an abstraction for creating objects based on a given <see cref="T:Rezolver.ResolveContext"/> - this is
             the ultimate target of all <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> calls in the standard
             container implementations within the Rezolver framework.
             </summary>
             <remarks>An <see cref="T:Rezolver.Compilation.ITargetCompiler"/> creates instances of this from <see cref="T:Rezolver.ITarget"/>s which are
             registered in an <see cref="T:Rezolver.ITargetContainer"/>.
            
             When the container is then called upon to resolve an instance of a particular type, the <see cref="T:Rezolver.ICompiledTarget"/> is first
             obtained, and then the responsibility for creating the object is delegated to its <see cref="M:Rezolver.ICompiledTarget.GetObject(Rezolver.ResolveContext)"/>
             method.</remarks>
        </member>
        <member name="M:Rezolver.ICompiledTarget.GetObject(Rezolver.ResolveContext)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="P:Rezolver.ICompiledTarget.SourceTarget">
            <summary>
            Gets the <see cref="T:Rezolver.ITarget"/> from which this compiled target was produced
            </summary>
        </member>
        <member name="T:Rezolver.UnresolvedTypeCompiledTarget">
             <summary>
             An <see cref="T:Rezolver.ICompiledTarget"/> that can be used when a type could not be resolved.
            
             Implementations of both <see cref="M:Rezolver.UnresolvedTypeCompiledTarget.GetObject(Rezolver.ResolveContext)"/> and <see cref="P:Rezolver.UnresolvedTypeCompiledTarget.SourceTarget"/> will throw an exception
             if called/read.
             </summary>
             <remarks>Use of this class is encouraged when an <see cref="T:Rezolver.IContainer"/> cannot resolve a type.  Instead of
             checking the compiled target for a null, an instance of this can be returned in its place, but its only when the
             <see cref="M:Rezolver.UnresolvedTypeCompiledTarget.GetObject(Rezolver.ResolveContext)"/> method is executed that an exception occurs.
            
             This is particularly useful when using classes such as <see cref="T:Rezolver.OverridingContainer"/>, which allow dependencies
             that do not exist in the base container to be fulfilled by the overriding container instead: by delaying the throwing
             of exceptions until the resolve operation occurs, we are able to provide that override capability.</remarks>
        </member>
        <member name="P:Rezolver.UnresolvedTypeCompiledTarget.SourceTarget">
            <summary>
            Implementation of <see cref="P:Rezolver.ICompiledTarget.SourceTarget"/>
            </summary>
            <remarks>Always throws an <see cref="T:System.InvalidOperationException"/></remarks>
        </member>
        <member name="M:Rezolver.UnresolvedTypeCompiledTarget.#ctor(System.Type)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.UnresolvedTypeCompiledTarget"/> class
            </summary>
            <param name="requestedType">Required.  The type that was requested, and which subsequently could not be resolved.</param>
        </member>
        <member name="M:Rezolver.UnresolvedTypeCompiledTarget.GetObject(Rezolver.ResolveContext)">
            <summary>
            Implementation of <see cref="M:Rezolver.ICompiledTarget.GetObject(Rezolver.ResolveContext)"/>
            </summary>
            <param name="context">The current <see cref="T:Rezolver.ResolveContext"/></param>
            <returns>Always throws an <see cref="T:System.InvalidOperationException"/></returns>
        </member>
        <member name="T:Rezolver.DirectCompiledTarget">
             <summary>
             An <see cref="T:Rezolver.ICompiledTarget"/> which wraps around an <see cref="T:Rezolver.IDirectTarget"/>.
            
             The implementation of <see cref="M:Rezolver.DirectCompiledTarget.GetObject(Rezolver.ResolveContext)"/> simply executes the target's
             <see cref="M:Rezolver.IDirectTarget.GetValue"/> method.
             </summary>
        </member>
        <member name="T:Rezolver.DelegatingCompiledTarget">
            <summary>
            Obsolete.  See <see cref="T:Rezolver.IFactoryProvider"/> and <see cref="T:Rezolver.IFactoryProvider`1"/>, and object factories
            are now just <see cref="T:System.Func`2"/> with <see cref="T:Rezolver.ResolveContext"/> as the parameter type
            and either <see cref="T:System.Object"/> as the return type or a strongly-typed return type equal to the
            instance type.
            </summary>
        </member>
        <member name="P:Rezolver.DelegatingCompiledTarget.SourceTarget">
            <summary>
            Implementation of <see cref="P:Rezolver.ICompiledTarget.SourceTarget"/>
            </summary>
        </member>
        <member name="M:Rezolver.DelegatingCompiledTarget.#ctor(System.Func{Rezolver.ResolveContext,System.Object},Rezolver.ITarget)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.DelegatingCompiledTarget"/> class.
            </summary>
            <param name="callback">Required.  The delegate to be executed when
            <see cref="M:Rezolver.DelegatingCompiledTarget.GetObject(Rezolver.ResolveContext)"/> is called.</param>
            <param name="sourceTarget">Required.  The <see cref="T:Rezolver.ITarget"/> from which this
            <see cref="T:Rezolver.DelegatingCompiledTarget"/> is constructed.</param>
        </member>
        <member name="M:Rezolver.DelegatingCompiledTarget.GetObject(Rezolver.ResolveContext)">
            <summary>
            Implementation of <see cref="M:Rezolver.ICompiledTarget.GetObject(Rezolver.ResolveContext)" /> - simply
            executes the delegate passed on construction.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.ConstantCompiledTarget">
            <summary>
            Obsolete, use <see cref="T:System.Func`2"/>
            </summary>
        </member>
        <member name="P:Rezolver.ConstantCompiledTarget.SourceTarget">
            <summary>
            The target for which this compiled target was created.
            </summary>
        </member>
        <member name="M:Rezolver.ConstantCompiledTarget.#ctor(System.Object,Rezolver.ITarget)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.ConstantCompiledTarget"/>
            </summary>
            <param name="obj">The constant object to be returned by <see cref="M:Rezolver.ConstantCompiledTarget.GetObject(Rezolver.ResolveContext)"/></param>
            <param name="sourceTarget">The <see cref="T:Rezolver.ITarget"/> from which this compiled target is created.</param>
        </member>
        <member name="M:Rezolver.ConstantCompiledTarget.GetObject(Rezolver.ResolveContext)">
            <summary>
            Implementation of <see cref="M:Rezolver.ICompiledTarget.GetObject(Rezolver.ResolveContext)"/> - simply returns the
            target with which this instance was constructed.
            </summary>
            <param name="context">ignored</param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Options.AllowMultiple">
             <summary>
             A <see cref="T:System.Boolean"/> option that controls whether an <see cref="T:Rezolver.ITargetContainer"/>
             accepts multiple registered targets for the same underlying type.
            
             This option can be applied globally or on a per-service basis - but must be set *before*
             any potentially affected registrations are performed.
            
             The <see cref="P:Rezolver.Options.AllowMultiple.Default"/> (unset) is equivalent to <c>true</c>
             </summary>
        </member>
        <member name="P:Rezolver.Options.AllowMultiple.Default">
             <summary>
             The default value for this option if not configured.
            
             Equivalent to <c>true</c>.
             </summary>
        </member>
        <member name="M:Rezolver.Options.AllowMultiple.op_Implicit(System.Boolean)~Rezolver.Options.AllowMultiple">
            <summary>
            Implicit conversion operator to this option type from <see cref="T:System.Boolean"/>,
            which simplifies setting this option with a simple <c>true</c> or <c>false</c>
            value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rezolver.Options.ContainerOption`1">
             <summary>
             A suggested base class to use for custom container options to be read/written through extensions
             such as <see cref="M:Rezolver.TargetContainerExtensions.SetOption``1(Rezolver.ITargetContainer,``0)"/>,
             <see cref="M:Rezolver.TargetContainerExtensions.GetOptions``2(Rezolver.ITargetContainer)"/> and the various
             overloads.S
            
             The type of the option value is the argument to the <typeparamref name="TOption"/> type parameter.
            
             Options must currently be objects - the ability to use callbacks to get options might be added at a
             future date.
             </summary>
             <typeparam name="TOption">The underlying option value type - e.g. <see cref="T:System.Boolean"/>, <see cref="T:System.String"/>,
             <see cref="T:System.Uri"/> or whatever</typeparam>
             <remarks>
             **This type is creatable only through inheritance.**
            
            
             Options in Rezolver are achieved by using registrations in the <see cref="T:Rezolver.ITargetContainer"/> that
             is to be configured (and, in turn, which might then configure any <see cref="T:Rezolver.Container"/>s built from
             that target container).
            
             Since options often take the form of primitive types - e.g <see cref="T:System.Boolean"/>, <see cref="T:System.String"/> etc - this
             means it's impossible to register multiple options which control different things which have the same underlying
             type if we registered them directly.
            
             This class is offered as a way around this.  Options (e.g. <see cref="T:Rezolver.Options.AllowMultiple"/>) are derived from this type,
             with the argument to the <typeparamref name="TOption"/> type parameter set to the underlying type of the option value.
            
             Thus - each distinct option is a different type, which then means that an <see cref="T:Rezolver.ITargetContainer"/> can distinguish
             between them.
            
             ---
            
             ### Note:
            
             Whilst Rezolver uses this type for most of its configurable options, you don't need to use it. Any type can be used as 
             an option.</remarks>
        </member>
        <member name="P:Rezolver.Options.ContainerOption`1.Value">
            <summary>
            The underlying value wrapped by this option.
            </summary>
        </member>
        <member name="M:Rezolver.Options.ContainerOption`1.#ctor">
            <summary>
            Inheritance constructor.
            </summary>
        </member>
        <member name="M:Rezolver.Options.ContainerOption`1.op_Implicit(Rezolver.Options.ContainerOption{`0})~`0">
             <summary>
             Implicit casting operator to convert to the option value type from an instance of <see cref="T:Rezolver.Options.ContainerOption`1"/>.
            
             All derived types are encouraged to have a similar casting operator from <typeparamref name="TOption" /> to <see cref="T:Rezolver.Options.ContainerOption`1"/>
             (for example, see <see cref="T:Rezolver.Options.EnableEnumerableInjection"/>).
             </summary>
             <param name="option">The option object to be cast to <typeparamref name="TOption" /> (by reading its <see cref="P:Rezolver.Options.ContainerOption`1.Value"/> property).
            
             Note that if this is <c>null</c>, then the return value will be the default for <typeparamref name="TOption" /></param>
        </member>
        <member name="M:Rezolver.Options.ContainerOption`1.ToString">
            <summary>
            Provides a textual representation of the value of this option and its underlying type.
            </summary>
            <returns>A string in the form <code>"{Value} ({typeof(TOption)})"</code></returns>
        </member>
        <member name="T:Rezolver.Options.EnableArrayInjection">
             <summary>
             Controls whether Rezolver's built-in array injection (which is also dependent upon the
             built-in IEnumerable injection) is enabled.
            
             If not defined the <see cref="P:Rezolver.Options.EnableArrayInjection.Default"/> is equivalent to <c>true</c>.
             </summary>
        </member>
        <member name="P:Rezolver.Options.EnableArrayInjection.Default">
            <summary>
            The default value for this option - equivalent to <c>true</c>
            </summary>
        </member>
        <member name="M:Rezolver.Options.EnableArrayInjection.op_Implicit(System.Boolean)~Rezolver.Options.EnableArrayInjection">
            <summary>
            Convenience conversion operator to <see cref="T:Rezolver.Options.EnableArrayInjection"/> from <see cref="T:System.Boolean"/>
            </summary>
            <param name="value">The value to be wrapped as an <see cref="T:Rezolver.Options.EnableArrayInjection"/> option value</param>
        </member>
        <member name="T:Rezolver.Options.EnableAutoFuncInjection">
            <summary>
            Option which controls whether the <see cref="T:Rezolver.Configuration.InjectAutoFuncs"/> configuration is applied, which
            enables the automatic registration of <see cref="T:System.Func`1"/> whenever a target is registered.
            </summary>
        </member>
        <member name="P:Rezolver.Options.EnableAutoFuncInjection.Default">
            <summary>
            The Default setting for the <see cref="T:Rezolver.Options.EnableAutoFuncInjection"/> option - evaluates to <c>false</c>
            </summary>
        </member>
        <member name="M:Rezolver.Options.EnableAutoFuncInjection.op_Implicit(System.Boolean)~Rezolver.Options.EnableAutoFuncInjection">
            <summary>
            Convenience operator for treating booleans as <see cref="T:Rezolver.Options.EnableAutoFuncInjection"/> option values.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rezolver.Options.EnableAutoLazyInjection">
            <summary>
            Boolean option used to control whether <see cref="T:System.Lazy`1"/> injection will automatically
            work.  Used by 
            </summary>
        </member>
        <member name="P:Rezolver.Options.EnableAutoLazyInjection.Default">
            <summary>
            Default value for this option - equivalent to <c>false</c>
            </summary>
        </member>
        <member name="M:Rezolver.Options.EnableAutoLazyInjection.op_Implicit(System.Boolean)~Rezolver.Options.EnableAutoLazyInjection">
            <summary>
            Implicit conversion operator from <see cref="T:System.Boolean"/> to <see cref="T:Rezolver.Options.EnableAutoLazyInjection"/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rezolver.Options.EnableCollectionInjection">
             <summary>
             Boolean option which, if configured before the <see cref="T:Rezolver.Configuration.InjectCollections"/> configuration is applied,
             will control whether automatic injection of <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> (and related interfaces - see the documentation
             on that type for more) will be enabled.
             The <see cref="P:Rezolver.Options.EnableCollectionInjection.Default"/> is equivalent to <c>true</c>.
             </summary>
             <remarks>
             The injection behaviour controlled by this option most commonly piggybacks off of the behaviour that's enabled by the
             <see cref="T:Rezolver.Configuration.InjectEnumerables"/> configuration.
            
             However, although this option is therefore related to the <see cref="T:Rezolver.Options.EnableEnumerableInjection"/> option, the two are independent.
            
             If you disable automatic enumerable injection, it does not automatically disable automatic list injection.</remarks>
             <seealso cref="T:Rezolver.Configuration.InjectLists"/>
             <seealso cref="T:Rezolver.Options.EnableEnumerableInjection"/>
             <seealso cref="T:Rezolver.Configuration.InjectEnumerables"/>
        </member>
        <member name="P:Rezolver.Options.EnableCollectionInjection.Default">
            <summary>
            The Default setting for the <see cref="T:Rezolver.Options.EnableCollectionInjection"/> option - evaluates to <c>true</c>
            </summary>
        </member>
        <member name="M:Rezolver.Options.EnableCollectionInjection.op_Implicit(System.Boolean)~Rezolver.Options.EnableCollectionInjection">
            <summary>
            Convenience operator for treating booleans as <see cref="T:Rezolver.Options.EnableCollectionInjection"/> option values.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rezolver.Options.EnableContravariance">
             <summary>
             A <see cref="T:System.Boolean"/> container options that controls whether contravariant generic
             parameters will be matched to registrations of bases/interfaces of the associated
             type.
            
             This option can be applied globally or on a per-service basis. See the remarks section
             for more.
            
             The <see cref="F:Rezolver.Options.EnableContravariance.Default"/> (unset) is equivalent to <c>true</c>, meaning that contravariance
             is enabled, for all applicable types.
             </summary>
             <remarks>To disable contravariance globally, you can set this option to <c>false</c>
             using the <see cref="M:Rezolver.TargetContainerExtensions.SetOption``1(Rezolver.ITargetContainer,``0)"/>
             extension method.
            
             You can also disable contravariance for a particular interface or delegate type - either by
             targetting the open generic (e.g. <see cref="T:System.Action`1"/> - which disables it for any type lookup
             for <see cref="T:System.Action`1"/>) or for a specific closed version of that generic
             (e.g. <c>Action&lt;Foo, Bar&gt;</c>).</remarks>
             <seealso cref="T:Rezolver.Options.EnableGlobalOptions"/>
        </member>
        <member name="F:Rezolver.Options.EnableContravariance.Default">
            <summary>
            Default value for this option - equivalent to <c>true</c>
            </summary>
        </member>
        <member name="M:Rezolver.Options.EnableContravariance.op_Implicit(System.Boolean)~Rezolver.Options.EnableContravariance">
            <summary>
            Implicit conversion operator from <see cref="T:System.Boolean"/> to <see cref="T:Rezolver.Options.EnableContravariance"/> -
            simplifies getting and setting this option.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rezolver.Options.EnableEnumerableCovariance">
            <summary>
            Option that controls whether or not auto-injected enumerables - either globally, or for a
            given type - will perform covariant searches when locating targets to be included in the
            enumerable. The <see cref="P:Rezolver.Options.EnableEnumerableCovariance.Default"/> is equivalent to <c>true</c>.
            </summary>
        </member>
        <member name="P:Rezolver.Options.EnableEnumerableCovariance.Default">
            <summary>
            The default value for this option - equivalent to <c>true</c>
            </summary>
        </member>
        <member name="M:Rezolver.Options.EnableEnumerableCovariance.op_Implicit(System.Boolean)~Rezolver.Options.EnableEnumerableCovariance">
            <summary>
            Convenience convserion operator from <see cref="T:System.Boolean"/> to <see cref="T:Rezolver.Options.EnableEnumerableCovariance"/>
            </summary>
            <param name="value">The boolean value to wrapped in a new instance of <see cref="T:Rezolver.Options.EnableEnumerableCovariance"/></param>
        </member>
        <member name="T:Rezolver.Options.EnableEnumerableInjection">
            <summary>
            Controls whether the <see cref="P:Rezolver.Container.DefaultConfig"/> will enable automatically injected enumerables
            or not.
            </summary>
        </member>
        <member name="P:Rezolver.Options.EnableEnumerableInjection.Default">
            <summary>
            The default value for this option - equivalent to <c>true</c>
            </summary>
        </member>
        <member name="M:Rezolver.Options.EnableEnumerableInjection.op_Implicit(System.Boolean)~Rezolver.Options.EnableEnumerableInjection">
            <summary>
            Convenience operator for creating an instance of this option from a <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rezolver.Options.EnableGlobalOptions">
            <summary>
            A <see cref="T:System.Boolean"/> container option which controls whether per-service options will fall back to
            a global option if not explicitly set.  The <see cref="P:Rezolver.Options.EnableGlobalOptions.Default"/> (unconfigured) is <c>true</c>.
            </summary>
        </member>
        <member name="P:Rezolver.Options.EnableGlobalOptions.Default">
             <summary>
             The default value for this option if not configured.
            
             Equivalent to <c>true</c>.
             </summary>
        </member>
        <member name="M:Rezolver.Options.EnableGlobalOptions.op_Implicit(System.Boolean)~Rezolver.Options.EnableGlobalOptions">
            <summary>
            Implicit casting operator from <see cref="T:System.Boolean"/> which simplifies setting this option with
            a simple <c>true</c> or <c>false</c>.
            </summary>
            <param name="value">The boolean value to be stored in the returned instance.</param>
        </member>
        <member name="T:Rezolver.Options.EnableListInjection">
             <summary>
             Boolean option which, if configured before the <see cref="T:Rezolver.Configuration.InjectLists"/> configuration is applied,
             will control whether automatic injection of <see cref="T:System.Collections.Generic.List`1"/> (and related interfaces - see the documentation
             on that type for more) will be enabled.
             The <see cref="P:Rezolver.Options.EnableListInjection.Default"/> is equivalent to <c>true</c>.
             </summary>
             <remarks>
             The injection behaviour controlled by this option most commonly piggybacks off of the behaviour that's enabled by the
             <see cref="T:Rezolver.Configuration.InjectEnumerables"/> configuration.
            
             However, although this option is therefore related to the <see cref="T:Rezolver.Options.EnableEnumerableInjection"/> option, the two are independent.
            
             If you disable automatic enumerable injection, it does not automatically disable automatic list injection.</remarks>
             <seealso cref="T:Rezolver.Configuration.InjectLists"/>
             <seealso cref="T:Rezolver.Options.EnableEnumerableInjection"/>
             <seealso cref="T:Rezolver.Configuration.InjectEnumerables"/>
        </member>
        <member name="P:Rezolver.Options.EnableListInjection.Default">
            <summary>
            Default value for this option, equivalent to <c>true</c>
            </summary>
        </member>
        <member name="M:Rezolver.Options.EnableListInjection.op_Implicit(System.Boolean)~Rezolver.Options.EnableListInjection">
            <summary>
            Convenience operator for creating an instance of this option from a boolean.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rezolver.Options.FetchAllMatchingGenerics">
             <summary>
             A boolean option for target containers that controls which registrations will be returned
             when <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)"/> is called with a closed generic type, when using the
             built in target containers.
            
             This ultimately affects the objects that are materialised in automatically generated enumerables
             (when the <see cref="T:Rezolver.Configuration.InjectEnumerables"/> is enabled - which it is, by default)
             when the element type is itself a generic type.
             </summary>
             <remarks>This option is primarily used to control the <see cref="T:Rezolver.GenericTargetContainer"/>
             and the targets it returns from its implementation of <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)"/>
             where the input type is a closed generic.
            
             When <c>true</c> (the <see cref="P:Rezolver.Options.FetchAllMatchingGenerics.Default"/>), all targets which match **both** the closed generic
             ***and*** which have been registered for all applicable open generics will be returned.
            
             When <c>false</c> then the function will return only the first matching group of targets sharing
             a common matching type.  So, if there are five registered against the open generic, and one against
             the closed generic; then the one will 'beat' the five.</remarks>
        </member>
        <member name="P:Rezolver.Options.FetchAllMatchingGenerics.Default">
            <summary>
            The default value for the <see cref="T:Rezolver.Options.FetchAllMatchingGenerics"/> option - equivalent to <c>true</c>.
            </summary>
        </member>
        <member name="M:Rezolver.Options.FetchAllMatchingGenerics.op_Implicit(System.Boolean)~Rezolver.Options.FetchAllMatchingGenerics">
            <summary>
            Implicit conversion operator to <see cref="T:Rezolver.Options.FetchAllMatchingGenerics"/> from <see cref="T:System.Boolean"/> to simplify
            reading and writing the option as a boolean.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rezolver.Options.IOptionForAnyGeneric">
             <summary>
             Used as a marker service type for GetOption when a service type is any generic.
            
             Allows options to be defined for any generic type instead of specific generics.
             </summary>
        </member>
        <member name="T:Rezolver.Options.LazyEnumerables">
             <summary>
             Controls whether the enumerables which are automatically generated by the container, when the <see cref="T:Rezolver.Configuration.InjectEnumerables"/> configuration
             is used and enabled, are evaluated lazily or eagerly.
             </summary>
             <remarks>
             A lazily evaluated enumerable will generate new instances (if not otherwise controlled by singleton/scoped lifetimes) every time it is enumerated.
            
             Eagerly evaluted enumerables do not.</remarks>
        </member>
        <member name="P:Rezolver.Options.LazyEnumerables.Default">
            <summary>
            The default value for this option - equivalent to <c>true</c>
            </summary>
        </member>
        <member name="M:Rezolver.Options.LazyEnumerables.op_Implicit(System.Boolean)~Rezolver.Options.LazyEnumerables">
            <summary>
            Convenience casting operator from <see cref="T:System.Boolean"/> to <see cref="T:Rezolver.Options.LazyEnumerables"/> to simplify
            integration of the option type into logic statements.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rezolver.OverridingContainer">
            <summary>
            A child container which extends another.
            
            Note that this container gets its own singletons, scope, etc - everything is new; it's just the registrations
            which are shared.
            </summary>
        </member>
        <member name="P:Rezolver.OverridingContainer.Inner">
            <summary>
            Gets the <see cref="T:Rezolver.Container"/> that is overriden by this container.
            </summary>
        </member>
        <member name="M:Rezolver.OverridingContainer.#ctor(Rezolver.Container,Rezolver.IContainerConfig)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.OverridingContainer"/>
            </summary>
            <param name="inner">Required.  The inner container that this one combines with.  Any dependencies not served
            by the new combined container's own targets will be sought from this container.  Equally, any targets in the base which
            are resolved when the overriding container is the root container for a resolve operation, will resolve
            their dependencies from this container.</param>
            <param name="config">Can be null.  A configuration to apply to this container (and, potentially its
            <see cref="N:Rezolver.Targets"/>).  If not provided, then the <see cref="P:Rezolver.Container.DefaultConfig"/> will be used</param>
        </member>
        <member name="T:Rezolver.OverridingTargetContainer">
             <summary>
             A version of <see cref="T:Rezolver.TargetContainer" /> which overrides and extends the registrations of another
             (the <see cref="P:Rezolver.OverridingTargetContainer.Parent" />).
             </summary>
             <seealso cref="T:Rezolver.TargetContainer" />
             <remarks>When this class searches for an entry for a type, if it
             cannot find one within its own registrations, it falls back to the registrations of
             its ancestors (starting with its <see cref="P:Rezolver.OverridingTargetContainer.Parent" />).
            
             As a result, any dependencies required by registrations in this container can be provided by
             any ancestor.
            
             This fallback logic in the <see cref="M:Rezolver.OverridingTargetContainer.Fetch(System.Type)" /> is triggered by the
             <see cref="P:Rezolver.ITarget.UseFallback" /> property.
            
             The <see cref="M:Rezolver.OverridingTargetContainer.FetchAll(System.Type)"/> method, however, returns all targets registered directly in this
             container and in the parent.</remarks>
        </member>
        <member name="P:Rezolver.OverridingTargetContainer.Parent">
            <summary>
            Gets the parent target container.
            </summary>
            <value>The parent.</value>
        </member>
        <member name="P:Rezolver.OverridingTargetContainer.Root">
            <summary>
            Overrides the base implementation so that the root is derived from the <see cref="P:Rezolver.OverridingTargetContainer.Parent"/>.
            </summary>
        </member>
        <member name="M:Rezolver.OverridingTargetContainer.#ctor(Rezolver.ITargetContainer,Rezolver.ITargetContainerConfig)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.OverridingTargetContainer"/> class.
            </summary>
            <param name="parent">Required. The parent target container.</param>
            <param name="config">Optional.  The configuration to apply to this target container.  If null, then
            the <see cref="P:Rezolver.TargetContainer.DefaultConfig"/> is used.
            </param>
        </member>
        <member name="M:Rezolver.OverridingTargetContainer.Fetch(System.Type)">
            <summary>
            Fetches the registered target for the given <paramref name="type"/>, if found, or
            forwards the call to the <see cref="P:Rezolver.OverridingTargetContainer.Parent"/> container.
            </summary>
            <param name="type">The type whose registration is sought.</param>
            <returns>The target which is registered for the given type, or null if no registration
            can be found.
            </returns>
        </member>
        <member name="M:Rezolver.OverridingTargetContainer.FetchAll(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)" /> which returns
            an enumerable of targets from both the base target container and this target container.
            </summary>
            <param name="type">The type whose targets are to be retrieved.</param>
            <returns>A non-null enumerable containing the targets that match the type, or an
            empty enumerable if the type is not registered.</returns>
        </member>
        <member name="M:Rezolver.OverridingTargetContainer.OnTargetRegistered(Rezolver.ITarget,System.Type)">
            <summary>
            Overrides the base method to record that registrations have been added, and that 
            the <see cref="M:Rezolver.OverridingTargetContainer.Fetch(System.Type)"/> and <see cref="M:Rezolver.OverridingTargetContainer.FetchAll(System.Type)"/> methods should
            combine results from both this and the <see cref="P:Rezolver.OverridingTargetContainer.Parent"/> target container.
            </summary>
            <param name="target">The target that was registered</param>
            <param name="serviceType">The type against which the <paramref name="target"/>
            was registered</param>
        </member>
        <member name="M:Rezolver.OverridingTargetContainer.OnTargetContainerRegistered(Rezolver.ITargetContainer,System.Type)">
            <summary>
            Overrides the base method to record that a target container has been registered.
            </summary>
            <param name="container">The target container that was registered</param>
            <param name="type">The type against which the target container was registered.</param>
        </member>
        <member name="T:Rezolver.ParameterBinding">
            <summary>
            Represents a binding between a method parameter and an <see cref="T:Rezolver.ITarget"/>
            </summary>
        </member>
        <member name="F:Rezolver.ParameterBinding.None">
            <summary>
            Represents an empty parameter bindings array.
            </summary>
        </member>
        <member name="P:Rezolver.ParameterBinding.Parameter">
            <summary>
            The parameter to be bound
            </summary>
        </member>
        <member name="P:Rezolver.ParameterBinding.Target">
            <summary>
            The initial target that was bound to this parameter.
            </summary>
        </member>
        <member name="P:Rezolver.ParameterBinding.IsValid">
             <summary>
             Gets a boolean indicating whether the parameter binding is valid
            
             Ultimately, this returns true if <see cref="P:Rezolver.ParameterBinding.Target"/> is non-null.
             </summary>
        </member>
        <member name="M:Rezolver.ParameterBinding.#ctor(System.Reflection.ParameterInfo,Rezolver.ITarget)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.ParameterBinding"/> class.
            </summary>
            <param name="parameter">Required - the parameter being bound</param>
            <param name="target">Optional - the argument supplied for the parameter.</param>
        </member>
        <member name="M:Rezolver.ParameterBinding.Resolve(Rezolver.Compilation.ICompileContext)">
             <summary>
             Fetch the target that would be bound to this parameter given the passed <see cref="T:Rezolver.Compilation.ICompileContext"/>
             </summary>
             <param name="context">The current compile context - a new one is created for the <see cref="P:Rezolver.ParameterBinding.Parameter"/> type</param>
             <returns>The target that should be used for the parameter, or null if no target could be found.
            
             Note that if the returned target's <see cref="P:Rezolver.ITarget.UseFallback"/> property is set to <c>true</c>,
             then it means either the parameter's default value is being used, or that the target fetched from the
             target container in the context is a stub (e.g. empty enumerable)</returns>
             <remarks>During compilation - you should not use the target returned by this function as a direct
             part of your expression tree - you should </remarks>
        </member>
        <member name="M:Rezolver.ParameterBinding.BindWithRezolvedArguments(System.Reflection.MethodBase)">
             <summary>
             Creates parameter bindings for each parameter in the passed method where each value will be resolved.
            
             For any optional parameters - their default values will be used as a fallback if the <see cref="T:Rezolver.Targets.ResolvedTarget"/>
             cannot either resolve a target at compile time or from the <see cref="T:Rezolver.Container"/> at resolve-time.
             </summary>
             <param name="method"></param>
             <returns></returns>
        </member>
        <member name="M:Rezolver.ParameterBinding.BindOverload(System.Reflection.MethodBase[],System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget},System.Reflection.MethodBase@)">
             <summary>
             Searches for a method in the <paramref name="methods"/> collection whose parameters can be filled by the targets provided in the <paramref name="args"/>
             dictionary, returning the parameter bindings, and passing out the resolved target method in <paramref name="resolvedMethod"/> if found.
            
             Note - if no match can be found, or if more than one method could be bound, then an InvalidOperationException will occur.
             </summary>
             <param name="methods">The methods.</param>
             <param name="args">The arguments.</param>
             <param name="resolvedMethod">The resolved method.</param>
             <returns>ParameterBinding[].</returns>
        </member>
        <member name="M:Rezolver.ParameterBinding.BindMethod(System.Reflection.MethodBase,System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget})">
            <summary>
            Matches named targets in <paramref name="args"/> to parameters on the passed <paramref name="method"/>,
            creating default <see cref="T:Rezolver.ParameterBinding"/>s (which will be resolved from the compile or run-time container),
            for any parameters for which named targets cannot be found.
            </summary>
            <param name="method"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.ParameterBinding.BindMethod(System.Reflection.MethodBase,Rezolver.ParameterBinding[])">
            <summary>
            Binds the method using explicit bindings for each parameter supplied in the <paramref name="suppliedBindings"/> array,
            or defaults (which will be resolved from the compile or run-time container) if not present.
            </summary>
            <param name="method">The method to be bound</param>
            <param name="suppliedBindings">Optional.  The supplied bindings for the parameters of the method.  Any parameters
            not matched from this array will be automatically bound with default (resolved from the container).</param>
        </member>
        <member name="T:Rezolver.ProjectionTargetContainer">
             <summary>
             Implements projections of IEnumerables from one type to another
            
             Effectively, this daisy chains one enumerable into another via something
             similar to a Linq Select.
             </summary>
        </member>
        <member name="P:Rezolver.ProjectionTargetContainer.Root">
            <summary>
            The ultimate root target container to which this target container belongs.
            </summary>
        </member>
        <member name="P:Rezolver.ProjectionTargetContainer.SourceElementType">
            <summary>
            Element type of the <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements will be projected into a
            new enumerable type.  Note - this is always equal to the type argument that's present in the
            <see cref="P:Rezolver.ProjectionTargetContainer.SourceEnumerableType"/>.
            </summary>
        </member>
        <member name="P:Rezolver.ProjectionTargetContainer.OutputElementType">
            <summary>
            Element type of the <see cref="T:System.Collections.Generic.IEnumerable`1"/> that is to be projected from the source
            enumerable.
            </summary>
        </member>
        <member name="P:Rezolver.ProjectionTargetContainer.SourceEnumerableType">
             <summary>
             The concrete type of the <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance that will feed the projection
             to an instance of the <see cref="P:Rezolver.ProjectionTargetContainer.OutputEnumerableType"/>.
            
             The single type argument is available through the <see cref="P:Rezolver.ProjectionTargetContainer.SourceElementType"/> property.
             </summary>
        </member>
        <member name="P:Rezolver.ProjectionTargetContainer.OutputEnumerableType">
             <summary>
             The concrete type of the <see cref="T:System.Collections.Generic.IEnumerable`1"/> that's projected from the source enumerable.
            
             The single type argument is available through the <see cref="P:Rezolver.ProjectionTargetContainer.OutputElementType"/> property.
             </summary>
        </member>
        <member name="M:Rezolver.ProjectionTargetContainer.Fetch(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainer.Fetch(System.Type)"/> - always produces an <see cref="T:Rezolver.Targets.EnumerableTarget"/>
            which, when compiled, will produce an enumerable of <see cref="P:Rezolver.ProjectionTargetContainer.OutputEnumerableType"/>.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.ProjectionTargetContainer.Register(Rezolver.ITarget,System.Type)">
            <summary>
            Not supported
            </summary>
            <param name="target"></param>
            <param name="serviceType"></param>
        </member>
        <member name="M:Rezolver.ProjectionTargetContainer.FetchAll(System.Type)">
            <summary>
            Not supported
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.ProjectionTargetContainer.CombineWith(Rezolver.ITargetContainer,System.Type)">
            <summary>
            Not supported
            </summary>
            <param name="existing"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.ProjectionTargetContainer.FetchContainer(System.Type)">
            <summary>
            Not supported
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.ProjectionTargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)">
            <summary>
            Not supported
            </summary>
            <param name="type"></param>
            <param name="container"></param>
        </member>
        <member name="T:Rezolver.ResolveContext">
            <summary>
            Captures the context of a resolve operation.  Publicly, only the <see cref="P:Rezolver.ResolveContext.RequestedType"/>
            is captured; however, internally, it captures both the original <see cref="T:Rezolver.Container"/>
            and <see cref="T:Rezolver.ContainerScope"/>.
            </summary>
            <remarks>Every resolve operation that your code produces (and many internally generated ones) rely
            on this type.  The code generated by the expression compiler will also reference the current context,
            particularly to ensure that the correct scope is used for tracking instances for the current operation.
            
            When <see cref="T:Rezolver.Configuration.InjectResolveContext"/> is enabled (which it is by default in the 
            <see cref="P:Rezolver.TargetContainer.DefaultConfig"/>) this type then also becomes available for 
            injection so that your code can perform further resolve operations should it need to.
            </remarks>
        </member>
        <member name="P:Rezolver.ResolveContext.RequestedType">
            <summary>
            Gets the type being requested from the container.
            </summary>
        </member>
        <member name="M:Rezolver.ResolveContext.#ctor(Rezolver.Container,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.ResolveContext"/> class.
            </summary>
            <param name="container">The container.</param>
            <param name="requestedType">The type of object to be resolved from the container.</param>
        </member>
        <member name="M:Rezolver.ResolveContext.#ctor(Rezolver.ContainerScope,System.Type)">
             <summary>
             Initializes a new instance of the <see cref="T:Rezolver.ResolveContext"/> class from the given scope.
            
             The <see cref="P:Rezolver.ResolveContext.Container"/> is inherited from the scope's <see cref="P:Rezolver.ContainerScope.Container"/>.
             </summary>
             <param name="scope">The scope.</param>
             <param name="requestedType">The of object to be resolved from the container.</param>
        </member>
        <member name="M:Rezolver.ResolveContext.Resolve``1">
            <summary>
            Resolves a new instance of a different type from the same scope and container as this context.
            </summary>
            <typeparam name="TService">Type of service to be resolved.</typeparam>
        </member>
        <member name="M:Rezolver.ResolveContext.Resolve``1(Rezolver.Container)">
            <summary>
            Resolves a new instance of a different type from the passed <paramref name="newContainer"/>, 
            fixing the scope to be the one from this context.
            </summary>
            <typeparam name="TService">Type of service to be resolved.</typeparam>
            <param name="newContainer">The container from which the service is to be resolved - note,
            even if this has its own scope, the scope which is captured by this context will be used.</param>
        </member>
        <member name="M:Rezolver.ResolveContext.Resolve(System.Type)">
            <summary>
            Resolves a new instance of a different type from the same scope and container as this context.
            </summary>
            <param name="serviceType">Type of service to be resolved.</param>
        </member>
        <member name="M:Rezolver.ResolveContext.Resolve(System.Type,Rezolver.Container)">
            <summary>
            Resolves a new instance of a different type from the passed <paramref name="newContainer"/>, 
            fixing the scope to be the one from this context.
            </summary>
            <param name="serviceType">Type of service to be resolved.</param>
            <param name="newContainer">The container from which the service is to be resolved - note,
            even if this has its own scope, the scope which is captured by this context will be used.</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.ResolveContext.ResolveMany(System.Type)">
            <summary>
            Resolves an enumerable of <paramref name="serviceType"/> from the current container.
            </summary>
            <param name="serviceType">The type of services required.</param>
        </member>
        <member name="M:Rezolver.ResolveContext.ResolveMany``1">
            <summary>
            Resolves an enumerable of <typeparamref name="TService"/> from the current container.
            </summary>
            <typeparam name="TService">Type of services required.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Rezolver.ResolveContext.ChangeRequestedType(System.Type)">
            <summary>
            Creates a new <see cref="T:Rezolver.ResolveContext"/> with the same container/scope, but with a new
            <see cref="P:Rezolver.ResolveContext.RequestedType"/>
            </summary>
            <param name="serviceType">The new service type</param>
        </member>
        <member name="M:Rezolver.ResolveContext.ChangeContainer(Rezolver.Container)">
            <summary>
            Creates a new context with the same <see cref="P:Rezolver.ResolveContext.RequestedType"/> but switches to a new container,
            but keeping the current scope.
            </summary>
            <param name="newContainer">The container from which the service is to be resolved - note,
            even if this has its own scope, the scope which is captured by this context will be used.</param>
        </member>
        <member name="M:Rezolver.ResolveContext.CreateScope">
            <summary>
            Creates a new scope
            </summary>
        </member>
        <member name="M:Rezolver.ResolveContext.GetHashCode">
            <summary>
            Implements the <see cref="M:System.Object.GetHashCode"/> method using the hash code of
            the <see cref="P:Rezolver.ResolveContext.RequestedType"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rezolver.ResolveContext.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
        </member>
        <member name="T:Rezolver.RootTargetContainerExtensions">
            <summary>
            Extensions for the <see cref="T:Rezolver.IRootTargetContainer"/> interface
            </summary>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``1(Rezolver.IRootTargetContainer)">
            <summary>Enables the automatic injection of a <see cref="T:System.Func`1" /> for the given <typeparamref name="TResult" /></summary>
            <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
            <remarks>
            Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
            it is resolved.
            
            This methods ensures that enumerables of the delegate type are also injectable.
            </remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``2(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`2" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``3(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`3" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``4(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`4" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``5(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`5" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``6(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`6" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``7(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`7" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``8(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`8" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``9(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`9" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T8">Type of the 8th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``10(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`10" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T8">Type of the 8th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T9">Type of the 9th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``11(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`11" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T8">Type of the 8th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T9">Type of the 9th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T10">Type of the 10th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``12(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`12" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T8">Type of the 8th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T9">Type of the 9th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T10">Type of the 10th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T11">Type of the 11th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``13(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`13" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T8">Type of the 8th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T9">Type of the 9th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T10">Type of the 10th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T11">Type of the 11th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T12">Type of the 12th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``14(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`14" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T8">Type of the 8th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T9">Type of the 9th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T10">Type of the 10th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T11">Type of the 11th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T12">Type of the 12th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T13">Type of the 13th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``15(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`15" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T8">Type of the 8th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T9">Type of the 9th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T10">Type of the 10th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T11">Type of the 11th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T12">Type of the 12th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T13">Type of the 13th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T14">Type of the 14th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``16(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`16" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T8">Type of the 8th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T9">Type of the 9th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T10">Type of the 10th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T11">Type of the 11th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T12">Type of the 12th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T13">Type of the 13th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T14">Type of the 14th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T15">Type of the 15th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFunc``17(Rezolver.IRootTargetContainer)">
             <summary>Enables the automatic injection of a <see cref="T:System.Func`17" /> auto-factory for the given 
             <typeparamref name="TResult" /> where one or more dependencies which would usually be resolved from the container 
             will instead be supplied by the code which calls the delegate.</summary>
             <typeparam name="T1">Type of the 1st parameter of the delegate.</typeparam>
             <typeparam name="T2">Type of the 2nd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T3">Type of the 3rd parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T4">Type of the 4th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T5">Type of the 5th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T6">Type of the 6th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T7">Type of the 7th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T8">Type of the 8th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T9">Type of the 9th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T10">Type of the 10th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T11">Type of the 11th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T12">Type of the 12th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T13">Type of the 13th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T14">Type of the 14th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T15">Type of the 15th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="T16">Type of the 16th parameter of the delegate.  This must not be the same type as any other parameter types.</typeparam>
             <typeparam name="TResult">The return type of the delegate - equivalent to the service type that is to be resolved from the container when the delegate is called.</typeparam>
             <param name="targets">Required.  The <see cref="T:Rezolver.IRootTargetContainer" /> into which the newly created target will be registered</param>
             <remarks>A parameterised auto-factory provides a way both to hide the container from application code, but also 
             to allow dependencies to be supplied to the requested service instead of relying on the container to have registrations
             for it.
            
             Note that scoping is honoured for the delegate call; with an injected auto-factory being bound to the scope from which
             it is resolved.
             
             This methods ensures that enumerables of the delegate type are also injectable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFactory``1(Rezolver.IRootTargetContainer)">
            <summary>
            Registers an <see cref="T:Rezolver.Targets.AutoFactoryTarget"/> for the given delegate type <typeparamref name="TDelegate"/>, enabling 
            the container to automatically build and inject a delegate which uses the container to produce a result.
            
            This method and its overload can be used for any delegate type.
            </summary>
            <typeparam name="TDelegate">The type of delegate to be injected. Must have a non-void return type
            and all its parameters must be of distinct types.</typeparam>
            <param name="targets">Required. The target container in which the registration is to be made.</param>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterAutoFactory(Rezolver.IRootTargetContainer,System.Type)">
            <summary>
            Registers an <see cref="T:Rezolver.Targets.AutoFactoryTarget"/> for the given <paramref name="delegateType"/>, enabling 
            the container to automatically build and inject a delegate which uses the container to produce a result.
            
            This method and its overload can be used for any delegate type.
            </summary>
            <param name="targets">Required. The target container in which the registration is to be made.</param>
            <param name="delegateType">Required. Must have a non-void return type and all its parameters must be of distinct types.</param>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.CreateTargetContainerForServiceType(Rezolver.IRootTargetContainer,System.Type)">
            <summary>
            Calls <see cref="M:Rezolver.IRootTargetContainer.GetContainerRegistrationType(System.Type)"/> to get the correct registration type for the target container 
            that should own a target that will be registered against the given <paramref name="serviceType"/>.  Once obtained, that type is then
            passed to the <see cref="M:Rezolver.IRootTargetContainer.CreateTargetContainer(System.Type)"/> to create the correct <see cref="T:Rezolver.ITargetContainer"/> for
            that container registration type.
            
            This is typically used by 'advanced' target containers which wrap others under potentially any type and which therefore need to reuse
            the root container's logic for ensuring that registrations are handled correctly.
            </summary>
            <param name="rootContainer"></param>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterDecorator``2(Rezolver.IRootTargetContainer)">
             <summary>
             Registers a decorator container which will cause all instances of <typeparamref name="TDecorated"/> to be decorated with
             the type <typeparamref name="TDecorator"/>.
            
             Any existing registrations for <typeparamref name="TDecorated"/> will be decorated correctly, and subsequent registrations
             of <typeparamref name="TDecorated"/> will also be decorated as expected.
             </summary>
             <typeparam name="TDecorator">The type to be used as the decorator implementation</typeparam>
             <typeparam name="TDecorated">The type which will be decorated by <typeparamref name="TDecorator"/>.</typeparam>
             <param name="targetContainer">The container into which the decorator will be registered.</param>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterDecorator``1(Rezolver.IRootTargetContainer,System.Func{``0,``0})">
             <summary>
             Registers a decorator container which will cause all instances of the type <typeparamref name="TDecorated"/> produced by the
             container to be intercepted and replaced by the result of calling the passed <paramref name="decoratorDelegate"/> with the
             original instance.
             </summary>
             <typeparam name="TDecorated">The type of object whose creation is being decorated by the delegate.</typeparam>
             <param name="targetContainer">The container into which the decorator will be registered.</param>
             <param name="decoratorDelegate">The delegate to be executed every time an instance of <typeparamref name="TDecorated"/>
             is produced by the container, and whose result will be used in place of the original object (which is fed into the delegate).</param>
             <remarks>
             Whilst this overload uses the term 'Decorator' in its name, it is of course entirely possible that the delegate won't actually
             create a decorating instance for the input object.
            
             As a result, it's better to think of this as decorating Rezolver's own process of getting an object, which may or may not result in
             a decorated instance - depending on what the delegate actually does.
            
             What this *does* allow, however, is decorating objects which otherwise can't be decorated by constructor injection - e.g. Arrays,
             delegate types, primitive objects (e.g. <see cref="T:System.Int32"/>) and so on.
             </remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterDecorator``1(Rezolver.IRootTargetContainer,System.Delegate)">
             <summary>
             Registers a decorator container which will cause all instances of the type <typeparamref name="TDecorated"/> produced by the
             container to be intercepted and replaced by the result of calling the passed <paramref name="decoratorDelegate"/> with the
             original instance.
             </summary>
             <typeparam name="TDecorated">The type of object whose creation is being decorated by the delegate.</typeparam>
             <param name="targetContainer">The container into which the decorator will be registered.</param>
             <param name="decoratorDelegate">The delegate to be executed every time an instance of <typeparamref name="TDecorated"/>
             is produced by the container, and whose result will be used in place of the original object (which is fed into the delegate).</param>
             <remarks>
             Whilst this overload uses the term 'Decorator' in its name, it is of course entirely possible that the delegate won't actually
             create a decorating instance for the input object.
            
             As a result, it's better to think of this as decorating Rezolver's own process of getting an object, which may or may not result in
             a decorated instance - depending on what the delegate actually does.
            
             What this *does* allow, however, is decorating objects which otherwise can't be decorated by constructor injection - e.g. Arrays,
             delegate types, primitive objects (e.g. <see cref="T:System.Int32"/>) and so on.
             </remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterDecorator(Rezolver.IRootTargetContainer,System.Delegate,System.Type)">
             <summary>
             Registers a delegate to be executed every time an instance of <paramref name="decoratedType"/> is produced by the container.
            
             This is ultimately the same as the <see cref="M:Rezolver.RootTargetContainerExtensions.RegisterDecorator``1(Rezolver.IRootTargetContainer,System.Func{``0,``0})"/> method
             except this allows you to pass delegates with more parameters than the one that that overload provides.
            
             The delegate's return type must be equal to <paramref name="decoratedType"/>
             </summary>
             <param name="targetContainer">The container into which the decorator will be registered.</param>
             <param name="decoratorDelegate">The delegate to be executed every time an instance of <paramref name="decoratedType"/>
             is produced by the container, and whose result will be used in place of the original object (which is fed into the delegate).</param>
             <param name="decoratedType">The type of object whose creation is being decorated by the delegate.</param>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterDecorator(Rezolver.IRootTargetContainer,System.Type,System.Type)">
             <summary>
             Registers a decorator container which will cause all instances of <paramref name="decoratedType" /> to be decorated with
             the type <paramref name="decoratorType" />.
            
             Any existing registrations for <paramref name="decoratedType" /> will be decorated correctly, and subsequent registrations
             of <paramref name="decoratedType" /> will also be decorated as expected.
             </summary>
             <param name="targetContainer">The container into which the decorator will be registered.</param>
             <param name="decoratorType">The type to be used as the decorator implementation</param>
             <param name="decoratedType">The type which will be decorated by <paramref name="decoratorType" />.</param>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.FetchAllCompatibleTargets(Rezolver.IRootTargetContainer,System.Type)">
            <summary>
            Fetches all targets from the <paramref name="rootContainer"/> registered against service types which are
            either equal to or compatible with the given <paramref name="serviceType"/>.  
            </summary>
            <param name="rootContainer">The root target container whose targets are to be searched</param>
            <param name="serviceType">The service type for which targets are sought.</param>
            <returns>An enumerable of targets which match the <paramref name="serviceType"/>.
            If no targets match, then the enumerable will be empty.</returns>
            <remarks>
            This is effectively a covariant version of the <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)"/> function,
            and is used by built-in functionality such as automatic enumerable injection (when <see cref="T:Rezolver.Options.EnableEnumerableCovariance"/>
            is <c>true</c>) and automatic factory injection <see cref="T:System.Func`1"/>.
            
            Note: the targets are de-duped before being returned, so if one target is registered multiple times against different
            compatible service types, it will still only appear once in the output enumerable.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterProjection``2(Rezolver.IRootTargetContainer)">
             <summary>
             Registers an enumerable projection that will create an enumerable of type <typeparamref name="TTo"/>
             from elements of an input enumerable of type <typeparamref name="TFrom"/> using constructor injection
             to create each instance of <typeparamref name="TTo"/>.
            
             The same as calling <see cref="M:Rezolver.RootTargetContainerExtensions.RegisterProjection(Rezolver.IRootTargetContainer,System.Type,System.Type,System.Type)"/> with
             <typeparamref name="TTo"/> used as the argument to both `TTo` and `TImplementation` type parameters.
             </summary>
             <typeparam name="TFrom">The type of the enumerable that provides the source of the projection</typeparam>
             <typeparam name="TTo">The type of the enumerable that will be the output of the projection</typeparam>
             <param name="targets"></param>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterProjection``3(Rezolver.IRootTargetContainer)">
             <summary>
             Registers an enumerable projection that will create an enumerable of type <typeparamref name="TTo"/>
             from elements of an input enumerable of type <typeparamref name="TFrom"/> using constructor injection
             to create each instance of <typeparamref name="TImplementation"/>.
             </summary>
             <typeparam name="TFrom">The type of the enumerable that provides the source of the projection</typeparam>
             <typeparam name="TTo">The type of the enumerable that will be the output of the projection</typeparam>
             <typeparam name="TImplementation">The type to be created for each element.</typeparam>
             <param name="targets"></param>
             <remarks>
             This is like hot-wiring the Linq <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
             directly into the container.
            
             Typically each instance of the implementation type <typeparamref name="TImplementation"/> will require an
             instance of type <typeparamref name="TFrom"/> to be passed into its constructor - the framework
             takes care of passing the individual elements in for each instance of <typeparamref name="TImplementation"/>
             that it creates.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterProjection``2(Rezolver.IRootTargetContainer,System.Func{Rezolver.IRootTargetContainer,Rezolver.ITarget,System.Type})">
            <summary>
            Registers an enumerable projection that create an enumerable of type <typeparamref name="TTo"/>
            from elements of an input enumerable of type <typeparamref name="TFrom"/> with the type of each
            projected element is determined by the result of the <paramref name="implementationTypeSelector"/>
            callback for each input target.  The type returned by this callback must be able to be created via
            automatic constructor injection.
            </summary>
            <typeparam name="TFrom">The type of the enumerable that provides the source of the projection</typeparam>
            <typeparam name="TTo">The type of the enumerable that will be the output of the projection</typeparam>
            <param name="targets"></param>
            <param name="implementationTypeSelector">A callback to be invoked for each target in the input enumerable which
            provides the type that is to be created for the corresponding element in the output enumerable.</param>
            <remarks>This overload is useful for creating specialised generics which share the <typeparamref name="TTo"/> type
            as a base or interface.</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterProjection(Rezolver.IRootTargetContainer,System.Type,System.Type)">
            <summary>
            Non-generic version of <see cref="M:Rezolver.RootTargetContainerExtensions.RegisterProjection``2(Rezolver.IRootTargetContainer)"/>
            </summary>
            <param name="targets"></param>
            <param name="fromType">The type of the enumerable that provides the source of the projection</param>
            <param name="toType">The type of the enumerable that will be the output of the projection - this type
            must be able to be created via automatic constructor injection.</param>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterProjection(Rezolver.IRootTargetContainer,System.Type,System.Type,System.Type)">
            <summary>
            Non-generic version of <see cref="M:Rezolver.RootTargetContainerExtensions.RegisterProjection``3(Rezolver.IRootTargetContainer)"/>
            </summary>
            <param name="targets"></param>
            <param name="fromType">The type of the enumerable that provides the source of the projection.</param>
            <param name="toType">The type of the enumerable produced by the projection.</param>
            <param name="implementationType">The type to be created for each element in the output enumerable.  Must be able to
            be created via automatic constructor injection.</param>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterProjection(Rezolver.IRootTargetContainer,System.Type,System.Type,System.Func{Rezolver.IRootTargetContainer,Rezolver.ITarget,System.Type})">
            <summary>
            Non-generic version of <see cref="M:Rezolver.RootTargetContainerExtensions.RegisterProjection``2(Rezolver.IRootTargetContainer,System.Func{Rezolver.IRootTargetContainer,Rezolver.ITarget,System.Type})"/>
            </summary>
            <param name="targets"></param>
            <param name="fromType">The type of the enumerable that provides the source of the projection.</param>
            <param name="toType">The type of the enumerable produced by the projection.</param>
            <param name="implementationTypeSelector">A callback to be invoked for each target in the input enumerable which
            provides the type that is to be created for the corresponding element in the output enumerable.</param>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterProjection``2(Rezolver.IRootTargetContainer,System.Func{Rezolver.IRootTargetContainer,Rezolver.ITarget,Rezolver.ITarget})">
            <summary>
            Registers an enumerable projection that will create an enumerable of type <typeparamref name="TTo"/>
            from elements of an input enumerable of type <typeparamref name="TFrom"/> using targets produced by the
            <paramref name="implementationTargetFactory"/> for each input element.
            </summary>
            <typeparam name="TFrom">The type of the enumerable that provides the source of the projection</typeparam>
            <typeparam name="TTo">The type of the enumerable that will be the output of the projection</typeparam>
            <param name="targets"></param>
            <param name="implementationTargetFactory">A factory callback that will be called once for each target in the
            input enumerable - the target returned by the factory will then be used to produce the projected element
            in the output enumerable.</param>
            <remarks>This overload is useful when output elements require more complex injection strategies other than just
            constructor injection; or perhaps where more advanced constructor injection is required (e.g. perhaps with member
            injection).</remarks>
        </member>
        <member name="M:Rezolver.RootTargetContainerExtensions.RegisterProjection(Rezolver.IRootTargetContainer,System.Type,System.Type,System.Func{Rezolver.IRootTargetContainer,Rezolver.ITarget,Rezolver.ITarget})">
            <summary>
            Non-generic version of <see cref="M:Rezolver.RootTargetContainerExtensions.RegisterProjection``2(Rezolver.IRootTargetContainer,System.Func{Rezolver.IRootTargetContainer,Rezolver.ITarget,Rezolver.ITarget})"/>
            </summary>
            <param name="targets"></param>
            <param name="fromType">The type of the enumerable that provides the source of the projection</param>
            <param name="toType">The type of the enumerable that will be the output of the projection</param>
            <param name="implementationTargetFactory">A factory callback that will be called once for each target in the
            input enumerable - the target returned by the factory will then be used to produce the projected element
            in the output enumerable.</param>
        </member>
        <member name="T:Rezolver.Runtime.ContravarianceAttribute">
            <summary>
            Internal hack to prevent stack overflows when the options API accessors recurse for other options lookups.
            </summary>
        </member>
        <member name="T:Rezolver.Runtime.DescendingTypeOrder">
            <summary>
            Generates a reasonable ordering of types where:
            Derived types are sorted before bases
            Interface implementations are sorted before the interfaces
            Fully-closed generics are sorted earlier than any containing generic parameters (or which are open).
            Generics are also sorted before non-generics.  It's not a general-purpose type sort: it's specifically
            useful for our TargetTypeSelector.
            </summary>
        </member>
        <member name="T:Rezolver.Runtime.EagerEnumerable`1">
             <summary>
             Direct implementation of <see cref="T:System.Collections.Generic.IEnumerable`1"/> for eagerly loaded enumerables when <see cref="T:Rezolver.Options.LazyEnumerables"/>
             has been disabled either globally, or for a specific enumerable's element type.
            
             Rezolver uses this type instead of an array to prevent casting and modifying the contents of the enumerable.
             </summary>
             <remarks>See the remarks section on <see cref="T:Rezolver.Runtime.LazyEnumerable`1"/> for more about lazy and eager enumerables.</remarks>
        </member>
        <member name="M:Rezolver.Runtime.EagerEnumerable`1.#ctor(`0[])">
            <summary>
            Constructs a new instance of <see cref="T:Rezolver.Runtime.EagerEnumerable`1"/>
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Rezolver.Runtime.EagerEnumerable`1.GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Runtime.EagerEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Runtime.GenericTypeMapping">
             <summary>
             Result returned from the <see cref="M:Rezolver.Targets.GenericConstructorTarget.MapType(System.Type)"/> function.  Represents various levels of success -
             from a completely incompatible mapping (<see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/> = <c>false</c>), or a successful mapping from
             an open generic type to a closed generic type which can then be constructed (<see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/> = <c>true</c>
             and <see cref="P:Rezolver.Runtime.GenericTypeMapping.IsFullyBound"/> = <c>true</c>) or, a successful mapping from an open generic type to another open
             generic type (<see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/> = <c>true</c> but <see cref="P:Rezolver.Runtime.GenericTypeMapping.IsFullyBound"/> = <c>false</c>).
            
             This mapping is then used by both the <see cref="M:Rezolver.Targets.GenericConstructorTarget.SupportsType(System.Type)"/> and
             <see cref="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/>
             functions.  Only fully bound mappings are supported by <see cref="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/>, whereas
             <see cref="M:Rezolver.Targets.GenericConstructorTarget.SupportsType(System.Type)"/> will return <c>true</c> so long as the <see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/> is true.
            
             The caller, therefore, must ensure it is aware of the difference between open and closed generics.
             </summary>
        </member>
        <member name="P:Rezolver.Runtime.GenericTypeMapping.BindErrorMessage">
             <summary>
             Gets a string describing the reason why the type could not be mapped.  Can be used for exceptions, etc.
            
             Note that this can be set even if <see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/> is <c>true</c> - because mappings exist between
             open generic types so that a target's <see cref="M:Rezolver.Targets.GenericConstructorTarget.SupportsType(System.Type)"/> returns <c>true</c>, but the
             <see cref="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> function throws an exception for the same type, since you can't create
             an instance of an open generic.
             </summary>
             <value>The binding error message.</value>
        </member>
        <member name="P:Rezolver.Runtime.GenericTypeMapping.RequestedType">
            <summary>
            The type requested for mapping.  If this is an open generic, then the best result for this mapping will be
            that <see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/> is <c>true</c> and <see cref="P:Rezolver.Runtime.GenericTypeMapping.IsFullyBound"/> is <c>false</c>.
            </summary>
        </member>
        <member name="P:Rezolver.Runtime.GenericTypeMapping.Type">
             <summary>
             If <see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/> = <c>true</c>, gets the generic type to be used for the <see cref="P:Rezolver.Runtime.GenericTypeMapping.RequestedType"/>.
            
             Note that this could be either an open or closed generic - the <see cref="P:Rezolver.Runtime.GenericTypeMapping.IsFullyBound"/> offers a quick means
             by which to determine this.  If <see cref="P:Rezolver.Runtime.GenericTypeMapping.IsFullyBound"/> is <c>true</c>, then the mapping will succeed when
             encountered by the <see cref="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method.
             </summary>
             <value>The type.</value>
        </member>
        <member name="P:Rezolver.Runtime.GenericTypeMapping.Constructor">
            <summary>
            If a specific constructor is to be used, then this is it.
            </summary>
        </member>
        <member name="P:Rezolver.Runtime.GenericTypeMapping.Success">
             <summary>
             Gets a value indicating whether the <see cref="P:Rezolver.Targets.GenericConstructorTarget.DeclaredType"/> of the
             <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
             was successfully mapped to the requested type.  If so, and <see cref="P:Rezolver.Runtime.GenericTypeMapping.IsFullyBound"/> is <c>true</c>, then an
             instance of <see cref="P:Rezolver.Runtime.GenericTypeMapping.Type"/> will be compatible with the type that was requested.
            
             If <see cref="P:Rezolver.Runtime.GenericTypeMapping.IsFullyBound"/> is <c>false</c>, then you can't create an instance of <see cref="P:Rezolver.Runtime.GenericTypeMapping.Type"/> because it's
             an open generic - but you will be able to bind the same target to a closed generic of the same <see cref="P:Rezolver.Runtime.GenericTypeMapping.Type"/>.
             </summary>
             <value><c>true</c> if success; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Rezolver.Runtime.GenericTypeMapping.IsFullyBound">
            <summary>
            If true, then the <see cref="P:Rezolver.Runtime.GenericTypeMapping.Type"/> is a fully closed generic type that can be constructed (and therefore would
            be successfully bound by the <see cref="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method, which uses the
            <see cref="M:Rezolver.Targets.GenericConstructorTarget.MapType(System.Type)"/>
            method).  If this is <c>false</c> but <see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/> is <c>true</c>, then while the target is technically
            compatible with the requested type, you can't create an instance.  The target will, however, be able to mapped to
            a closed generic type based on the same <see cref="P:Rezolver.Runtime.GenericTypeMapping.Type"/>.
            </summary>
        </member>
        <member name="T:Rezolver.Runtime.LazyEnumerable`1">
             <summary>
             Can be used as an implementation of <see cref="T:System.Collections.Generic.IEnumerable`1"/> when injecting enumerables from
             one or more registered targets.
             </summary>
             <typeparam name="T">The type of object enumerated by the enumerable.</typeparam>
             <remarks>Objects are not expected to take a dependency on this type - but <see cref="T:System.Collections.Generic.IEnumerable`1"/>.  The
             default compiler, <see cref="T:Rezolver.Compilation.Expressions.ExpressionCompiler"/>, constructs an instance of this
             when building an <see cref="T:Rezolver.Targets.EnumerableTarget"/> (via the <see cref="T:Rezolver.Compilation.Expressions.EnumerableTargetBuilder"/>
             expression builder).
            
             ## Lazy vs Eager enumerables
            
             The default enumerable produced by Rezolver containers is lazily evaluated - via this type.  You can disable this entirely
             (i.e. switching to eagerly loaded enumerables implemented via the <see cref="T:Rezolver.Runtime.EagerEnumerable`1"/> type)
             by setting the <see cref="T:Rezolver.Options.LazyEnumerables"/> option to <c>false</c> in the underlying <see cref="T:Rezolver.ITargetContainer"/>
             used by the container.
            
             You can also switch to eagerly loaded enumerables on a per-type basis - by setting the <see cref="T:Rezolver.Options.LazyEnumerables"/>
             option to <c>false</c> against the specific type of enumerable you want to be eagerly loaded - e.g. for an eagerly loaded <see cref="T:System.Collections.Generic.IEnumerable`1"/> of
             type <see cref="T:System.String"/>, then you would set the <see cref="T:Rezolver.Options.LazyEnumerables"/> to <c>false</c> for the type <c>IEnumerable&lt;string&gt;</c>
             </remarks>
             <seealso cref="T:Rezolver.Runtime.EagerEnumerable`1"/>
        </member>
        <member name="M:Rezolver.Runtime.LazyEnumerable`1.#ctor(System.Delegate[])">
            <summary>
            Creates a new <see cref="T:Rezolver.Runtime.LazyEnumerable`1"/> instance.
            </summary>
            <param name="factories"></param>
        </member>
        <member name="M:Rezolver.Runtime.LazyEnumerable`1.GetInstances(Rezolver.ResolveContext)">
            <summary>
            The method that is used to produce instances by the container.
            </summary>
            <param name="context">The current context</param>
            <returns>An enumerable which produces each instance as it is enumerated.</returns>
        </member>
        <member name="P:Rezolver.Runtime.TargetProjection.Target">
            <summary>
            The target that will implement the projection
            </summary>
        </member>
        <member name="P:Rezolver.Runtime.TargetProjection.ImplementationType">
            <summary>
            Concrete type to be built by the <see cref="P:Rezolver.Runtime.TargetProjection.Target"/> for the projection
            </summary>
        </member>
        <member name="P:Rezolver.TargetTypeSelectorParams.EnableVariance">
             <summary>
             <c>true</c> if contravariance (and covariance when it's implemented) are to be allowed
             for this search.  This acts as a master gate for all variance - e.g. even if a type parameter
             is contravariant, setting this to <c>false</c> will prevent contravariant searching.
            
             Further checks are then performed for the individual types of variant searching to detect if they're
             to be used.
             </summary>
        </member>
        <member name="P:Rezolver.TargetTypeSelectorParams.Contravariance">
            <summary>
            If Contravariant type searches are enabled, this controls the types
            which are to be considered.
            </summary>
        </member>
        <member name="P:Rezolver.TargetTypeSelectorParams.ForceContravariance">
             <summary>
             If <c>null</c>, enabling of contravariance for the search type is determined
             by a target container option (or internal attribute for internal types).
            
             If not null, contravariant searches are only performed for the search type
             if it is <c>true</c>.
             </summary>
             <remarks>This is required for when options are sought from a target container
             because the <see cref="T:Rezolver.Options.IOptionContainer`2"/> interface
             is contravariant and allows us to set option on a per-service bases, contravariant
             searching is forced to <c>true</c> for those, and is forced to <c>false</c>
             for <see cref="T:Rezolver.Options.IOptionContainer`1"/>, to avoid endless recursion into the
             options API.
            
             This is demonstrated by the paradox created when using the
             <see cref="T:Rezolver.Options.EnableContravariance"/> option to disable contravariance for a
             type and any of its derivatives or implementations - that option lookup *requires*
             contravariance for that type to be enabled in order to work!</remarks>
        </member>
        <member name="M:Rezolver.TargetTypeSelectorParams.#ctor(System.Type,Rezolver.TargetTypeSelector)">
            <summary>
            Constructor used for the top-level search
            </summary>
            <param name="type"></param>
            <param name="owner"></param>
        </member>
        <member name="T:Rezolver.ScopeBehaviour">
            <summary>
            Describes different ways in which objeects interact with scopes.
            </summary>
            <remarks>Note: this enum *might* be replaced with an abstraction in the future.  If so,
            it will not alter how regatrations are performed, but it will affect any low-level code
            which uses this enum directly.</remarks>
        </member>
        <member name="F:Rezolver.ScopeBehaviour.Implicit">
            <summary>
            Implicitly scoped objects are only added to the scope
            for the purposes of disposing when the scope is disposed
            </summary>
        </member>
        <member name="F:Rezolver.ScopeBehaviour.Explicit">
            <summary>
            Explicitly scoped objects act like singletons in the current scope, regardless of
            whether they are disposable or not.
            </summary>
        </member>
        <member name="F:Rezolver.ScopeBehaviour.None">
            <summary>
            The object will not be tracked in any scope, regardless of whether there is one active,
            or whether the object is disposable.
            </summary>
        </member>
        <member name="T:Rezolver.ScopedContainer">
             <summary>
             Extends the <see cref="T:Rezolver.Container"/> to implement lifetime implicit scoping through a
             <see cref="T:Rezolver.DisposingContainerScope"/> that's created along with it.
             </summary>
             <remarks>
             If you want your root container to act as a lifetime scope, then you should use this
             class instead of using <see cref="T:Rezolver.Container"/>.
            
             Note that this class does NOT implement the <see cref="T:Rezolver.ContainerScope"/> interface because
             the two interfaces are not actually compatible with each other, thanks to identical sets of extension methods.
             </remarks>
        </member>
        <member name="M:Rezolver.ScopedContainer.#ctor(Rezolver.IRootTargetContainer,Rezolver.IContainerConfig)">
             <summary>
             Constructs a new instance of the <see cref="T:Rezolver.ScopedContainer"/> class.
             </summary>
             <param name="targets">Optional.  Contains the targets that will be used as the source of registrations for the
             container, ultimately being passed to the <see cref="N:Rezolver.Targets"/> property.
            
             If not provided, then a new <see cref="T:Rezolver.TargetContainer"/> will be created.</param>
             <param name="config">Can be null.  A configuration to apply to this container (and, potentially its
             <see cref="N:Rezolver.Targets"/>).  If not provided, then the <see cref="P:Rezolver.Container.DefaultConfig"/> will be used</param>
        </member>
        <member name="M:Rezolver.ScopedContainer.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Rezolver.ScopedContainer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Rezolver.ScopePreference">
            <summary>
            Specifies the scope that the object produced by a target should be tracked within.
            </summary>
        </member>
        <member name="F:Rezolver.ScopePreference.Current">
            <summary>
            The object will be tracked within the scope already set on the <see cref="T:Rezolver.ResolveContext"/>
            </summary>
        </member>
        <member name="F:Rezolver.ScopePreference.Root">
            <summary>
            The object (and all its dependants) will be tracked within the <see cref="P:Rezolver.ContainerScope.Root"/> scope of the current scope
            set on the <see cref="T:Rezolver.ResolveContext"/>
            </summary>
        </member>
        <member name="T:Rezolver.Sdk.Dependant">
            <summary>
            Simple base class for implementations of <see cref="T:Rezolver.Sdk.IDependant"/> - the <see cref="P:Rezolver.Sdk.IDependant.Dependencies"/>
            property is implemented explictly.
            </summary>
        </member>
        <member name="T:Rezolver.Sdk.DependantCollection`1">
             <summary>
             A collection of objects in which one or more objects can be dependent on others in the
             same collection (via the <see cref="T:Rezolver.Sdk.IDependant"/> interface).
             </summary>
             <typeparam name="T">The type of object in the collection</typeparam>
             <remarks>
             To iterate the collection in order of least dependant to most dependant, enumerate the
             result of the <see cref="P:Rezolver.Sdk.DependantCollection`1.Ordered"/> function - which uses a typical DAG topological
             sort to organise the objects by least dependent to most dependent.
            
             In order for this to work - one or more objects in the collection must implement the <see cref="T:Rezolver.Sdk.IDependant"/>
             interface.</remarks>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.#ctor">
            <summary>
            Constructs a new empty <see cref="T:Rezolver.Sdk.DependantCollection`1"/> instance
            </summary>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs a new <see cref="T:Rezolver.Sdk.DependantCollection`1"/> with the passed range of objects as the initial
            set.
            </summary>
            <param name="range">The items to be added to the collection on construction.  If null, then the collection simply
            starts off empty.</param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.#ctor(`0[])">
            <summary>
            Provides a convenient way to initialise a <see cref="T:Rezolver.Sdk.DependantCollection`1"/> using a variable argument
            list.
            </summary>
            <param name="dependants">The items to be added to the collection on construction.</param>
        </member>
        <member name="P:Rezolver.Sdk.DependantCollection`1.Ordered">
             <summary>
             Gets an enumerable which will return the items in the collection in order of least dependent
             to most dependent.  Therefore, if item 1 depends on item 2, this enumerable will return item 2
             first, followed by item 1.
            
             Items which have no dependencies within the same collection will be sorted earlier in the collection.
            
             The sort is stable with respect to the order in which items are added; so equally dependant objects will
             retain their original order.
             </summary>
             <returns></returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.Clone``1">
            <summary>
            Creates a new instance of the collection type <typeparamref name="TDerived"/> whose items
            are cloned from this collection's items.
            </summary>
            <typeparam name="TDerived">The type of collection to be created from this one.</typeparam>
            <returns>A new instance of the type <typeparamref name="TDerived"/> whose items are cloned
            from this collection.</returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.Replace(`0,`0)">
            <summary>
            Replaces the <paramref name="original"/> object with the passed <paramref name="replacement"/> object, if
            <paramref name="original"/> is found within the collection.  The original object is returned if it is found
            and the replacement operation succeeds.
            </summary>
            <param name="original">Required. The object to be replaced.</param>
            <param name="replacement">Required. The replacement object.</param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.ReplaceOrAdd(`0,`0)">
            <summary>
            Replaces the <paramref name="original"/> with the <paramref name="replacement"/>, or
            adds the <paramref name="replacement"/> to the end of the collection if the <paramref name="original"/>
            does not exist.
            </summary>
            <param name="original">The item to be replaced.  If found, it will be swapped with
            the <paramref name="replacement"/>.</param>
            <param name="replacement">The item to be swapped with <paramref name="original"/> or added to
            the end of the collection if the <paramref name="original"/> can't be found.</param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.ReplaceAnyOrAdd``1(`0)">
            <summary>
            Replaces any objects of the type <typeparamref name="TOriginal"/> with the single object
            passed for the <paramref name="replacement"/> argument.  Note - the replacement will be inserted at the
            first index at which a matching object was found.  If none is found, then the replacement will be added to
            the end of the collection.
            </summary>
            <typeparam name="TOriginal">The type of object to be removed.  Note that any object equal to, derived from,
            or which implements the type will be removed.</typeparam>
            <param name="replacement">The object to be added to the collection at the position where the first object
            of the type <typeparamref name="TOriginal"/> is found.  Note that all will still be removed.</param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.ReplaceAnyOrAdd``1(System.Func{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Replaces any objects of the type <typeparamref name="TOriginal"/> with a single object
            obtained by calling the <paramref name="replacementCallback"/> callback.  Note - the replacement will be
            inserted at the first index at which a matching object was found.  If none is found, then the replacement
            will be added to the end of the collection.
            </summary>
            <typeparam name="TOriginal">The type of object to be removed.  Note that any object whose type is equal to, derived from,
            or which implements the type will be removed.</typeparam>
            <param name="replacementCallback">Callback to be executed to get the object that will replace any existing entries
            of the given type.  The callback will be passed an enumerable containing any existing entries.  Note that this
            enumerable will *never* be null, but might be empty.</param>
        </member>
        <member name="P:Rezolver.Sdk.DependantCollection`1.Item(System.Int32)">
            <summary>
            Implementation of <see cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
            </summary>
            <param name="index">Index of the item to be read or written.</param>
        </member>
        <member name="P:Rezolver.Sdk.DependantCollection`1.Count">
            <summary>
            Implementation of <see cref="P:System.Collections.Generic.ICollection`1.Count"/>
            </summary>
        </member>
        <member name="P:Rezolver.Sdk.DependantCollection`1.IsReadOnly">
            <summary>
            Implementation of <see cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>
            </summary>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.Clear">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.Clear"/>.  Empties the collection.
            </summary>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.Contains(`0)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>.  Returns a boolean indicating whether
            the passed <paramref name="item"/> is found in the collection.
            </summary>
            <param name="item">The item to be checked.</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>.
            </summary>
            <param name="array">The target array into which the collection will be copied.</param>
            <param name="arrayIndex">The starting index in the array </param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.IndexOf(`0)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IList`1.IndexOf(`0)"/>.
            </summary>
            <param name="item">The item whose index in the collection is to be returned.</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the passed <paramref name="item"/> at the given <paramref name="index"/> in the collection
            </summary>
            <param name="index">The index at which the new item is to be inserted.</param>
            <param name="item">Required.  The item to be inserted.</param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.Remove(`0)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
            </summary>
            <param name="item">The item to be removed.</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.RemoveAt(System.Int32)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)"/>
            </summary>
            <param name="index">The index of the item to be removed.</param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.Add(`0)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>
            </summary>
            <param name="item">Required.  The item to be added to the collection.</param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all the passed items to the collection.
            </summary>
            <param name="range">Required - the items to be added.  None of the items can be <c>null</c></param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.AddAll(`0[])">
            <summary>
            Alternative to <see cref="M:Rezolver.Sdk.DependantCollection`1.AddAll(System.Collections.Generic.IEnumerable{`0})"/> which allows you to pass individual items as arguments
            </summary>
            <param name="items">The items to be added</param>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all the <paramref name="items"/> from the collection that can be found within it.
            </summary>
            <param name="items">Required.  The items to be removed.</param>
            <returns><c>true</c> if all items were removed (note - if <paramref name="items"/> is empty this is
            also the case); <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Sdk.DependantExtensions">
            <summary>
            Extension methods for the <see cref="T:Rezolver.Sdk.IDependant"/> interface
            </summary>
        </member>
        <member name="M:Rezolver.Sdk.DependantExtensions.Requires``2(``0,``1)">
             <summary>
             Adds a required dependency from the object on which this is called to <paramref name="dep"/>
            
             The object <paramref name="dep"/> must be present in the input collection when dependencies are resolved.
             </summary>
             <typeparam name="T">The type of object on which this is called.</typeparam>
             <typeparam name="TDependency">The type for the dependency being added.</typeparam>
             <param name="obj">The object to which a dependency is to be added.</param>
             <param name="dep">The object upon which <paramref name="obj"/> is dependent.</param>
             <returns>The object on which the method is called.</returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantExtensions.Requires``2(``0,System.Collections.Generic.IEnumerable{``1})">
             <summary>
             Adds a required dependency from the object on which this is called to all the objects in <paramref name="deps"/>
            
             Every object in <paramref name="deps"/> must be present in the input collection when dependencies are resolved.
             </summary>
             <typeparam name="T">The type of object on which this is called.</typeparam>
             <typeparam name="TDependency">The type for the dependency being added.</typeparam>
             <param name="obj">The object to which a dependency is to be added.</param>
             <param name="deps">The objects upon which <paramref name="obj"/> is dependent.</param>
             <returns>The object on which the method is called.</returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantExtensions.RequiresAny``1(``0,System.Type)">
            <summary>
            Adds a required dependency from the object on which this is called to at least one object of the type
            <paramref name="dependencyType"/>.  Use this when only the type of the dependency is known, but the specific
            instance is not important.
            </summary>
            <typeparam name="T">The type of object on which this is called.</typeparam>
            <param name="obj">The object to which a dependency is to be added.</param>
            <param name="dependencyType">The type of objects upon which the object is dependent.</param>
            <returns>The object on which the method is called.</returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantExtensions.After``2(``0,``1)">
             <summary>
             Adds an optional dependency from the object on which this is called to <paramref name="dep"/>.
            
             If the object <paramref name="dep"/> is present in the input collection when dependencies are resolved, then it
             will be identified.
             </summary>
             <typeparam name="T">The type of object on which this is called.</typeparam>
             <typeparam name="TDependency">The type for the dependency being added.</typeparam>
             <param name="obj">The object to which a dependency is to be added.</param>
             <param name="dep">The object upon which <paramref name="obj"/> is optionally dependent.</param>
             <returns>The object on which the method is called.</returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantExtensions.After``2(``0,System.Collections.Generic.IEnumerable{``1})">
             <summary>
             Adds an optional dependency from the object on which this is called to all the objects in <paramref name="deps"/>.
            
             Any objects in <paramref name="deps"/> which are present in the input collection when dependencies are resolved will
             be identified as dependencies.  None of them will be required.
             </summary>
             <typeparam name="T">The type of object on which this is called.</typeparam>
             <typeparam name="TDependency">The type for the dependency being added.</typeparam>
             <param name="obj">The object to which a dependency is to be added.</param>
             <param name="deps">The objects upon which <paramref name="obj"/> is optionally dependent.</param>
             <returns>The object on which the method is called.</returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantExtensions.AfterAny``1(``0,System.Type)">
            <summary>
            Adds an optional dependency from the object on which this is called to any object of the type
            <paramref name="dependencyType"/>.  Use this when only the type of the dependency is known, but the specific
            instance is not important.
            </summary>
            <typeparam name="T">The type of object on which this is called.</typeparam>
            <param name="obj">The object to which a dependency is to be added.</param>
            <param name="dependencyType">The type for the dependency being added.</param>
            <returns>The object on which the method is called.</returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantExtensions.GetDependencies``2(``0,System.Collections.Generic.IEnumerable{``1})">
             <summary>
             Shortcut method for resolving the dependencies for an <see cref="T:Rezolver.Sdk.IDependant"/> from a set of objects.
            
             All the method does is forward the call to the <see cref="M:Rezolver.Sdk.DependencyEnumerableExtensions.GetDependencies``1(System.Collections.Generic.IEnumerable{Rezolver.Sdk.DependencyMetadata},System.Collections.Generic.IEnumerable{``0})"/>
             method of the <see cref="T:Rezolver.Sdk.DependencyMetadataCollection"/> belonging to the passed <see cref="T:Rezolver.Sdk.IDependant"/> - <paramref name="obj"/>
             </summary>
             <typeparam name="T">The type of object on which the method was called.</typeparam>
             <typeparam name="TDependency">The common dependency type</typeparam>
             <param name="obj">Required - the object whose dependencies are to be resolved.</param>
             <param name="objects">Required - the range of objects from which dependencies are to be located.
            
             Generally speaking, it's typical for <paramref name="obj"/> to be a member of this range.</param>
             <returns></returns>
        </member>
        <member name="M:Rezolver.Sdk.DependantExtensions.CreateTypeDependency``1(Rezolver.Sdk.IDependant,System.Boolean)">
             <summary>
             Creates a dependency for the object on which this method is invoked to objects of a particular type - either required or optional.
             </summary>
             <typeparam name="TDependency">The type of objects that will be the target of the dependency.</typeparam>
             <param name="obj">The dependant object for which the dependency is to be created.</param>
             <param name="required"><c>true</c> to make the dependency required; <c>false</c> to make it optional.</param>
             <returns>A new <see cref="T:Rezolver.Sdk.DependencyMetadata"/> object representing a dependency from <paramref name="obj"/> to
             objects of type <typeparamref name="TDependency"/>.</returns>
             <remarks>As with <see cref="M:Rezolver.Sdk.DependantExtensions.CreateObjectDependency``1(Rezolver.Sdk.IDependant,``0,System.Boolean)"/>, this method creates a
             new <see cref="T:Rezolver.Sdk.DependencyMetadata"/> object and returns it, as opposed to the methods
             <see cref="M:Rezolver.Sdk.DependantExtensions.RequiresAny``1(``0,System.Type)"/> or <see cref="M:Rezolver.Sdk.DependantExtensions.AfterAny``1(``0,System.Type)"/>, which create and add the dependency directly
             to an <see cref="T:Rezolver.Sdk.IMutableDependant"/> object.
            
             This method is used most often by <see cref="T:Rezolver.Sdk.IDependant"/> objects (i.e. those with read-only dependencies) which have a
             fixed set of required or optional dependencies that are known at construction-time.</remarks>
        </member>
        <member name="M:Rezolver.Sdk.DependantExtensions.CreateObjectDependency``1(Rezolver.Sdk.IDependant,``0,System.Boolean)">
             <summary>
             Creates a dependency for the object which this method is invoked to a specific instance of a particular type - either
             required or optional.
             </summary>
             <typeparam name="TDependency">The type of the object that will be the target of the dependency.</typeparam>
             <param name="obj">The dependant object for which the dependency is to be created.</param>
             <param name="dependency">The object that will be the target of the dependency.</param>
             <param name="required"><c>true</c> to make the dependency required; <c>false</c> to make it optional.</param>
             <returns>A new <see cref="T:Rezolver.Sdk.DependencyMetadata"/> object representing a dependency from <paramref name="obj"/> to
             the object <paramref name="dependency"/>.</returns>
             <remarks>As with <see cref="M:Rezolver.Sdk.DependantExtensions.CreateTypeDependency``1(Rezolver.Sdk.IDependant,System.Boolean)"/>, this method creates a
             new <see cref="T:Rezolver.Sdk.DependencyMetadata"/> object and returns it, as opposed to the methods
             <see cref="M:Rezolver.Sdk.DependantExtensions.Requires``2(``0,``1)"/> or <see cref="M:Rezolver.Sdk.DependantExtensions.After``2(``0,``1)"/>,
             which create and add the dependency directly to an <see cref="T:Rezolver.Sdk.IMutableDependant"/> object.
            
             This method is used most often by <see cref="T:Rezolver.Sdk.IDependant"/> objects (i.e. those with read-only dependencies) which have a
             fixed set of required or optional dependencies that are known at construction-time.</remarks>
        </member>
        <member name="T:Rezolver.Sdk.DependencyEnumerableExtensions">
            <summary>
            Extensions for <c>IEnumerable&lt;DependencyMetadata&gt;</c>
            </summary>
        </member>
        <member name="M:Rezolver.Sdk.DependencyEnumerableExtensions.GetDependencies``1(System.Collections.Generic.IEnumerable{Rezolver.Sdk.DependencyMetadata},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Identifies the objects that match the dependencies in this collection.
            </summary>
            <param name="metadata">The dependency metadata which describes a set of dependencies</param>
            <param name="objects">The objects from which dependencies are to be identified.</param>
            <returns>An enumerable containing the objects (selected from <paramref name="objects"/>) which
            match the dependencies in this collection.  If there are no dependency matches, the enumerable
            will be empty.</returns>
        </member>
        <member name="T:Rezolver.Sdk.DependencyException">
             <summary>
             This exception is related to the <see cref="T:Rezolver.Sdk.IDependant"/> functionality used by Rezolver.
            
             It is raised when two objects dependn on each other, or if a required dependency is missing
             from the collection passed to a <see cref="T:Rezolver.Sdk.DependencyMetadata"/> object's
             <see cref="M:Rezolver.Sdk.DependencyMetadata.GetDependencies``1(System.Collections.Generic.IEnumerable{``0})"/> method.
             </summary>
             <remarks>Creation of this exception is currently kept internal</remarks>
        </member>
        <member name="M:Rezolver.Sdk.DependencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Required constructor for Serialization
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Rezolver.Sdk.DependencyMetadata">
             <summary>
             Represents a dependency from an <see cref="T:Rezolver.Sdk.IDependant"/> on one or more other objects
             in a collection.
            
             Note that the current implementations of this class are internal and can only be created
             through the various methods in the <see cref="T:Rezolver.Sdk.DependantExtensions"/> class.
             </summary>
        </member>
        <member name="P:Rezolver.Sdk.DependencyMetadata.Owner">
            <summary>
            The <see cref="T:Rezolver.Sdk.IDependant"/> to which this dependency belongs.
            </summary>
        </member>
        <member name="P:Rezolver.Sdk.DependencyMetadata.Required">
            <summary>
            <c>true</c> if the dependency is essential to the <see cref="P:Rezolver.Sdk.DependencyMetadata.Owner"/>, false
            if it's optional.
            </summary>
            <remarks>When a <see cref="T:Rezolver.Sdk.DependantCollection`1"/> sorts its contents by dependency,
            all objects will be sorted after their dependencies, regardless of whether they're required or
            not.  The difference between a required dependency and an optional one is that if a required
            dependency fails to match all the objects it expects when <see cref="M:Rezolver.Sdk.DependencyMetadata.GetDependencies``1(System.Collections.Generic.IEnumerable{``0})"/>
            is called, an exception will occur.</remarks>
        </member>
        <member name="M:Rezolver.Sdk.DependencyMetadata.#ctor(Rezolver.Sdk.IDependant,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.Sdk.DependencyMetadata"/> class.
            </summary>
            <param name="owner"></param>
            <param name="required"></param>
        </member>
        <member name="M:Rezolver.Sdk.DependencyMetadata.GetDependencies``1(System.Collections.Generic.IEnumerable{``0})">
             <summary>
             Called to select the dependencies which match this dependency metadata from the
             <paramref name="objects"/> passed.
             </summary>
             <typeparam name="T">Type type of objects from which dependencies are sought.</typeparam>
             <param name="objects">Required.  The objects which are to be searched for dependencies which
             match this dependency metadata.</param>
             <returns>A filtered enumerable containing any objects from <paramref name="objects"/> which match
             this dependency metadata.</returns>
             <exception cref="T:Rezolver.Sdk.DependencyException">Most commonly thrown if a required dependency is not
             present in <paramref name="objects"/>, but other reasons are possible.
            
             Basically - if you get one of these, then there's something wrong with the <paramref name="objects"/>
             which prevents dependencies from being obtained by this dependency metadata.</exception>
        </member>
        <member name="T:Rezolver.Sdk.DependencyMetadataCollection">
             <summary>
             A collection of <see cref="T:Rezolver.Sdk.DependencyMetadata"/> objects.
            
             An <see cref="T:Rezolver.Sdk.IDependant"/> contains one of these collections in order to store the
             dependencies that it has on other objects.
             </summary>
        </member>
        <member name="M:Rezolver.Sdk.DependencyMetadataCollection.GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/> - returns an enumerator
            which enumerates all the <see cref="T:Rezolver.Sdk.DependencyMetadata"/> objects in the collection.
            </summary>
        </member>
        <member name="M:Rezolver.Sdk.DependencyMetadataCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:Rezolver.Sdk.DependencyMetadataCollection.Add(Rezolver.Sdk.DependencyMetadata)">
            <summary>
            Adds a dependency to this collection.
            </summary>
            <param name="dependency">Required.  The dependency to be added.</param>
        </member>
        <member name="M:Rezolver.Sdk.DependencyMetadataCollection.AddRange(System.Collections.Generic.IEnumerable{Rezolver.Sdk.DependencyMetadata})">
            <summary>
            Adds multiple dependencies to the collection.
            </summary>
            <param name="dependencies"></param>
        </member>
        <member name="T:Rezolver.Sdk.IDependant">
            <summary>
            Interface for an object that is dependent upon other objects
            </summary>
        </member>
        <member name="P:Rezolver.Sdk.IDependant.Dependencies">
            <summary>
            Contains all dependency metadata for this object.
            </summary>
        </member>
        <member name="T:Rezolver.Sdk.IMutableDependant">
            <summary>
            Interface for an <see cref="T:Rezolver.Sdk.IDependant"/> whose dependencies are described by a
            <see cref="T:Rezolver.Sdk.DependencyMetadataCollection"/> (and which are, therefore, mutable).
            </summary>
        </member>
        <member name="P:Rezolver.Sdk.IMutableDependant.Dependencies">
            <summary>
            A collection through which dependencies can be added and removed, as well as read.
            </summary>
            <remarks>The <see cref="T:Rezolver.Sdk.DependantExtensions"/> extension methods leverage this property to provide a
            clean interface for adding different types of dependencies to dependant objects.</remarks>
        </member>
        <member name="T:Rezolver.Sdk.ObjectDependency">
            <summary>
            Represents a dependency on a specific instance
            </summary>
        </member>
        <member name="T:Rezolver.Target">
            <summary>
            Provides static factory methods (including extension methods) for creating numerous types of targets
            from the <see cref="N:Rezolver.Targets"/> namespace.
            </summary>
            <remarks>
            Although most of these methods create targets of a known type (e.g. <see cref="M:Rezolver.Target.Scoped(Rezolver.ITarget)"/>
            returns a <see cref="T:Rezolver.Targets.ScopedTarget"/>), the methods all return <see cref="T:Rezolver.ITarget"/> to allow for
            changes in implementation in the future.</remarks>
        </member>
        <member name="M:Rezolver.Target.Scoped(Rezolver.ITarget)">
            <summary>
            Extension method which creates a <see cref="T:Rezolver.Targets.ScopedTarget"/> from the target on which this
            method is invoked.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Target.Unscoped(Rezolver.ITarget)">
            <summary>
            Extension method which creates an <see cref="T:Rezolver.Targets.UnscopedTarget"/> from the target
            on which this method is invoked.
            </summary>
            <param name="target">The target.</param>
        </member>
        <member name="M:Rezolver.Target.Singleton(Rezolver.ITarget)">
            <summary>
            Extension method which constructs a <see cref="T:Rezolver.Targets.SingletonTarget"/> that wraps the
            target on which the method is invoked.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Target.As(Rezolver.ITarget,System.Type)">
            <summary>
            Extension method which creates a new <see cref="T:Rezolver.Targets.ChangeTypeTarget"/> that wraps the
            <paramref name="target"/>, changing its <see cref="P:Rezolver.ITarget.DeclaredType"/> to the
            <paramref name="targetType"/> passed.
            </summary>
            <param name="target">Required. The target.</param>
            <param name="targetType">Required. The new type for the <paramref name="target"/>.</param>
        </member>
        <member name="M:Rezolver.Target.As``1(Rezolver.ITarget)">
            <summary>
            Extension method which creates a new <see cref="T:Rezolver.Targets.ChangeTypeTarget"/> that wraps the
            <paramref name="target"/>, changing its <see cref="P:Rezolver.ITarget.DeclaredType"/> to
            <typeparamref name="T"/>.
            </summary>
            <param name="target">Required. The target.</param>
        </member>
        <member name="M:Rezolver.Target.ForObject``1(``0,System.Type,Rezolver.ScopeBehaviour)">
            <summary>
            Creates a new <see cref="T:Rezolver.Targets.ObjectTarget"/> for the passed <paramref name="object"/> whose
            <see cref="P:Rezolver.ITarget.DeclaredType"/> will either be set to <typeparamref name="T"/> or
            <paramref name="declaredType"/>, if it is passed non-null.
            </summary>
            <typeparam name="T">Type of the object</typeparam>
            <param name="object">The @object to be wrapped by the new <see cref="T:Rezolver.Targets.ObjectTarget"/></param>
            <param name="declaredType">Optional - will be used to set the <see cref="P:Rezolver.ITarget.DeclaredType"/>
            of the target that is created.</param>
            <param name="scopeBehaviour">The scope behaviour of the target if resolved inside an
            <see cref="T:Rezolver.ContainerScope"/>.</param>
        </member>
        <member name="M:Rezolver.Target.ForObject(System.Object,System.Type,Rezolver.ScopeBehaviour)">
            <summary>
            Creates a new <see cref="T:Rezolver.Targets.ObjectTarget"/> for the passed <paramref name="object"/> whose
            <see cref="P:Rezolver.ITarget.DeclaredType"/> will either be set to object's type (obtained by calling
            <see cref="M:System.Object.GetType"/> or <paramref name="declaredType"/>, if it is passed non-null.
            </summary>
            <param name="object">The @object to be wrapped by the new <see cref="T:Rezolver.Targets.ObjectTarget"/></param>
            <param name="declaredType">Optional - will be used to set the <see cref="P:Rezolver.ITarget.DeclaredType"/>
            of the target that is created.</param>
            <param name="scopeBehaviour">The scope behaviour of the target if resolved inside an
            <see cref="T:Rezolver.ContainerScope"/>.</param>
        </member>
        <member name="M:Rezolver.Target.Resolved(System.Type,Rezolver.ITarget)">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ResolvedTarget"/> for the given type, providing a way to call back into the
            container during the execution of another target.
            </summary>
            <param name="type">Required. The type to be resolved from the container.</param>
            <param name="fallbackTarget">Optional. If provided and the container is unable to resolve the
            <paramref name="type"/>, then this target is used instead.</param>
            <returns>An <see cref="T:Rezolver.ITarget"/>.</returns>
        </member>
        <member name="M:Rezolver.Target.Resolved``1(Rezolver.ITarget)">
            <summary>
            Generic version of <see cref="M:Rezolver.Target.Resolved(System.Type,Rezolver.ITarget)"/> - creates a <see cref="T:Rezolver.Targets.ResolvedTarget"/>
            for the given type, providing a way to callback into the container during the execution of another
            target.
            </summary>
            <typeparam name="T">The type to be resolved from the container.</typeparam>
            <param name="fallbackTarget">Optional. If provided and the container is unable to resolve the
            <typeparamref name="T"/>, then this target is used instead</param>
            <returns>An <see cref="T:Rezolver.ITarget"/> which represents the act of resolving a particular type from the container.</returns>
        </member>
        <member name="M:Rezolver.Target.ForDelegate(System.Delegate,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>
            A simple wrapper for the <see cref="M:Rezolver.Targets.DelegateTarget.#ctor(System.Delegate,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)"/> constructor.
            </summary>
            <param name="factory">Required, the factory delegate that is to be used to produce an object.</param>
            <param name="declaredType">Optional.  If not null, then it will be used as the target's <see cref="P:Rezolver.ITarget.DeclaredType"/>
            which, in turn, is used as the target's default registration type if not overriden when added to
            an <see cref="T:Rezolver.ITargetContainer"/>.  If null, then the return type of the factory will be used.</param>
            <param name="scopeBehaviour">Scope behaviour for this delegate.  The default is <see cref="F:Rezolver.ScopeBehaviour.None"/>, which means
            that no disposal will take place by default for the instance.  If the delegate produces a new instance, then 
            <see cref="F:Rezolver.ScopeBehaviour.Implicit"/> or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the delegate should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <returns>An <see cref="T:Rezolver.ITarget"/> which represents the passed factory.</returns>
        </member>
        <member name="M:Rezolver.Target.ForExpression(System.Linq.Expressions.Expression,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>
            A simple wrapper for the <see cref="M:Rezolver.Targets.ExpressionTarget.#ctor(System.Linq.Expressions.Expression,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)"/> constructor.
            </summary>
            <param name="expression">Required, the expression representing the code that is to be executed
            in order to produce an object.</param>
            <param name="declaredType">Optional.  If not null, then it will be used as the target's <see cref="P:Rezolver.ITarget.DeclaredType"/>
            which, in turn, is used as the target's default registration type if not overriden when added to an
            <see cref="T:Rezolver.ITargetContainer"/>.  If null, then the <see cref="P:System.Linq.Expressions.Expression.Type"/> will be used, unless
            <paramref name="expression"/> is a <see cref="T:System.Linq.Expressions.LambdaExpression"/>, in which case the <see cref="P:System.Linq.Expressions.Expression.Type"/>
            of its <see cref="P:System.Linq.Expressions.LambdaExpression.Body"/> will be used.</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.None"/>, which means
            that no disposal will take place by default for the instance.  If the expression produces a new instance, then 
            <see cref="F:Rezolver.ScopeBehaviour.Implicit"/> or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <returns>An <see cref="T:Rezolver.ITarget"/> which represents the given expression; which must be compiled or otherwise
            translated into a runtime operation which creates/obtains an object.</returns>
        </member>
        <member name="M:Rezolver.Target.ForType(System.Type,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
            for the type <paramref name="type"/>.
            </summary>
            <param name="type">The type whose constructor is to be bound by the target.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
            <returns>A new target for the type <paramref name="type"/></returns>
            <remarks>If the type is a generic type definition, then a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
            is created; otherwise a <see cref="T:Rezolver.Targets.ConstructorTarget"/> is created.</remarks>
        </member>
        <member name="M:Rezolver.Target.ForType(System.Type,System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget},Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
            for the type <paramref name="type"/>.
            </summary>
            <param name="type">The type whose constructor is to be bound by the target.</param>
            <param name="namedArgs">Optional.  A dictionary of targets that are to be bound to the type's
            constructor by name and type.  If <paramref name="type"/> is a generic type definition, then
            this parameter must be null, or an <see cref="T:System.ArgumentException"/> will be thrown.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
            <returns>A new target for the type <paramref name="type"/></returns>
            <remarks>If the type is a generic type definition, then a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
            is created; otherwise a <see cref="T:Rezolver.Targets.ConstructorTarget"/> is created.</remarks>
        </member>
        <member name="M:Rezolver.Target.ForType``1(Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> for the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type whose constructor is to be bound by the target.</typeparam>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
            <returns>A new target for the type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Rezolver.Target.ForType``1(System.Action{Rezolver.IMemberBindingBehaviourBuilder{``0}})">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> for the type <typeparamref name="T"/> with
            an <see cref="T:Rezolver.IMemberBindingBehaviour"/> built from an <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/>
            that's configured by the <paramref name="configureMemberBinding"/> callback.
            </summary>
            <typeparam name="T">The type of object to be created by the target</typeparam>
            <param name="configureMemberBinding">Will be called with a new instance of
            <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> for you to configure any
            member bindings you wish to add to the target.</param>
            <returns>A new target for the type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Rezolver.Target.ForType``1(System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget},Rezolver.IMemberBindingBehaviour)">
             <summary>
             Creates a <see cref="T:Rezolver.Targets.ConstructorTarget" /> or <see cref="T:Rezolver.Targets.GenericConstructorTarget" />
             for the type <typeparamref name="T" />.
             </summary>
             <typeparam name="T">The type whose constructor is to be bound by the target.</typeparam>
             <param name="namedArgs">Can be null. A dictionary of targets that are to be bound to the type's
             constructor by name and <see cref="P:Rezolver.ITarget.DeclaredType"/>.
            
             If <typeparamref name="T"/> is a generic type definition, then
             this parameter must be null, or an <see cref="T:System.ArgumentException"/> will be thrown.</param>
             <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
             if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
             <returns>A new target for the type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Rezolver.Target.ForType``1(System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget},System.Action{Rezolver.IMemberBindingBehaviourBuilder{``0}})">
             <summary>
             Same as <see cref="M:Rezolver.Target.ForType``1(System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget},Rezolver.IMemberBindingBehaviour)"/> except this allows you to
             build a custom member binding behaviour using the fluent API exposed by the <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/>
             interface
             </summary>
             <typeparam name="T">The type whose constructor is to be bound by the target.</typeparam>
             <param name="namedArgs">Can be null. A dictionary of targets that are to be bound to the type's
             constructor by name and <see cref="P:Rezolver.ITarget.DeclaredType"/>.
            
             If <typeparamref name="T"/> is a generic type definition, then
             this parameter must be null, or an <see cref="T:System.ArgumentException"/> will be thrown.</param>
             <param name="configureMemberBinding">Will be called with a new instance of
             <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> for you to configure any
             member bindings you wish to add to the target.</param>
             <returns>A new target for the type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Rezolver.Target.ForType(System.Type,System.Object,Rezolver.IMemberBindingBehaviour)">
             <summary>
             Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
             for the type <paramref name="type"/>.
             </summary>
             <param name="type">The type whose constructor is to be bound by the target.</param>
             <param name="namedArgs">Optional.  An object whose publicly readable members which are of the
             type <see cref="T:Rezolver.ITarget"/> (or a type which implements it) are to be bound to the type's constructor
             by name and <see cref="P:Rezolver.ITarget.DeclaredType"/>.
            
             If <paramref name="type"/> is a generic type definition, then
             this parameter must be null, or an <see cref="T:System.ArgumentException"/> will be thrown.</param>
             <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
             if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
             <remarks>If the type is a generic type definition, then a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
             is created; otherwise a <see cref="T:Rezolver.Targets.ConstructorTarget"/> is created.
             </remarks>
             <example>This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a
             ConstructorTarget for the type 'MyType':
             <code>Target.ForType(typeof(MyType), namedArguments: new { param1 = new ObjectTarget(&quot; Hello World&quot;) });</code>
             </example>
        </member>
        <member name="M:Rezolver.Target.ForType``1(System.Object,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
            for the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type whose constructor is to be bound by the created target.</typeparam>
            <param name="namedArgs">Optional.  An object whose publicly readable members which are of the
            type <see cref="T:Rezolver.ITarget"/> (or a type which implements it) are to be bound to the type's constructor
            by name and <see cref="P:Rezolver.ITarget.DeclaredType"/>.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
            <returns>A new target for the type <typeparamref name="T"/></returns>
            <example>This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a
            ConstructorTarget for the type 'MyType':
            <code>Target.ForType&lt;MyType&gt;(namedArguments: new { param1 = new ObjectTarget(&quot;Hello World&quot;) });</code>
            </example>
        </member>
        <member name="M:Rezolver.Target.ForType``1(System.Object,System.Action{Rezolver.IMemberBindingBehaviourBuilder{``0}})">
            <summary>
            Same as <see cref="M:Rezolver.Target.ForType``1(System.Object,Rezolver.IMemberBindingBehaviour)"/> except this lets you build a custom <see cref="T:Rezolver.IMemberBindingBehaviour"/>
            using the fluent API offered by the <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> interface.
            </summary>
            <typeparam name="T">The type whose constructor is to be bound by the created target.</typeparam>
            <param name="namedArgs">Optional.  An objeect whose publicly readable members which are of the type
            <see cref="T:Rezolver.ITarget"/> (or a type which implements it) are to be bound to the type's constructor by name
            and <see cref="P:Rezolver.ITarget.DeclaredType"/>.</param>
            <param name="configureMemberBinding">Will be called with a new instance of
            <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> for you to configure any
            member bindings you wish to add to the target.</param>
            <returns>A new target for the type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Rezolver.Target.ForConstructor(System.Reflection.ConstructorInfo,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> for the given constructor, or a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> if the
            constructor belongs to a generic type definition ('open generic type').
            </summary>
            <param name="constructor">Required.  The constructor to be bound by the target.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
        </member>
        <member name="M:Rezolver.Target.ForConstructor(System.Reflection.ConstructorInfo,Rezolver.ParameterBinding[],Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> for the given constructor, or a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> if the
            constructor belongs to a generic type definition ('open generic type').
            </summary>
            <param name="constructor">Required.  The constructor to be bound by the target.</param>
            <param name="parameterBindings">Can be null/empty.  An array of <see cref="T:Rezolver.ParameterBinding"/>
            objects containing targets to be bound to somme or all of the constructor parameters.  **Must not be supplied if <paramref name="constructor"/>
            is a constructor belonging to an open generic type,**</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
        </member>
        <member name="M:Rezolver.Target.ForConstructor(System.Reflection.ConstructorInfo,System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget},Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> for the given constructor, or a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> if the
            constructor belongs to a generic type definition ('open generic type').
            </summary>
            <param name="constructor">Required.  The constructor to be bound by the target.</param>
            <param name="namedArgs">Can be null.  A dictionary of targets that are to be bound to the
            constructor by name and <see cref="P:Rezolver.ITarget.DeclaredType"/>.  **Must not be supplied if <paramref name="constructor"/>
            is a constructor belonging to an open generic type,**</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
        </member>
        <member name="M:Rezolver.Target.ForConstructor(System.Reflection.ConstructorInfo,System.Object,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates a <see cref="T:Rezolver.Targets.ConstructorTarget"/> for the given constructor, or a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> if the
            constructor belongs to a generic type definition ('open generic type').
            </summary>
            <param name="constructor">Required.  The constructor to be bound by the target.</param>
            <param name="namedArgs">Optional.  An object whose publicly readable members which are of the
            type <see cref="T:Rezolver.ITarget"/> (or a type which implements it) are to be bound to the constructor
            by name and <see cref="P:Rezolver.ITarget.DeclaredType"/>.  **Must not be supplied if <paramref name="constructor"/>
            is a constructor belonging to an open generic type,**</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on any target container in which the target is subsequently registered.</param>
        </member>
        <member name="M:Rezolver.Target.ForGenericConstructor``1(System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates a target which binds to the constructor of an open generic type, an exemplar of which is passed in <paramref name="newExpr"/>.
            
            The created target will be <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> whose <see cref="P:Rezolver.Targets.GenericConstructorTarget.GenericTypeConstructor"/>
            will be set to the constructor that is identified from the expression.
            </summary>
            <typeparam name="TExample">Must be a generic type.  It doesn't matter what the type arguments are, however,
            as the target that is created will be for the generic type definition of this type.</typeparam>
            <param name="newExpr">A lambda expression whose <see cref="P:System.Linq.Expressions.LambdaExpression.Body"/> is a <see cref="T:System.Linq.Expressions.NewExpression"/>
            which identifies the constructor that is to be used to create the instance of all concrete types derived from the
            the same generic type definition as <typeparamref name="TExample"/>.</param>
            <param name="memberBindingBehaviour">Optional. If you wish to bind members on the new instance, pass a member binding
            behaviour here.</param>
            <remarks>Note - a concrete generic is used as an *example* - the equivalent open generic constructor is located
            and registered against the open generic of the type you actually invoke this method for; e.g. if
            <typeparamref name="TExample"/> is `MyGeneric&lt;Foo, Bar&gt;`, then a target bound to the equivalent
            constructor on the open generic `MyGeneric&lt;,&gt;` will be what is actually created.</remarks>
        </member>
        <member name="M:Rezolver.Target.ForDelegate``1(System.Func{``0},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates a <see cref="T:Rezolver.Targets.DelegateTarget" /> for a parameterless factory delegate 
            which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="factory">Required.  The factory delegate that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Optional.  The type of disposal tracking to be employed by this target.  Defaults to <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.Target.ForDelegate``1(System.Func{Rezolver.ResolveContext,``0},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates a <see cref="T:Rezolver.Targets.DelegateTarget" /> for a factory delegate which takes an 
            <see cref="T:Rezolver.ResolveContext" /> and which returns
            an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="factory">Required.  The factory delegate that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Optional.  The type of disposal tracking to be employed by this target.  Defaults to <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the delegate are injected from the container when executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForDelegate``2(System.Func{``0,``1},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates a <see cref="T:Rezolver.Targets.DelegateTarget" /> for a factory delegate which takes 1 argument
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="factory">Required.  The factory delegate that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Optional.  The type of disposal tracking to be employed by this target.  Defaults to <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the delegate are injected from the container when executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForDelegate``3(System.Func{``0,``1,``2},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates a <see cref="T:Rezolver.Targets.DelegateTarget" /> for a factory delegate which takes 2 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="T2">Type of the 2nd delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="factory">Required.  The factory delegate that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Optional.  The type of disposal tracking to be employed by this target.  Defaults to <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the delegate are injected from the container when executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForDelegate``4(System.Func{``0,``1,``2,``3},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates a <see cref="T:Rezolver.Targets.DelegateTarget" /> for a factory delegate which takes 3 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="T2">Type of the 2nd delegate parameter</typeparam>
            <typeparam name="T3">Type of the 3rd delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="factory">Required.  The factory delegate that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Optional.  The type of disposal tracking to be employed by this target.  Defaults to <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the delegate are injected from the container when executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForDelegate``5(System.Func{``0,``1,``2,``3,``4},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates a <see cref="T:Rezolver.Targets.DelegateTarget" /> for a factory delegate which takes 4 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="T2">Type of the 2nd delegate parameter</typeparam>
            <typeparam name="T3">Type of the 3rd delegate parameter</typeparam>
            <typeparam name="T4">Type of the 4th delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="factory">Required.  The factory delegate that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Optional.  The type of disposal tracking to be employed by this target.  Defaults to <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the delegate are injected from the container when executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForDelegate``6(System.Func{``0,``1,``2,``3,``4,``5},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates a <see cref="T:Rezolver.Targets.DelegateTarget" /> for a factory delegate which takes 5 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="T2">Type of the 2nd delegate parameter</typeparam>
            <typeparam name="T3">Type of the 3rd delegate parameter</typeparam>
            <typeparam name="T4">Type of the 4th delegate parameter</typeparam>
            <typeparam name="T5">Type of the 5th delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="factory">Required.  The factory delegate that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Optional.  The type of disposal tracking to be employed by this target.  Defaults to <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the delegate are injected from the container when executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForExpression``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates an <see cref="T:Rezolver.Targets.ExpressionTarget" /> for a parameterless lambda expression 
            which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="lambda">Required.  The lambda expression that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.Target.ForExpression``1(System.Linq.Expressions.Expression{System.Func{Rezolver.ResolveContext,``0}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates an <see cref="T:Rezolver.Targets.ExpressionTarget" /> for a lambda expression which takes an
            <see cref="T:Rezolver.ResolveContext" /> and which returns
            an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="lambda">Required.  The lambda expression that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForExpression``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates an <see cref="T:Rezolver.Targets.ExpressionTarget" /> for a lambda expression which takes 1 argument
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="lambda">Required.  The lambda expression that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForExpression``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates an <see cref="T:Rezolver.Targets.ExpressionTarget" /> for a lambda expression which takes 2 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="T2">Type of the 2nd parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="lambda">Required.  The lambda expression that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForExpression``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates an <see cref="T:Rezolver.Targets.ExpressionTarget" /> for a lambda expression which takes 3 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="T2">Type of the 2nd parameter of the lambda expression.</typeparam>
            <typeparam name="T3">Type of the 3rd parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="lambda">Required.  The lambda expression that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForExpression``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates an <see cref="T:Rezolver.Targets.ExpressionTarget" /> for a lambda expression which takes 4 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="T2">Type of the 2nd parameter of the lambda expression.</typeparam>
            <typeparam name="T3">Type of the 3rd parameter of the lambda expression.</typeparam>
            <typeparam name="T4">Type of the 4th parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="lambda">Required.  The lambda expression that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.Target.ForExpression``6(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Creates an <see cref="T:Rezolver.Targets.ExpressionTarget" /> for a lambda expression which takes 5 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="T2">Type of the 2nd parameter of the lambda expression.</typeparam>
            <typeparam name="T3">Type of the 3rd parameter of the lambda expression.</typeparam>
            <typeparam name="T4">Type of the 4th parameter of the lambda expression.</typeparam>
            <typeparam name="T5">Type of the 5th parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="lambda">Required.  The lambda expression that is to be wrapped by the target.</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created,
            if different from <typeparamref name="TResult" /></param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="T:Rezolver.TargetContainer">
             <summary>
             Root container for <see cref="T:Rezolver.ITarget"/>s that can be used as the backing for
             <see cref="T:Rezolver.Container"/> and <see cref="T:Rezolver.ScopedContainer"/>.
            
             Stores and retrieves registrations of <see cref="T:Rezolver.ITarget"/>s, is also Generic type aware,
             unlike its base class - <see cref="T:Rezolver.TargetDictionaryContainer"/>.
             </summary>
             <remarks>This is the type used by default for the <see cref="P:Rezolver.Container.Targets"/> of all
             the standard containers in the core framework, e.g. <see cref="T:Rezolver.Container"/>,
             <see cref="T:Rezolver.ScopedContainer"/> etc, when you don't supply an instance of an
             <see cref="T:Rezolver.ITargetContainer"/> explicitly on construction.
            
             Although you can derive from this class to extend its functionality; it's also possible to
             extend it via configuration (see <see cref="T:Rezolver.ITargetContainerConfig"/>) - which is how, for example,
             the framework enables automatic injection of enumerables (see <see cref="T:Rezolver.Configuration.InjectEnumerables"/>) and
             lists (see <see cref="T:Rezolver.Configuration.InjectLists"/>).
            
             The <see cref="P:Rezolver.TargetContainer.DefaultConfig"/> is used for new instances which are not passed an explicit configuration.</remarks>
        </member>
        <member name="E:Rezolver.TargetContainer.TargetRegistered">
            <summary>
            Implementation of the <see cref="E:Rezolver.IRootTargetContainer.TargetRegistered"/> event
            </summary>
        </member>
        <member name="E:Rezolver.TargetContainer.TargetContainerRegistered">
            <summary>
            Implementation of the <see cref="E:Rezolver.IRootTargetContainer.TargetContainerRegistered"/> event
            </summary>
        </member>
        <member name="P:Rezolver.TargetContainer.DefaultConfig">
             <summary>
             The default configuration used for <see cref="T:Rezolver.TargetContainer"/> objects created via the <see cref="M:Rezolver.TargetContainer.#ctor(Rezolver.ITargetContainerConfig)"/>
             constructor when no configuration is explicitly passed.
             </summary>
             <remarks>The simplest way to configure all target container instances is to add/remove configs to this collection.
            
             Note also that the <see cref="T:Rezolver.OverridingTargetContainer"/> class also uses this.
            
             #### Default configurations
            
             The configurations applied by default are:
            
             - <see cref="T:Rezolver.Configuration.InjectEnumerables"/>
             - <see cref="T:Rezolver.Configuration.InjectArrays"/>
             - <see cref="T:Rezolver.Configuration.InjectLists"/>
             - <see cref="T:Rezolver.Configuration.InjectCollections"/>
             - <see cref="T:Rezolver.Configuration.InjectAutoFuncs"/>
             - <see cref="T:Rezolver.Configuration.InjectAutoLazies"/>
             - <see cref="T:Rezolver.Configuration.InjectResolveContext"/>
             
             In most cases, these are controllable through the use of global properties such as:
             
             - <see cref="T:Rezolver.Options.EnableEnumerableInjection"/>
             - <see cref="T:Rezolver.Options.EnableArrayInjection"/>
             - <see cref="T:Rezolver.Options.EnableListInjection"/>
             - <see cref="T:Rezolver.Options.EnableCollectionInjection"/>
             - <see cref="T:Rezolver.Options.EnableAutoFuncInjection"/> (**NOTE:** defaults to <c>false</c>)
             - <see cref="T:Rezolver.Options.EnableAutoLazyInjection"/> (**NOTE:** defaults to <c>false</c>)
             </remarks>
        </member>
        <member name="P:Rezolver.TargetContainer.Root">
            <summary>
            Always returns this instance.
            </summary>
        </member>
        <member name="M:Rezolver.TargetContainer.#ctor(Rezolver.ITargetContainerConfig)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.TargetContainer"/> class.
            </summary>
            <param name="config">Optional.  The configuration to apply to this target container.  If null, then
            the <see cref="P:Rezolver.TargetContainer.DefaultConfig"/> is used.
            </param>
            <remarks>Note to inheritors: this constructor will throw an <see cref="T:System.InvalidOperationException"/> if called by derived
            classes.  You must instead use the <see cref="M:Rezolver.TargetContainer.#ctor"/> constructor and apply configuration in your
            constructor.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainer.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.TargetContainer"/> class without attaching any
            <see cref="T:Rezolver.ITargetContainerConfig"/> to it.  This is desirable for derived types as behaviours typically
            will invoke methods on this target container which are declared virtual and which are, therefore,
            unsafe to be called during construction.
            </summary>
        </member>
        <member name="M:Rezolver.TargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)"/>,
            overriding the base version to extend special support for open generic types and for
            <see cref="T:Rezolver.ITargetContainerTypeResolver"/> options.
            </summary>
            <param name="type"></param>
            <param name="container"></param>
        </member>
        <member name="M:Rezolver.TargetContainer.OnTargetContainerRegistered(Rezolver.ITargetContainer,System.Type)">
            <summary>
            Raises the <see cref="E:Rezolver.TargetContainer.TargetContainerRegistered"/> event.
            </summary>
            <param name="container">The target container that was registered</param>
            <param name="type">The type against which the <paramref name="container"/> was registered</param>
        </member>
        <member name="M:Rezolver.TargetContainer.Register(Rezolver.ITarget,System.Type)">
            <summary>
            Overrides the base method to block registration if the <paramref name="target"/> does not support the
            <paramref name="serviceType"/> (checked by calling the target's <see cref="M:Rezolver.ITarget.SupportsType(System.Type)"/> method).
            </summary>
            <param name="target">The target to be registered.</param>
            <param name="serviceType">Optional - the type against which the target is to be registered, if different from the
            target's <see cref="P:Rezolver.ITarget.DeclaredType"/>.</param>
        </member>
        <member name="M:Rezolver.TargetContainer.OnTargetRegistered(Rezolver.ITarget,System.Type)">
            <summary>
            Called when a new target has been registered in this target container.
            </summary>
            <param name="target">The target.</param>
            <param name="serviceType">Type of the service.</param>
        </member>
        <member name="M:Rezolver.TargetContainer.GetRegisteredContainerType(System.Type)">
            <summary>
            Called to get the type that's to be used to fetch a child <see cref="T:Rezolver.ITargetContainer"/> for targets registered
            against a given <paramref name="serviceType"/>.
            </summary>
            <param name="serviceType">The service type - usually pulled from the <see cref="P:Rezolver.ITarget.DeclaredType"/> of a
            <see cref="T:Rezolver.ITarget"/> that is to be registered, or the service type passed to <see cref="M:Rezolver.ITargetContainer.Fetch(System.Type)"/>.</param>
            <returns>The redirected type, or the <paramref name="serviceType"/> if no type redirection is necessary.</returns>
        </member>
        <member name="M:Rezolver.TargetContainer.CreateTargetContainer(System.Type)">
            <summary>
            Overrides <see cref="M:Rezolver.TargetDictionaryContainer.CreateTargetContainer(System.Type)"/> to provide special support
            for open generic types and to support <see cref="T:Rezolver.ITargetContainerFactory"/> options.
            </summary>
            <param name="targetContainerType"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.TargetContainerExtensions">
            <summary>
            Provides numerous extensions for registering targets
            </summary>
            <summary>
            Extension methods for ITargetContainer designed to simplify the registration of <see cref="T:Rezolver.Targets.DelegateTarget"/> and its
            numerous generic variants.
            </summary>
            <summary>
            Extensions for to simplify registering expressions in an <see cref="T:Rezolver.ITargetContainer"/>.
            </summary>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterAlias``2(Rezolver.ITargetContainer)">
            <summary>
            Generic version of <see cref="M:Rezolver.TargetContainerExtensions.RegisterAlias(Rezolver.ITargetContainer,System.Type,System.Type)"/>, see that method for more.
            </summary>
            <typeparam name="TAlias">Type being registered as an alias to another type</typeparam>
            <typeparam name="TOriginal">The target type of the alias.</typeparam>
            <param name="targetContainer">The target container in which the alias is to be registered</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterAlias(Rezolver.ITargetContainer,System.Type,System.Type)">
             <summary>
             Registers an alias for one type to another type.
            
             The created entry will effectively represent a second Resolve call into the container for the aliased type.
             </summary>
             <param name="targetContainer">The builder in which the alias is to be registered</param>
             <param name="aliasType">The type to be registered as an alias</param>
             <param name="originalType">The type being aliased.</param>
             <remarks>Use this when it's important that a given target type is always served through the same compiled target, even when the consumer
             expects it to be of a different type.  A very common scenario is when you have a singleton instance of the <paramref name="originalType" />,
             and need to serve that same instance for <paramref name="aliasType"/>.  If you register the same singleton for both types, you get two
             separate singletons for each type, whereas if you create an alias, both will be served by the same alias.
             </remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterConstructor(Rezolver.ITargetContainer,System.Reflection.ConstructorInfo,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Registers a type by constructor alone.
            </summary>
            <param name="targets"></param>
            <param name="constructor">The constructor to be bound. The <see cref="P:System.Reflection.MemberInfo.DeclaringType"/> will be used
            as the service type to be registered against.</param>
            <param name="memberBindingBehaviour">Optional. If you wish to bind members on the new instance, passing a member binding
            behaviour here.</param>
            <remarks>If the <paramref name="constructor"/> belongs to an open generic type, then a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
            will be created and registered.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterConstructor(Rezolver.ITargetContainer,System.Reflection.ConstructorInfo,System.Type,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Registers a type by constructor against the service type <paramref name="serviceType"/>.
            </summary>
            <param name="targets"></param>
            <param name="constructor">The constructor to be bound.  The <see cref="P:System.Reflection.MemberInfo.DeclaringType"/> must
            be compatible with the <paramref name="serviceType"/> otherwise an exception will occur.</param>
            <param name="serviceType">The type against which the registration will be made.</param>
            <param name="memberBindingBehaviour">Optional. If you wish to bind members on the new instance, passing a member binding
            behaviour here.</param>
            <remarks>If the <paramref name="constructor"/> belongs to an open generic type, then a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>
            will be created and registered.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterConstructor``1(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)">
            <summary>
            Register a type by constructor (represented by the expression <paramref name="newExpr"/>).
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="targets"></param>
            <param name="newExpr">A lambda expression whose <see cref="P:System.Linq.Expressions.LambdaExpression.Body"/> is a <see cref="T:System.Linq.Expressions.NewExpression"/>
            which identifies the constructor that is to be used to create the instance of <typeparamref name="TObject"/>.</param>
            <param name="memberBindingBehaviour">Optional. If you wish to bind members on the new instance, passing a member binding
            behaviour here.</param>
            <remarks>Note that you can achieve a similar result by simply registering an expression which
            represents a call to a type's constructor.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterConstructor``1(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0}},System.Action{Rezolver.IMemberBindingBehaviourBuilder{``0}})">
             <summary>
             Register a type by constructor (represented by the expression <paramref name="newExpr"/>).
             </summary>
             <typeparam name="TObject"></typeparam>
             <param name="targets"></param>
             <param name="newExpr">A lambda expression whose <see cref="P:System.Linq.Expressions.LambdaExpression.Body"/> is a <see cref="T:System.Linq.Expressions.NewExpression"/>
             which identifies the constructor that is to be used to create the instance of <typeparamref name="TObject"/>.  An exception
             will be thrown if the lambda does not follow this pattern.</param>
             <param name="configureMemberBinding">A callback which configures a custom member binding via the
             <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> interface.  A new builder will be created and passed to this
             callback.</param>
             <remarks>Note that you can achieve a similar result by simply registering an expression which
             represents a call to a type's constructor.
            
             **Generic constructors**
             If you wish to register an open generic type by constructor through the use of an expression, then you
             need to use the <see cref="M:Rezolver.TargetContainerExtensions.RegisterGenericConstructor``1(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)"/>
             overload.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterConstructor``2(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)">
            <summary>
            Register a type by constructor (represented by the expression <paramref name="newExpr"/>)
            to be created when <typeparamref name="TService"/> is requested from the container.
            </summary>
            <typeparam name="TObject">The type whose constructor is to be called</typeparam>
            <typeparam name="TService">The service against which the registration is to be made.  An exception
            will be thrown if the lambda does not follow this pattern.</typeparam>
            <param name="targets"></param>
            <param name="newExpr">A lambda expression whose <see cref="P:System.Linq.Expressions.LambdaExpression.Body"/> is a <see cref="T:System.Linq.Expressions.NewExpression"/>
            which identifies the constructor that is to be used to create the instance of <typeparamref name="TObject"/>.</param>
            <param name="memberBindingBehaviour">Optional. If you wish to bind members on the new instance, passing a member binding
            behaviour here.</param>
            <remarks>Note that you can achieve a similar result by simply registering an expression which
            represents a call to a type's constructor.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterConstructor``2(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0}},System.Action{Rezolver.IMemberBindingBehaviourBuilder{``0}})">
            <summary>
            Register a type by constructor (represented by the expression <paramref name="newExpr"/>)
            to be created when <typeparamref name="TService"/> is requested from the container.
            </summary>
            <typeparam name="TObject">The type whose constructor is to be called</typeparam>
            <typeparam name="TService">The service against which the registration is to be made.  An exception
            will be thrown if the lambda does not follow this pattern.</typeparam>
            <param name="targets"></param>
            <param name="newExpr">A lambda expression whose <see cref="P:System.Linq.Expressions.LambdaExpression.Body"/> is a <see cref="T:System.Linq.Expressions.NewExpression"/>
            which identifies the constructor that is to be used to create the instance of <typeparamref name="TObject"/>.</param>
            <param name="configureMemberBinding">A callback which configures a custom member binding via the
            <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> interface.  A new builder will be created and passed to this
            callback.</param>
            <remarks>Note that you can achieve a similar result by simply registering an expression which
            represents a call to a type's constructor.</remarks>
            <seealso cref="M:Rezolver.Target.ForGenericConstructor``1(System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)"/>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterGenericConstructor``1(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)">
            <summary>
            Creates and registers a target bound to the constructor of a generic type definition using the 
            <see cref="M:Rezolver.Target.ForGenericConstructor``1(System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)"/> factory method. 
            
            See the documentation on that method for more.
            
            The registration will be made against the open generic type.
            </summary>
            <typeparam name="TExample">Must be a generic type which represents a concrete generic whose generic type definition will be
            bound by the created target.  This type is also used as the service type for the registration.</typeparam>
            <param name="targets">The container into which the registration will be made.</param>
            <param name="newExpr">Exemplar expression which is used to identify the constructor to be bound.</param>
            <param name="memberBindingBehaviour">A member binding behaviour to be passed to the created target</param>
            <seealso cref="M:Rezolver.Target.ForGenericConstructor``1(System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)"/>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterGenericConstructor``2(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)">
            <summary>
            Same as <see cref="M:Rezolver.TargetContainerExtensions.RegisterGenericConstructor``1(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)"/>
            except this creates the target and then registers it against a generic base or interface of the generic type definition identified
            from <typeparamref name="TExampleService"/>.
            </summary>
            <typeparam name="TExample">Must be a generic type which represents a concrete generic whose generic type definition will be
            bound by the target that is created and registered.  The type must inherit or implement the type <typeparamref name="TExampleService"/>.</typeparam>
            <typeparam name="TExampleService">Must be a generic type that is a base or interface of <typeparamref name="TExample"/>.  The registration will
            be made against this type's generic type definition.</typeparam>
            <param name="targets">The container into which the registration will be made.</param>
            <param name="newExpr">Exemplar expression which is used to identify the constructor to be bound.</param>
            <param name="memberBindingBehaviour">A member binding behaviour to be passed to the created target</param>
            <seealso cref="M:Rezolver.Target.ForGenericConstructor``1(System.Linq.Expressions.Expression{System.Func{``0}},Rezolver.IMemberBindingBehaviour)"/>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterDelegate(Rezolver.ITargetContainer,System.Delegate,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>
            Constructs a <see cref="T:Rezolver.Targets.DelegateTarget"/> from the passed factory delegate (optionally with the given <paramref name="declaredType"/>,
            <paramref name="scopeBehaviour"/> and <paramref name="scopePreference"/>) and registers it in the target container.
            </summary>
            <param name="targetContainer">The target container in which the new target is to registered</param>
            <param name="factory">The factory delegate that is to be executed by the <see cref="T:Rezolver.Targets.DelegateTarget"/> that is created.</param>
            <param name="declaredType">Optional - if provided, then it overrides the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the <see cref="T:Rezolver.Targets.DelegateTarget"/>
            that is created which, in turn, will change the type against which the target will be registered in the target container.  If null, then
            the return type of the factory will be used.</param>
            <param name="scopeBehaviour">Optional.  Controls how the object generated from the factory delegate will be
            tracked if the target is executed within an <see cref="T:Rezolver.ContainerScope" />.  The default is <see cref="F:Rezolver.ScopeBehaviour.None" /> - which means 
            no disposal will take place.  Be careful with changing this - if the delegate produces new instances each time it's used, then 
            <see cref="F:Rezolver.ScopeBehaviour.Implicit"/> is suitable; if not, then only <see cref="F:Rezolver.ScopeBehaviour.None"/> or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/>
            are suitable.</param>
            <param name="scopePreference">Optional.  If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the
            type of scope in which the instance should be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/>.  <see cref="F:Rezolver.ScopePreference.Root"/>
            should be used if the result of the delegate is effectively a singleton.</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterEventHandler``1(Rezolver.ITargetContainer,Rezolver.ITargetContainerEventHandler{``0})">
            <summary>
            Adds an event handler to the target container for the event type <typeparamref name="TEvent"/>
            </summary>
            <typeparam name="TEvent">The type of event that is to be handled by the handler.</typeparam>
            <param name="targets">Required.  The target container to which the event subscription is being added.</param>
            <param name="handler">Required.  The handler that is to be invoked when the <paramref name="targets"/>
            target container raises an event of type <typeparamref name="TEvent"/></param>
            <remarks>Event handlers are implemented as registrations inside the <paramref name="targets"/> target
            container behind the scenes; as such it is not possible to remove an event handler after adding it.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterExpression(Rezolver.ITargetContainer,System.Linq.Expressions.Expression,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
             <summary>
             Registers the expression in the target container
             </summary>
             <param name="targetContainer">The target container in which the registration will be made.</param>
             <param name="expression">The expression to be registered.</param>
             <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType"/> of the target to be created,
             if different from the <see cref="P:System.Linq.Expressions.Expression.Type"/> of the <paramref name="expression"/> (or its
             <see cref="P:System.Linq.Expressions.LambdaExpression.Body"/> if the expression is a <see cref="T:System.Linq.Expressions.LambdaExpression"/>).
            
             Will also override the type against which the expression will be registered if provided.</param>
             <param name="scopeBehaviour">Optional.  Controls how the object generated from the compiled expression will be
             tracked if the target is executed within an <see cref="T:Rezolver.ContainerScope" />.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
             <param name="scopePreference">Optional.  If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the
             type of scope in which the instance should be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/>.  <see cref="F:Rezolver.ScopePreference.Root"/>
             should be used if the result of the delegate is effectively a singleton.</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterObject``1(Rezolver.ITargetContainer,``0,System.Type,System.Type,Rezolver.ScopeBehaviour)">
            <summary>
            Registers an instance to be used when resolving a particular service type via the <see cref="T:Rezolver.Targets.ObjectTarget"/>
            target.
            </summary>
            <typeparam name="T">Type of the object - will be used as the service type for registration if
            <paramref name="serviceType"/> is not provied.</typeparam>
            <param name="targetContainer">The target container which will receive the registration.</param>
            <param name="obj">The instance that will be resolved when the service type is requested.</param>
            <param name="declaredType">Type to be set as the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the <see cref="T:Rezolver.Targets.ObjectTarget"/> that is
            created for <paramref name="obj"/>, if different from <typeparamref name="T"/>.</param>
            <param name="serviceType">The service type against which this object is to be registered, if different
            from <typeparamref name="T"/>.</param>
            <param name="scopeBehaviour">Sets the <see cref="P:Rezolver.ITarget.ScopeBehaviour"/> for the <see cref="T:Rezolver.Targets.ObjectTarget"/> that's created</param>
            <remarks>By default, the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the <see cref="T:Rezolver.Targets.ObjectTarget"/> that is created is
            fixed to <typeparamref name="T"/> - use the <paramref name="declaredType"/> parameter to override this if <typeparamref name="T"/>
            is a less specific type than the one for which you wish to create a registration.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterObject(Rezolver.ITargetContainer,System.Object,System.Type,System.Type,Rezolver.ScopeBehaviour)">
            <summary>
            Registers an instance to be used when resolve a particular service type via the <see cref="T:Rezolver.Targets.ObjectTarget"/>
            </summary>
            <param name="targetContainer">The target container which will receive the registration.</param>
            <param name="obj">Required, but can be <c>null</c>.  The instance that will be resolved when the service type is requested.</param>
            <param name="declaredType">Type to be set as the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the <see cref="T:Rezolver.Targets.ObjectTarget"/>
            that is created for <paramref name="obj"/>, if different from the object's type.</param>
            <param name="serviceType">The service type against which this object is to be registered, if different
            from <paramref name="declaredType"/> (or the object's type).</param>
            <param name="scopeBehaviour">Sets the <see cref="P:Rezolver.ITarget.ScopeBehaviour"/> for the <see cref="T:Rezolver.Targets.ObjectTarget"/> that's created</param>
            <remarks><c>null</c> objects are implicitly treated as <see cref="T:System.Object"/> if <paramref name="declaredType"/> is not passed.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.SetOption``1(Rezolver.ITargetContainer,``0)">
             <summary>
             Sets the passed <paramref name="option"/> into the <paramref name="targets"/> target container.
            
             The value can later be retrieved through a call to <see cref="M:Rezolver.TargetContainerExtensions.GetOption``1(Rezolver.ITargetContainer,``0)"/>
             or one of its overloads.
             </summary>
             <typeparam name="TOption">The type of option to be set.</typeparam>
             <param name="targets">The target container into which the option will be set.</param>
             <param name="option">The option value to be set</param>
             <returns>The target container on which the method is called, to enable method chaining.</returns>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.SetOption``1(Rezolver.ITargetContainer,``0,System.Type)">
             <summary>
             Sets the passed <paramref name="option"/> into the <paramref name="targets"/> target container, associating
             it with the given <paramref name="serviceType"/>.
            
             The value can later be retrieved through a call to <see cref="M:Rezolver.TargetContainerExtensions.GetOption``2(Rezolver.ITargetContainer,``0)"/>
             or <see cref="M:Rezolver.TargetContainerExtensions.GetOption``1(Rezolver.ITargetContainer,System.Type,``0)"/>, passing the same type, or a derived type.
             </summary>
             <typeparam name="TOption">The type of option to be set.</typeparam>
             <param name="targets">The target container into which the option will be set.</param>
             <param name="option">The option value to be set</param>
             <param name="serviceType">The type against which the option is to be set.  It's called 'serviceType' because the majority
             of the time, you will used this method and its generic overload to customise behaviour for specific types.  If <c>null</c>,
             then it's equivalent to calling <see cref="M:Rezolver.TargetContainerExtensions.SetOption``1(Rezolver.ITargetContainer,``0)"/>.</param>
             <returns>The target container on which the method is called, to enable method chaining.</returns>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.SetOption``2(Rezolver.ITargetContainer,``0)">
             <summary>
             Sets the passed <paramref name="option"/> into the <paramref name="targets"/> target container, associating
             it with the given <typeparamref name="TService"/>.
            
             The value can later be retrieved through a call to <see cref="M:Rezolver.TargetContainerExtensions.GetOption``2(Rezolver.ITargetContainer,``0)"/>
             or <see cref="M:Rezolver.TargetContainerExtensions.GetOption``1(Rezolver.ITargetContainer,System.Type,``0)"/>, passing the same type, or a derived type.
             </summary>
             <typeparam name="TOption">The type of option to be set.</typeparam>
             <typeparam name="TService">The type against which the option is to be set.</typeparam>
             <param name="targets">The target container into which the option will be set.</param>
             <param name="option">The option value to be set</param>
             <returns>The target container on which the method is called, to enable method chaining.</returns>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.SetGenericServiceOption``1(Rezolver.ITargetContainer,``0)">
             <summary>
             Sets an option which will apply to any service type which is generic (either closed or open).
            
             This is a *very* special case which is reserved only for internal functionality at the moment.
             </summary>
             <typeparam name="TOption">The type of option to be set.</typeparam>
             <param name="targets">The target container into which the option is to be set.</param>
             <param name="option">The option value to be set</param>
             <returns>The target container on which the method is called, to enabled method chaining.</returns>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.GetOption``1(Rezolver.ITargetContainer,``0)">
            <summary>
            Gets a globally-defined option of the type <typeparamref name="TOption"/> from the <paramref name="targets"/> target container,
            returning the <paramref name="default"/> if the option has not been explicitly set.
            </summary>
            <typeparam name="TOption">The type of option to retrieve</typeparam>
            <param name="targets">Required. The target container from which the option is to be read.</param>
            <param name="default">The default value to return if the option has not been set.</param>
            <returns>An option value which was either previously set, or the <paramref name="default"/> if not</returns>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.GetOption``1(Rezolver.ITargetContainer,System.Type,``0)">
             <summary>
             Gets an option either specific to the <paramref name="serviceType"/>, or a global option (if <see cref="T:Rezolver.Options.EnableGlobalOptions"/> is
             enabled), of the type <typeparamref name="TOption"/>
             from the <paramref name="targets"/> target container, returning the <paramref name="default"/> if the option has not been explicitly set.
             </summary>
             <typeparam name="TOption">The type of option to retrieve</typeparam>
             <param name="targets">Required. The target container from which the option is to be read.</param>
             <param name="serviceType">A type for which the option is to be retrieved.  Note that the default behaviour is to search for
             an option which is specific to this service, and then to search for more generally-defined options.  See the remarks section for more.</param>
             <param name="default">The default value to return if the option has not been set.</param>
             <returns>An option value which was either previously set, or the <paramref name="default"/> if not</returns>
             <remarks>Options are frequently used to control how a Rezolver container interprets registrations.  Take, for example, the
             <see cref="T:Rezolver.Options.AllowMultiple"/> option - which is used to control whether a target container accepts multiple registrations
             for a given type.
            
             When defined globally (i.e. without a service type) it determines whether multiple registrations can be performed for all types.  However,
             it can also be defined on a per-service basis - so, for example, if you want to restrict an application only to register one target for a
             particular service - e.g. <c>IMyApplication</c> - then you can set the <see cref="T:Rezolver.Options.AllowMultiple"/> option to <c>false</c> specifically against
             that type, and multiple registrations will result in a runtime error.
            
             When searching for service-specific options, generics are automatically processed in descending order of specificity - i.e. <c>IFoo&lt;Bar&gt;</c>
             is more specific than <c>IFoo&lt;&gt;</c> - so you can set options for a specific closed generic, or its open generic.
            
             **Global Fallback**
            
             In the absence of a service-specific option, a globally-defined option will instead be used if the <see cref="T:Rezolver.Options.EnableGlobalOptions"/> option
             is set to <c>true</c> for the <paramref name="targets"/> target container.  By default, this is enabled.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.GetOption``2(Rezolver.ITargetContainer,``0)">
            <summary>
            Generic equivalent of <see cref="M:Rezolver.TargetContainerExtensions.GetOption``1(Rezolver.ITargetContainer,System.Type,``0)"/>.  See documentation on that method for more.
            </summary>
            <typeparam name="TOption">The type of option to retrieve</typeparam>
            <typeparam name="TService">The service type for which the option is to be retrieved</typeparam>
            <param name="targets">That target container from which the option is to be read.</param>
            <param name="default">The default value to be returned if the option is not set.</param>
            <returns>An option value which was either previously set, or the <paramref name="default"/> if not</returns>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.GetOptions``1(Rezolver.ITargetContainer)">
            <summary>
            Gets all globally-defined options of the type <typeparamref name="TOption"/> from the <paramref name="targets"/> target container,
            returning an empty enumerable if none have been set.
            </summary>
            <typeparam name="TOption">The type of option to retrieve</typeparam>
            <param name="targets">Required. The target container from which the options are to be read.</param>
            <returns>An enumerable of the type <typeparamref name="TOption"/> containing zero or more options that have been
            set.</returns>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.GetOptions``1(Rezolver.ITargetContainer,System.Type)">
            <summary>
            Get all options of the type <typeparamref name="TOption"/> which have been set for the service type <paramref name="serviceType"/>
            or any of its derivatives.  Globally-defined options will also be included in the results unless the <see cref="T:Rezolver.Options.EnableGlobalOptions"/>
            option has been set to <c>false</c> on the <paramref name="targets"/> target container.
            </summary>
            <typeparam name="TOption">The type of option to be retrieved</typeparam>
            <param name="targets">Required.  The target container from which the options are to be read.</param>
            <param name="serviceType">Required.  The service type for which options are to be retrieved.</param>
            <returns>An enumerable of the type <typeparamref name="TOption"/> containing zero or more options that have been
            set.</returns>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.GetOptions``2(Rezolver.ITargetContainer)">
            <summary>
            Generic version of the <see cref="M:Rezolver.TargetContainerExtensions.GetOptions``1(Rezolver.ITargetContainer,System.Type)"/> method.  See the documentation on that method
            for more.
            </summary>
            <typeparam name="TOption">The type of option to be retrieved</typeparam>
            <typeparam name="TService">The service type for which options are to be retrieved.</typeparam>
            <param name="targets">Required.  The target container from which the options are to be read.</param>
            <returns>An enumerable of the type <typeparamref name="TOption"/> containing zero or more options that have been
            set.</returns>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterMultiple(Rezolver.ITargetContainer,System.Collections.Generic.IEnumerable{Rezolver.ITarget},System.Type)">
             <summary>
             Called to register multiple targets against the same type.
            
             It is the same as calling <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/> multiple times
             with the different targets.
             </summary>
             <param name="targetContainer">The container on which the registration is to be performed.</param>
             <param name="targets">The targets to be registered - all must support a common service type (potentially
             passed in the <paramref name="commonServiceType"/> argument.</param>
             <param name="commonServiceType">Optional - if provided, then this will be used as the common service type
             for registration.  If not provided, then the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the first target
             will be used.</param>
             <remarks>If the container has the capability to create enumerables automatically (enabled by the
             <see cref="T:Rezolver.Configuration.InjectEnumerables"/> target container behaviour - which is switched on by default)
             then each target will be returned when an IEnumerable of the common service type is requested.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterAll(Rezolver.ITargetContainer,System.Collections.Generic.IEnumerable{Rezolver.ITarget})">
             <summary>
             Batch-registers multiple targets against their <see cref="P:Rezolver.ITarget.DeclaredType"/>.
            
             This is the same as calling <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/> for each of the
             <paramref name="targets"/>, except the type cannot be overriden from the target's DeclaredType.
             </summary>
             <param name="targetContainer">The target container on which the registrations are to be performed.</param>
             <param name="targets">The targets to be registered</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterAll(Rezolver.ITargetContainer,Rezolver.ITarget[])">
            <summary>
            Performs the same operations as <see cref="M:Rezolver.TargetContainerExtensions.RegisterAll(Rezolver.ITargetContainer,System.Collections.Generic.IEnumerable{Rezolver.ITarget})"/> except
            via a variable number of <see cref="T:Rezolver.ITarget"/> arguments.
            </summary>
            <param name="targetContainer">The target container on which the registrations are to be performed.</param>
            <param name="targets">The targets to be registered.</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterType``1(Rezolver.ITargetContainer,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Registers the type <typeparamref name="TObject"/> to be created by a <see cref="T:Rezolver.Container"/> via constructor injection.
            The registration will auto-bind a constructor based on the services available in the <see cref="T:Rezolver.ITargetContainer"/> and
            <see cref="T:Rezolver.Container"/> available at the time <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> is first called.
            </summary>
            <typeparam name="TObject">The type of the object that is to be constructed when resolved.  Also doubles up as the type to be
            used for the registration itself.</typeparam>
            <param name="targetContainer">The target container on which the registration is to be performed.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on the <paramref name="targetContainer"/>.</param>
            <remarks>This is equivalent to creating either a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> via
            the <see cref="M:Rezolver.Target.ForType``1(Rezolver.IMemberBindingBehaviour)"/> static method and then registering it.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterType``2(Rezolver.ITargetContainer,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Registers the type <typeparamref name="TObject"/> for the service type <typeparamref name="TService"/> to be created by
            an <see cref="T:Rezolver.Container"/> via constructor injection.
            The registration will auto-bind a constructor based on the services available in the <see cref="T:Rezolver.ITargetContainer"/> and
            <see cref="T:Rezolver.Container"/> available at the time <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> is first called.
            </summary>
            <typeparam name="TObject">The type of the object that is to be constructed when resolved.</typeparam>
            <typeparam name="TService">The type against which the registration will be performed.  <typeparamref name="TObject"/> must be
            compatible with this type.</typeparam>
            <param name="targetContainer">The target container on which the registration is to be performed.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on the <paramref name="targetContainer"/>.</param>
            <remarks>This is equivalent to creating either a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> via
            the <see cref="M:Rezolver.Target.ForType``1(Rezolver.IMemberBindingBehaviour)"/> static method and then registering it against
            the type <typeparamref name="TService"/>.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterType(Rezolver.ITargetContainer,System.Type,System.Type,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Registers the type <paramref name="objectType"/> (optionally for the service type <paramref name="serviceType"/>) to be
            created by an <see cref="T:Rezolver.Container"/> via constructor injection.
            The registration will auto-bind a constructor based on the services available in the <see cref="T:Rezolver.ITargetContainer"/> and
            <see cref="T:Rezolver.Container"/> available at the time <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> is first called.
            </summary>
            <param name="targetContainer">The target container on which the registration is to be performed.</param>
            <param name="objectType">The type of the object that is to be constructed when resolved.</param>
            <param name="serviceType">Optional.  The type against which the registration will be performed, if different from
            <paramref name="objectType"/>.  <paramref name="objectType"/> must be compatible with this type, if it's provided.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on the <paramref name="targetContainer"/>.</param>
            <remarks>This is equivalent to creating either a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> via
            the <see cref="M:Rezolver.Target.ForType(System.Type,Rezolver.IMemberBindingBehaviour)"/> static method and then registering it against
            the type <paramref name="serviceType"/> or <paramref name="objectType"/>.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterType``1(Rezolver.ITargetContainer,System.Action{Rezolver.IMemberBindingBehaviourBuilder{``0}})">
            <summary>
            Register the type <typeparamref name="TObject"/> to be created by the container via constructor injection, with an <see cref="T:Rezolver.IMemberBindingBehaviour"/>
            that's built from an <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/> that's configure by a callback you provide.
            </summary>
            <typeparam name="TObject">The type to be registered and created.</typeparam>
            <param name="targets">The target container on which the registration is to be performed.</param>
            <param name="configureMemberBinding">A callback that will be invoked with a new <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/>
            object that you can use to configure a custom member binding behaviour for the type <typeparamref name="TObject"/>.  The
            <see cref="M:Rezolver.IMemberBindingBehaviourBuilder`1.BuildBehaviour"/> method will be called after executing your callback to
            obtain the final <see cref="T:Rezolver.IMemberBindingBehaviour"/>.</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterType``2(Rezolver.ITargetContainer,System.Action{Rezolver.IMemberBindingBehaviourBuilder{``0}})">
            <summary>
            Same as the <see cref="M:Rezolver.TargetContainerExtensions.RegisterType``1(Rezolver.ITargetContainer,System.Action{Rezolver.IMemberBindingBehaviourBuilder{``0}})"/> method, except this
            creates a registration for <typeparamref name="TService"/> that will be implemented by instances of the type <typeparamref name="TObject"/>,
            created via constructor injection.
            </summary>
            <typeparam name="TObject"></typeparam>
            <typeparam name="TService"></typeparam>
            <param name="targets">The target container on which the registration is to be performed.</param>
            <param name="configureMemberBinding">A callback that will be invoked with a new <see cref="T:Rezolver.IMemberBindingBehaviourBuilder`1"/>
            object that you can use to configure a custom member binding behaviour for the type <typeparamref name="TObject"/>.  The
            <see cref="M:Rezolver.IMemberBindingBehaviourBuilder`1.BuildBehaviour"/> method will be called after executing your callback to
            obtain the final <see cref="T:Rezolver.IMemberBindingBehaviour"/>.</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterScoped``1(Rezolver.ITargetContainer,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Registers an explicitly scoped instance of <typeparamref name="TObject"/> to be created by an <see cref="T:Rezolver.Container"/> via
            constructor injection.
            The registration will auto-bind a constructor based on the services available in the <see cref="T:Rezolver.ITargetContainer"/> and
            <see cref="T:Rezolver.Container"/> available at the time <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> is first called.
            </summary>
            <typeparam name="TObject">The type of the object that is to be constructed when resolved.  Also doubles up as the type to be
            used for the registration itself.</typeparam>
            <param name="targetContainer">The target container on which the registration is to be performed.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on the <paramref name="targetContainer"/>.</param>
            <remarks>This is equivalent to creating either a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> via
            the <see cref="M:Rezolver.Target.ForType``1(Rezolver.IMemberBindingBehaviour)"/> static method, wrapping it with a
            <see cref="T:Rezolver.Targets.ScopedTarget"/> and registering it.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterScoped``2(Rezolver.ITargetContainer,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Registers an explicitly scoped instance of <typeparamref name="TObject"/> for the service type <typeparamref name="TService"/>
            to be created by an <see cref="T:Rezolver.Container"/> via constructor injection.
            The registration will auto-bind a constructor based on the services available in the <see cref="T:Rezolver.ITargetContainer"/> and
            <see cref="T:Rezolver.Container"/> available at the time <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> is first called.
            </summary>
            <typeparam name="TObject">The type of the object that is to be constructed when resolved.</typeparam>
            <typeparam name="TService">The type against which the registration will be performed.  <typeparamref name="TObject"/> must be
            compatible with this type.</typeparam>
            <param name="targetContainer">The target container on which the registration is to be performed.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on the <paramref name="targetContainer"/>.</param>
            <remarks>This is equivalent to creating either a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> via
            the <see cref="M:Rezolver.Target.ForType``1(Rezolver.IMemberBindingBehaviour)"/> static method, wrapping it with a
            <see cref="T:Rezolver.Targets.ScopedTarget"/> and then registering it against
            the type <typeparamref name="TService"/>.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterScoped(Rezolver.ITargetContainer,System.Type,System.Type,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Registers an explicitly instance of <paramref name="objectType"/> (optionally for the service type <paramref name="serviceType"/>) to be
            created by an <see cref="T:Rezolver.Container"/> via constructor injection.
            The registration will auto-bind a constructor based on the services available in the <see cref="T:Rezolver.ITargetContainer"/> and
            <see cref="T:Rezolver.Container"/> available at the time <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> is first called.
            </summary>
            <param name="targetContainer">The target container on which the registration is to be performed.</param>
            <param name="objectType">The type of the object that is to be constructed when resolved.</param>
            <param name="serviceType">Optional.  The type against which the registration will be performed, if different from
            <paramref name="objectType"/>.  <paramref name="objectType"/> must be compatible with this type, if it's provided.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
            if different from the behaviour configured via options on the <paramref name="targetContainer"/>.</param>
            <remarks>This is equivalent to creating either a <see cref="T:Rezolver.Targets.ConstructorTarget"/> or <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> via
            the <see cref="M:Rezolver.Target.ForType(System.Type,Rezolver.IMemberBindingBehaviour)"/> static method, wrapping it with a <see cref="T:Rezolver.Targets.ScopedTarget"/>
            and then registering it against the type <paramref name="serviceType"/> or <paramref name="objectType"/>.</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterSingleton``1(Rezolver.ITargetContainer,Rezolver.IMemberBindingBehaviour)">
             <summary>
             Registers the type <typeparamref name="TObject"/> as a singleton (<see cref="T:Rezolver.Targets.SingletonTarget"/>) in the target container.
            
             The instance will be built automatically with constructor injection by leveraging either the <see cref="T:Rezolver.Targets.ConstructorTarget"/> or
             <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>, depending on whether <typeparamref name="TObject"/> is a generic type or not.
             </summary>
             <typeparam name="TObject">The type to be created, and the type against which the registration will be made</typeparam>
             <param name="targetContainer">The container on which the registrations will be made.</param>
             <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
             if different from the behaviour configured via options on the <paramref name="targetContainer"/>.</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterSingleton``2(Rezolver.ITargetContainer,Rezolver.IMemberBindingBehaviour)">
             <summary>
             Registers the type <typeparamref name="TObject"/> as a singleton (<see cref="T:Rezolver.Targets.SingletonTarget"/>) in the target container
             for the service type <typeparamref name="TService"/>.
            
             The instance will be built automatically with constructor injection by leveraging either the <see cref="T:Rezolver.Targets.ConstructorTarget"/> or
             <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>, depending on whether <typeparamref name="TObject"/> is a generic type or not.
             </summary>
             <typeparam name="TObject">The type of object to be created.</typeparam>
             <typeparam name="TService">The type against which the target will be registered in the <paramref name="targetContainer"/></typeparam>
             <param name="targetContainer">The container on which the registrations will be made.</param>
             <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
             if different from the behaviour configured via options on the <paramref name="targetContainer"/>.</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterSingleton(Rezolver.ITargetContainer,System.Type,System.Type,Rezolver.IMemberBindingBehaviour)">
             <summary>
             Registers the type <paramref name="objectType"/> as a singleton (<see cref="T:Rezolver.Targets.SingletonTarget"/>) in the target container,
             either for the same service type, or for the service type passed to the <paramref name="serviceType"/> parameter (if provided).
            
             The instance will be built automatically with constructor injection by leveraging either the <see cref="T:Rezolver.Targets.ConstructorTarget"/> or
             <see cref="T:Rezolver.Targets.GenericConstructorTarget"/>, depending on whether <paramref name="objectType"/> is a generic type or not.
             </summary>
             <param name="targetContainer">The container on which the registrations will be made.</param>
             <param name="objectType">Required.  The type of object to be created.</param>
             <param name="serviceType">Optional.  The type against which the target will be registered in the <paramref name="targetContainer"/></param>
             <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance,
             if different from the behaviour configured via options on the <paramref name="targetContainer"/>.</param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterDelegate``1(Rezolver.ITargetContainer,System.Func{``0},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers a <see cref="T:Rezolver.Targets.DelegateTarget" /> built from a parameterless factory delegate 
            which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="factory">Required.  The factory delegate which is to be executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Optional.  Controls how the object generated from the factory delegate will be
            tracked if the target is executed within an <see cref="T:Rezolver.ContainerScope" />.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterDelegate``1(Rezolver.ITargetContainer,System.Func{Rezolver.ResolveContext,``0},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers a <see cref="T:Rezolver.Targets.DelegateTarget" /> built from a factory delegate which takes an 
            <see cref="T:Rezolver.ResolveContext" /> and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="factory">Required.  The factory delegate which is to be executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Optional.  Controls how the object generated from the factory delegate will be
            tracked if the target is executed within an <see cref="T:Rezolver.ContainerScope" />.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterDelegate``2(Rezolver.ITargetContainer,System.Func{``0,``1},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers a <see cref="T:Rezolver.Targets.DelegateTarget" /> built from a factory delegate which takes 1 argument
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="factory">Required.  The factory delegate which is to be executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Optional.  Controls how the object generated from the factory delegate will be
            tracked if the target is executed within an <see cref="T:Rezolver.ContainerScope" />.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterDelegate``3(Rezolver.ITargetContainer,System.Func{``0,``1,``2},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers a <see cref="T:Rezolver.Targets.DelegateTarget" /> built from a factory delegate which takes 2 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="T2">Type of the 2nd delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="factory">Required.  The factory delegate which is to be executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Optional.  Controls how the object generated from the factory delegate will be
            tracked if the target is executed within an <see cref="T:Rezolver.ContainerScope" />.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterDelegate``4(Rezolver.ITargetContainer,System.Func{``0,``1,``2,``3},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers a <see cref="T:Rezolver.Targets.DelegateTarget" /> built from a factory delegate which takes 3 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="T2">Type of the 2nd delegate parameter</typeparam>
            <typeparam name="T3">Type of the 3rd delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="factory">Required.  The factory delegate which is to be executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Optional.  Controls how the object generated from the factory delegate will be
            tracked if the target is executed within an <see cref="T:Rezolver.ContainerScope" />.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterDelegate``5(Rezolver.ITargetContainer,System.Func{``0,``1,``2,``3,``4},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers a <see cref="T:Rezolver.Targets.DelegateTarget" /> built from a factory delegate which takes 4 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="T2">Type of the 2nd delegate parameter</typeparam>
            <typeparam name="T3">Type of the 3rd delegate parameter</typeparam>
            <typeparam name="T4">Type of the 4th delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="factory">Required.  The factory delegate which is to be executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Optional.  Controls how the object generated from the factory delegate will be
            tracked if the target is executed within an <see cref="T:Rezolver.ContainerScope" />.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterDelegate``6(Rezolver.ITargetContainer,System.Func{``0,``1,``2,``3,``4,``5},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers a <see cref="T:Rezolver.Targets.DelegateTarget" /> built from a factory delegate which takes 5 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st delegate parameter</typeparam>
            <typeparam name="T2">Type of the 2nd delegate parameter</typeparam>
            <typeparam name="T3">Type of the 3rd delegate parameter</typeparam>
            <typeparam name="T4">Type of the 4th delegate parameter</typeparam>
            <typeparam name="T5">Type of the 5th delegate parameter</typeparam>
            <typeparam name="TResult">The type of the object produced by the factory delegate.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="factory">Required.  The factory delegate which is to be executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Optional.  Controls how the object generated from the factory delegate will be
            tracked if the target is executed within an <see cref="T:Rezolver.ContainerScope" />.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit" />.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterExpression``1(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers an <see cref="T:Rezolver.Targets.ExpressionTarget" /> built from a parameterless lambda expression 
            which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="lambda">Required.  The lambda expression which is to be compiled and executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterExpression``1(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{Rezolver.ResolveContext,``0}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers an <see cref="T:Rezolver.Targets.ExpressionTarget" /> built from a lambda expression which takes an 
            <see cref="T:Rezolver.ResolveContext" /> and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="lambda">Required.  The lambda expression which is to be compiled and executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterExpression``2(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers an <see cref="T:Rezolver.Targets.ExpressionTarget" /> built from a lambda expression which takes 1 argument
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="lambda">Required.  The lambda expression which is to be compiled and executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterExpression``3(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers an <see cref="T:Rezolver.Targets.ExpressionTarget" /> built from a lambda expression which takes 2 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="T2">Type of the 2nd parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="lambda">Required.  The lambda expression which is to be compiled and executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterExpression``4(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers an <see cref="T:Rezolver.Targets.ExpressionTarget" /> built from a lambda expression which takes 3 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="T2">Type of the 2nd parameter of the lambda expression.</typeparam>
            <typeparam name="T3">Type of the 3rd parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="lambda">Required.  The lambda expression which is to be compiled and executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterExpression``5(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers an <see cref="T:Rezolver.Targets.ExpressionTarget" /> built from a lambda expression which takes 4 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="T2">Type of the 2nd parameter of the lambda expression.</typeparam>
            <typeparam name="T3">Type of the 3rd parameter of the lambda expression.</typeparam>
            <typeparam name="T4">Type of the 4th parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="lambda">Required.  The lambda expression which is to be compiled and executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="M:Rezolver.TargetContainerExtensions.RegisterExpression``6(Rezolver.ITargetContainer,System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5}},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>Registers an <see cref="T:Rezolver.Targets.ExpressionTarget" /> built from a lambda expression which takes 5 arguments
            and which returns an instance of <typeparamref name="TResult" /></summary>
            <typeparam name="T1">Type of the 1st parameter of the lambda expression.</typeparam>
            <typeparam name="T2">Type of the 2nd parameter of the lambda expression.</typeparam>
            <typeparam name="T3">Type of the 3rd parameter of the lambda expression.</typeparam>
            <typeparam name="T4">Type of the 4th parameter of the lambda expression.</typeparam>
            <typeparam name="T5">Type of the 5th parameter of the lambda expression.</typeparam>
            <typeparam name="TResult">The return type of the lambda expression.</typeparam>
            <param name="targets">Required.  The <see cref="T:Rezolver.ITargetContainer" /> into which the newly created target will be registered</param>
            <param name="lambda">Required.  The lambda expression which is to be compiled and executed when an instance is resolved by a container</param>
            <param name="declaredType">Optional.  The <see cref="P:Rezolver.ITarget.DeclaredType" /> of the target to be created
            if different from <typeparamref name="TResult" />.  Also overrides the type against which the registration will be made.</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks>All arguments to the lambda are injected from the container when compiled and executed</remarks>
        </member>
        <member name="T:Rezolver.TargetDictionaryContainer">
             <summary>
             An <see cref="T:Rezolver.ITargetContainer"/> implementation that stores and retrieves
             <see cref="T:Rezolver.ITarget"/> and <see cref="T:Rezolver.ITargetContainer"/> by service type.
             </summary>
             <remarks>
             This class stores <see cref="T:Rezolver.ITarget"/> instances inside child <see cref="T:Rezolver.ITargetContainer"/> instances that are registered
             against types equal, or related, to the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the target.
            
             When <see cref="M:Rezolver.TargetDictionaryContainer.Register(Rezolver.ITarget,System.Type)"/> is called, an <see cref="T:Rezolver.ITargetContainer"/> is looked up which will 'own' that target.
             If one is not found, then one will be created and automatically registered (via <see cref="M:Rezolver.TargetDictionaryContainer.EnsureContainer(System.Type)"/>.
            
             With a (possibly new) child target container in hand, the registration is then delegated to that target container.
             </remarks>
        </member>
        <member name="P:Rezolver.TargetDictionaryContainer.Root">
            <summary>
            Never null.  Returns the root target container.
            </summary>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.#ctor(Rezolver.IRootTargetContainer)">
            <summary>
            Constructs a new <see cref="T:Rezolver.TargetDictionaryContainer"/> optionally setting the <see cref="P:Rezolver.TargetDictionaryContainer.Root"/> target container.
            </summary>
            <param name="root">If this container belongs to one overarching root container (typically an instance of
            <see cref="T:Rezolver.TargetContainer"/> or <see cref="T:Rezolver.OverridingTargetContainer"/>), then pass it here.</param>
            <remarks>The importance of the <paramref name="root"/> target container is to enable code to be able to reach all
            registrations for all services rather than only those which are stored within this container, because this type is used
            both as a root, but also for other more specialised target containers.</remarks>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.Fetch(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainer.Fetch(System.Type)"/>.
            </summary>
            <param name="type">The type whose default target is to be retrieved.</param>
            <returns>A single target representing the last target registered against the
            <paramref name="type"/>, or, null if no target is found.</returns>
            <remarks>Note - in scenarios where you are chaining multiple containers, then
            you should consult the return value's <see cref="P:Rezolver.ITarget.UseFallback"/> property
            if the method returns non-null because, if true, then it's an instruction to
            use a parent container's result for the same type.</remarks>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.FetchAll(System.Type)">
            <summary>
            Implementation of <see cref="M:Rezolver.ITargetContainer.FetchAll(System.Type)"/>
            </summary>
            <param name="type">The type whose targets are to be retrieved.</param>
            <returns>A non-null enumerable containing the targets that match the type, or an
            empty enumerable if the type is not registered.</returns>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.FetchContainer(System.Type)">
             <summary>
             Obtains the child container which owns the given <paramref name="serviceType"/> on behalf
             of this target container.
            
             Returns null if no entry is found.
             </summary>
             <param name="serviceType">The service type whose owning <see cref="T:Rezolver.ITargetContainer"/> is sought.</param>
             <returns>The target container which manages the given service type, if one is registered - otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)">
             <summary>
             Implementation of <see cref="M:Rezolver.ITargetContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)" />
             </summary>
             <param name="type"></param>
             <param name="container"></param>
             <remarks>This container implementation actually stores containers against the types that targets are registered
             against, rather than simply storing a dictionary of targets.  This method allows you to add your own containers
             against type (instead of the default, which is <see cref="T:Rezolver.TargetListContainer"/>) so you can plug in some advanced
             behaviour into this container.
            
             For example, decorators are not actually <see cref="T:Rezolver.ITarget"/> implementations but specialised <see cref="T:Rezolver.ITargetContainer"/>
             instances into which the 'standard' targets are registered.</remarks>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.Register(Rezolver.ITarget,System.Type)">
             <summary>
             Implementation of <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/>.
             </summary>
             <param name="target">The target to be registered</param>
             <param name="serviceType">The service type against which the <paramref name="target"/> is to be registered, if
             different from the target's <see cref="P:Rezolver.ITarget.DeclaredType"/>.</param>
             <remarks>This implementation creates a child <see cref="T:Rezolver.ITargetContainer"/> for the <paramref name="serviceType"/>
             with a call to the protected method <see cref="M:Rezolver.TargetDictionaryContainer.EnsureContainer(System.Type)"/> if one doesn't already exist.
            
             The registration is then delegated to that child container's own implementation of
             <see cref="M:Rezolver.ITargetContainer.Register(Rezolver.ITarget,System.Type)"/>.</remarks>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.EnsureContainer(System.Type)">
             <summary>
             Called to make sure that an <see cref="T:Rezolver.ITargetContainer"/> has been registered which can act as
             owner to targets whose <see cref="P:Rezolver.ITarget.DeclaredType"/> is equal to the passed <paramref name="serviceType"/>
             so that a target or target container can be registered.
             </summary>
             <param name="serviceType">Required. The service type against which a target registration is to be made (and for
             which a target container is required.</param>
             <returns>A child target container into which targets, or another child target container, can be registered.</returns>
             <remarks>
             An existing container is returned if <see cref="M:Rezolver.TargetDictionaryContainer.FetchContainer(System.Type)"/> returns it.  If not, then a new container
             is created and registered via the <see cref="M:Rezolver.TargetDictionaryContainer.AutoRegisterContainer(System.Type)"/> method, and returned.
            
             Note that the <paramref name="serviceType"/> will possibly be mapped to a different container type via any
             <see cref="T:Rezolver.ITargetContainerTypeResolver"/> that's registered via the options API.</remarks>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.AutoRegisterContainer(System.Type)">
             <summary>
             Called by <see cref="M:Rezolver.TargetDictionaryContainer.Register(Rezolver.ITarget,System.Type)"/> to create and register the container
             instance most suited for the passed target.  The base implementation
             always creates a <see cref="T:Rezolver.TargetListContainer"/>, capable of storing multiple targets
             against a single type.</summary>
             <param name="targetContainerType">The type that the target container is to be registered under.
            
             Note that this type will *not* be remapped by the <see cref="M:Rezolver.TargetDictionaryContainer.GetRegisteredContainerType(System.Type)"/> method -
             it will be used as-is.</param>
             <returns></returns>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.GetRegisteredContainerType(System.Type)">
            <summary>
            Called to get the type that's to be used to fetch a child <see cref="T:Rezolver.ITargetContainer"/> for targets registered
            against a given <paramref name="serviceType"/>.
            </summary>
            <param name="serviceType">The service type - usually pulled from the <see cref="P:Rezolver.ITarget.DeclaredType"/> of a
            <see cref="T:Rezolver.ITarget"/> that is to be registered, or the service type passed to <see cref="M:Rezolver.TargetDictionaryContainer.Fetch(System.Type)"/>.</param>
            <returns>The base implementation always returns the <paramref name="serviceType"/></returns>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.CreateTargetContainer(System.Type)">
            <summary>
            Called to create a new container instance which will be
            </summary>
            <param name="targetContainerType"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.TargetDictionaryContainer.CombineWith(Rezolver.ITargetContainer,System.Type)">
            <summary>
            Not supported by default
            </summary>
            <param name="existing"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.TargetListContainer">
             <summary>
             An <see cref="T:Rezolver.ITargetContainer"/> that stores multiple targets in a list.
            
             This is not a type that you would typically use directly in your code, unless you are writing
             custom logic/behaviour for <see cref="T:Rezolver.ITarget"/> registration.
             </summary>
             <remarks>
             This type is not thread-safe, nor does it perform any type checking on the targets
             that are added to it.
             </remarks>
        </member>
        <member name="P:Rezolver.TargetListContainer.RegisteredType">
            <summary>
            Gets the type against which this list container is registered in its <see cref="T:Rezolver.ITargetContainer"/>.
            </summary>
        </member>
        <member name="P:Rezolver.TargetListContainer.DefaultTarget">
            <summary>
            Gets the default target for this list - which will always be the last target added to the list, or
            <c>null</c> if no targets have been added yet.
            </summary>
        </member>
        <member name="P:Rezolver.TargetListContainer.Count">
            <summary>
            Gets the number of targets which have been added to the list.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:Rezolver.TargetListContainer.Root">
            <summary>
            The root target container.  Implementation of <see cref="P:Rezolver.ITargetContainer.Root"/>
            </summary>
        </member>
        <member name="M:Rezolver.TargetListContainer.#ctor(Rezolver.IRootTargetContainer,System.Type,Rezolver.ITarget[])">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.TargetListContainer"/> class.
            </summary>
            <param name="root">The root target container in which this container is registered.</param>
            <param name="registeredType">Required - the type against which this list will be registered.</param>
            <param name="targets">Optional array of targets with which to initialise the list.</param>
        </member>
        <member name="M:Rezolver.TargetListContainer.Register(Rezolver.ITarget,System.Type)">
            <summary>
            Registers the specified target into the list.  Note - the target is not checked to see
            if it supports this list's <see cref="P:Rezolver.TargetListContainer.RegisteredType"/>.
            </summary>
            <param name="target">The target.</param>
            <param name="registeredType">Ignored.</param>
        </member>
        <member name="M:Rezolver.TargetListContainer.Fetch(System.Type)">
            <summary>
            Returns the first target which supports the passed <paramref name="type"/>
            </summary>
            <param name="type">The type for which a target is sought.</param>
        </member>
        <member name="M:Rezolver.TargetListContainer.FetchAll(System.Type)">
            <summary>
            Retrieves an enumerable of all targets that have been registered to this list.
            </summary>
            <param name="type">Ignored.</param>
        </member>
        <member name="M:Rezolver.TargetListContainer.CombineWith(Rezolver.ITargetContainer,System.Type)">
            <summary>
            Not supported.
            </summary>
            <param name="existing">Ignored</param>
            <param name="type">Ignored.</param>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="M:Rezolver.TargetListContainer.FetchContainer(System.Type)">
            <summary>
            Not supported by this target container.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.TargetListContainer.RegisterContainer(System.Type,Rezolver.ITargetContainer)">
            <summary>
            Not supported by this target container
            </summary>
            <param name="type"></param>
            <param name="container"></param>
        </member>
        <member name="M:Rezolver.TargetListContainer.IndexOf(Rezolver.ITarget)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IList`1.IndexOf(`0)"/>
            </summary>
            <param name="item">The item whose index is to be found</param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.TargetListContainer.Insert(System.Int32,Rezolver.ITarget)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)"/>
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Rezolver.TargetListContainer.RemoveAt(System.Int32)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)"/>
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Rezolver.TargetListContainer.Add(Rezolver.ITarget)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Rezolver.TargetListContainer.Clear">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.Clear"/>
            </summary>
        </member>
        <member name="M:Rezolver.TargetListContainer.Contains(Rezolver.ITarget)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.TargetListContainer.CopyTo(Rezolver.ITarget[],System.Int32)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Rezolver.TargetListContainer.Remove(Rezolver.ITarget)">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Rezolver.TargetListContainer.GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rezolver.TargetListContainer.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Targets.AutoFactoryTarget">
            <summary>
            A target that builds a delegate (potentially parameterised) by wrapping another target, typically
            resolved from the container.
            
            When the delegate is executed, the delegate will execute the same code as would've been executed
            had the dependency from the inner target been directly injected.  This allows applications which use factory delegates 
            to build components to use Rezolver containers as the mechanism for doing this directly instead of having
            to resort to mechanisms such as <see cref="T:System.IServiceProvider"/> etc.
            </summary>
            <remarks>This is used to implement the [Autofactories functionality](/developers/docs/autofactories.html).</remarks>
        </member>
        <member name="P:Rezolver.Targets.AutoFactoryTarget.DeclaredType">
            <summary>
            The delegate type that will be built by this target - always equal to <see cref="P:Rezolver.Targets.AutoFactoryTarget.DeclaredType"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.AutoFactoryTarget.BoundTarget">
            <summary>
            If the target is already bound to another target (e.g. <see cref="T:Rezolver.Targets.ConstructorTarget"/>), then this
            will be it.  
            
            Note that the compiler should always call the <see cref="M:Rezolver.Targets.AutoFactoryTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method
            in any case to get the inner target.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.AutoFactoryTarget.ReturnType">
            <summary>
            The return type of the <see cref="P:Rezolver.Targets.AutoFactoryTarget.DeclaredType"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.AutoFactoryTarget.ParameterTypes">
            <summary>
            An array of types of the arguments that are accepted by delegates of the type <see cref="P:Rezolver.Targets.AutoFactoryTarget.DeclaredType"/>,
            or, an empty array if the the delegate is nullary.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.AutoFactoryTarget.ScopeBehaviour">
            <summary>
            Overrides the property always to return <see cref="F:Rezolver.ScopeBehaviour.None"/> by default.
            </summary>
        </member>
        <member name="M:Rezolver.Targets.AutoFactoryTarget.#ctor(System.Type,Rezolver.ITarget)">
            <summary>
            Creates a new <see cref="T:Rezolver.Targets.AutoFactoryTarget"/> for the given <paramref name="delegateType"/>, optionally already bound
            to the given <paramref name="boundTarget"/>.
            </summary>
            <param name="delegateType">Required.  The type of delegate that is to be produced by this target.  It MUST have a non-void return type.</param>
            <param name="boundTarget">Optional.  The target whose result is to be wrapped by the delegate.</param>
        </member>
        <member name="M:Rezolver.Targets.AutoFactoryTarget.SupportsType(System.Type)">
            <summary>
            Overrides the base implementation to enhance support for closed generics where
            the <see cref="P:Rezolver.Targets.AutoFactoryTarget.DeclaredType"/> is an open generic.
            </summary>
            <param name="type">The type.</param>
            <returns><c>true</c> if this target can build an instance of the <paramref name="type"/>, otherwise <c>false</c></returns>
        </member>
        <member name="M:Rezolver.Targets.AutoFactoryTarget.Bind(Rezolver.Compilation.ICompileContext)">
            <summary>
            Returns the <see cref="T:Rezolver.ITarget"/> that should be compiled as the body of the delegate.  If <see cref="P:Rezolver.Targets.AutoFactoryTarget.BoundTarget"/>
            is not null and its <see cref="P:Rezolver.ITarget.UseFallback"/> is false, then no binding is performed.
            
            Otherwise, a suitable target is sought from the <paramref name="compileContext"/>.  If not found, then
            a <see cref="T:Rezolver.Targets.ResolvedTarget"/> is emitted with a fallback set to the <see cref="P:Rezolver.Targets.AutoFactoryTarget.BoundTarget"/> if non-null,
            meaning that the delegate will actually perform a late-bound resolve operation on the container on which it's
            called.
            </summary>
            <param name="compileContext">The current compilation context, this is used to resolve the target to be bound.</param>
            <returns>The target to be compiled as the body of the factory.</returns>
        </member>
        <member name="T:Rezolver.Targets.ChangeTypeTarget">
             <summary>
             This target is specifically used for explicitly casting the result of one target to another type.
             Its use is rare, since the framework already caters for downcasting the result of targets to
             base types.
             </summary>
             <remarks>
             A valid use of this target is when you have a <see cref="T:Rezolver.Targets.SingletonTarget"/> registered against one
             type, and you want the same singleton (backed by the same instance) to server another type.
            
             In this case, instead of registering the same singleton target multiple times, you can register it once
             for its primary type, then register one of these for the other type, with a <see cref="T:Rezolver.Targets.ResolvedTarget"/>
             as its inner target.
            
             When creating this target, the <see cref="P:Rezolver.ITarget.DeclaredType"/> of the <see cref="P:Rezolver.Targets.ChangeTypeTarget.InnerTarget"/> must
             be able to cast up or down to the <see cref="P:Rezolver.Targets.ChangeTypeTarget.DeclaredType"/> of this target.
             </remarks>
        </member>
        <member name="P:Rezolver.Targets.ChangeTypeTarget.ScopeBehaviour">
            <summary>
            Always returns <see cref="F:Rezolver.ScopeBehaviour.None"/>
            </summary>
            <value>The scope behaviour.</value>
        </member>
        <member name="P:Rezolver.Targets.ChangeTypeTarget.DeclaredType">
            <summary>
            Always returns the target type that was passed in the <see cref="M:Rezolver.Targets.ChangeTypeTarget.#ctor(Rezolver.ITarget,System.Type)"/> constructor.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ChangeTypeTarget.InnerTarget">
            <summary>
            The target whose type will be changed to <see cref="P:Rezolver.Targets.ChangeTypeTarget.DeclaredType"/>.
            </summary>
        </member>
        <member name="M:Rezolver.Targets.ChangeTypeTarget.#ctor(Rezolver.ITarget,System.Type)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.Targets.ChangeTypeTarget"/> class.
            </summary>
            <param name="innerTarget">Required.  See <see cref="P:Rezolver.Targets.ChangeTypeTarget.InnerTarget"/></param>
            <param name="targetType">Required.  See <see cref="P:Rezolver.Targets.ChangeTypeTarget.DeclaredType"/></param>
        </member>
        <member name="T:Rezolver.Targets.ConstructorTarget">
             <summary>
             A target that binds to a type's constructor with zero or more arguments supplied by other <see cref="T:Rezolver.ITarget"/>s and, optionally
             binding to the new instance's writeable properties.
            
             The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the
             available services and/or any named arguments which might been provided up front.
             </summary>
             <remarks>Although you can create this target directly through the
             <see cref="M:Rezolver.Targets.ConstructorTarget.#ctor(System.Type,System.Reflection.ConstructorInfo,Rezolver.IMemberBindingBehaviour,Rezolver.ParameterBinding[],System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget})"/> constructor,
             you're more likely to create it through factory methods such as <see cref="M:Rezolver.Target.ForType``1(Rezolver.IMemberBindingBehaviour)"/> or, more likely still,
             extension methods such as <see cref="M:Rezolver.TargetContainerExtensions.RegisterType``2(Rezolver.ITargetContainer,Rezolver.IMemberBindingBehaviour)"/> during
             your application's container setup phase.
            
             To compile this target, an <see cref="T:Rezolver.Compilation.ITargetCompiler"/> should first call the <see cref="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method,
             which will select the correct constructor to be bound based on the original arguments passed to the target when it was built, and
             the other registrations in the <see cref="T:Rezolver.ITargetContainer"/> that's active when compilation occurs.
             
             This target is used to implement [constructor injection](/developers/docs/constructor-injection/index.html).
             </remarks>
        </member>
        <member name="P:Rezolver.Targets.ConstructorTarget.Ctor">
             <summary>
             Can be null. Gets the constructor that this target is bound to, if it was known when the target
             was created.
             </summary>
             <remarks>ConstructorTargets can be bound to a particular constructor
             in advance, or they can search for a best-match constructor at the point where
             <see cref="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> is called.
            
             This property will only be set ultimately if it was passed to the
             <see cref="M:Rezolver.Targets.ConstructorTarget.#ctor(System.Reflection.ConstructorInfo,Rezolver.ParameterBinding[],Rezolver.IMemberBindingBehaviour)"/>
             constructor, possibly by a factory method like <see cref="M:Rezolver.Target.ForConstructor(System.Reflection.ConstructorInfo,System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget},Rezolver.IMemberBindingBehaviour)"/>
             is captured within the expression.</remarks>
        </member>
        <member name="P:Rezolver.Targets.ConstructorTarget.ParameterBindings">
            <summary>
            If this target was created with a specific constructor then this might contain
            argument bindings for that constructor's parameters.
            </summary>
            <remarks>This is not the same as <see cref="P:Rezolver.Targets.ConstructorTarget.NamedArgs"/> - as is noted by the documentation
            on that property.  This property is for when the constructor is known in advance and when certain
            parameters are to be bound with specific arguments; whereas
            <see cref="P:Rezolver.Targets.ConstructorTarget.NamedArgs"/> is for when the constructor is not known.</remarks>
        </member>
        <member name="P:Rezolver.Targets.ConstructorTarget.MemberBindingBehaviour">
             <summary>
             Gets the member binding behaviour to be used when <see cref="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> is called.
            
             If <c>null</c>, then the binding behaviour will be resolved from <see cref="T:Rezolver.Compilation.ICompileContext"/> passed to the
             <see cref="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method, via the Options API.
             </summary>
             <remarks>The container default <see cref="T:Rezolver.IMemberBindingBehaviour"/> can be configured by setting it as an
             option using the <see cref="M:Rezolver.TargetContainerExtensions.SetOption``1(Rezolver.ITargetContainer,``0)"/>
             extension method - passing an instance of member binding behaviour to be used as the default.
            
             The global default, unconfigured, behaviour is not to inject any members
             (<see cref="P:Rezolver.MemberBindingBehaviour.BindNone"/>)</remarks>
        </member>
        <member name="P:Rezolver.Targets.ConstructorTarget.NamedArgs">
            <summary>
            Named arguments (as <see cref="T:Rezolver.ITarget"/> objects) to be supplied to the object on construction,
            also aiding the search for a constructor.  This equivalent to the way that languages such as C#
            can bind to overloaded functions based solely on named arguments.
            </summary>
            <remarks>Note the difference between this and <see cref="P:Rezolver.Targets.ConstructorTarget.ParameterBindings"/> - this
            property might be used when the constructor is not known in advance, whereas
            <see cref="P:Rezolver.Targets.ConstructorTarget.ParameterBindings"/> is used when it is.</remarks>
        </member>
        <member name="P:Rezolver.Targets.ConstructorTarget.DeclaredType">
            <summary>
            Implementation of <see cref="P:Rezolver.Targets.TargetBase.DeclaredType"/>.  Always equal to the
            type whose constructor will be bound by this target.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ConstructorTarget.ScopeBehaviour">
            <summary>
            Returns <see cref="F:Rezolver.ScopeBehaviour.None"/> if the type to be constructed is not disposable.  Strictly, this should also check for a public Dispose method.
            </summary>
        </member>
        <member name="M:Rezolver.Targets.ConstructorTarget.#ctor(System.Type,System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget},Rezolver.IMemberBindingBehaviour)">
             <summary>
             Initializes a just-in-time-bound instance of the <see cref="T:Rezolver.Targets.ConstructorTarget" /> class which must be bound
             to the best constructor at compile-time by calling the <see cref="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method.
             </summary>
             <param name="type">Required.  The type whose constructor is to bound.</param>
             <param name="namedArgs">Optional.  The named arguments which will be passed to, and used to find, the best-matched constructor.
             These are taken into account when the constructor is sought - with the constructor containing the most matched parameters matched being selected.</param>
             <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance.
             If not provided, then the <see cref="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method will attempt to obtain one via the options API from the
             <see cref="T:Rezolver.Compilation.ICompileContext"/> - and if one is still not available, then no member binding will be performed.</param>
             <remarks>To compile this target, a <see cref="T:Rezolver.Compilation.ITargetCompiler"/> first calls the <see cref="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method
             to discover the constructor to be executed, along with the final set of arguments to be provided to it (see <see cref="T:Rezolver.ConstructorBinding"/>).
            
             The best available constructor is defined as the constructor with the most parameters for which arguments can be resolved from the
             <see cref="T:Rezolver.Compilation.ICompileContext" /> at compile-time to the fewest number of <see cref="T:Rezolver.ITarget" /> objects whose <see cref="P:Rezolver.ITarget.UseFallback" />
             is false.
            
             *An extension point will be provided in the future which will allow the constructor resolution process to be overriden*
             </remarks>
        </member>
        <member name="M:Rezolver.Targets.ConstructorTarget.#ctor(System.Reflection.ConstructorInfo,Rezolver.ParameterBinding[],Rezolver.IMemberBindingBehaviour)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Targets.ConstructorTarget"/> class bound in advance to a specific constructor.
            </summary>
            <param name="ctor">Required - the constructor that is to be bound.  The <see cref="P:Rezolver.Targets.ConstructorTarget.DeclaredType"/> of the new instance
            will be set to the <see cref="P:System.Reflection.MemberInfo.DeclaringType"/> of this object.</param>
            <param name="parameterBindings">Optional.  Specific bindings for the parameters of the given <paramref name="ctor"/>
            which should be used during code generation.  Note that this array can contain fewer or more entries than there are
            parameters on the <paramref name="ctor"/>.  Any missing bindings will be automatically generated when <see cref="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/>
            is called.</param>
            <param name="memberBinding">Optional - provides an explicit member injection behaviour to be used when creating the instance.
            If not provided, then the <see cref="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method will attempt to obtain one via the options API from the
            <see cref="T:Rezolver.Compilation.ICompileContext"/> - and if one is still not available, then no member binding will be performed.</param>
        </member>
        <member name="M:Rezolver.Targets.ConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)">
             <summary>
             Gets the <see cref="T:Rezolver.ConstructorBinding"/> for the <see cref="P:Rezolver.Targets.ConstructorTarget.DeclaredType"/> using the
             targets available in the <paramref name="context"/> for dependency lookup.
            
             The constructor is either resolved by checking available targets for the best match, or is pre-selected
             on construction (<see cref="P:Rezolver.Targets.ConstructorTarget.Ctor"/> will be non-null in this case).
             </summary>
             <param name="context">The current compilation context.</param>
             <exception cref="T:System.Reflection.AmbiguousMatchException">If more than one constructor can be bound with an equal amount of all-resolved
             arguments or default arguments.</exception>
             <exception cref="T:System.InvalidOperationException">If no sutiable constructors can be found.</exception>
             <remarks>All implementations of <see cref="T:Rezolver.Compilation.ITargetCompiler"/> should first use this method to find
             the constructor to be called, and the arguments that are to be supplied to it.
            
             This method also builds a list of <see cref="T:Rezolver.MemberBinding"/>s for properties or fields on the type
             which are to be set with values from the container after construction.  The exact behaviour of this is
             controlled by the behaviour set on the <see cref="P:Rezolver.Targets.ConstructorTarget.MemberBindingBehaviour"/> property, or, if <c>null</c>
             then the method attempts to resolve an <see cref="T:Rezolver.IMemberBindingBehaviour"/> from the
             <see cref="P:Rezolver.ResolveContext.Container"/> of the <see cref="T:Rezolver.ResolveContext"/> set on the
             <see cref="P:Rezolver.Compilation.ICompileContext.ResolveContext"/> of the passed <paramref name="context"/>.</remarks>
        </member>
        <member name="T:Rezolver.Targets.DecoratingTargetFactory">
            <summary>
            Delegate type that is passed to the <see cref="T:Rezolver.Targets.DecoratorTarget"/> on construction to obtain
            a reference to an <see cref="T:Rezolver.ITarget"/> which, when compiled and executed, will produce an instance
            of the decorator object.
            </summary>
            <param name="decoratedTarget">The target whose result is to be decorated</param>
            <param name="decoratedType">The type being decorated.</param>
            <returns>An <see cref="T:Rezolver.ITarget"/> which, when compiled and executed correctly, will produce an instance of
            the decorator, with the instance produced by the <paramref name="decoratedTarget" /> as the decorated object
            inside of it.</returns>
        </member>
        <member name="T:Rezolver.Targets.DecoratorTarget">
             <summary>
             Represents the action of implementing a common <see cref="P:Rezolver.Targets.DecoratorTarget.DecoratedType"/> by decorating one instance
             (produced by <see cref="P:Rezolver.Targets.DecoratorTarget.DecoratedTarget"/>) with another (<see cref="P:Rezolver.Targets.DecoratorTarget.InnerTarget"/>).
            
             NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely
             know what you're doing.  Rather, decorators should be registered using the extension method
             <see cref="M:Rezolver.RootTargetContainerExtensions.RegisterDecorator``2(Rezolver.IRootTargetContainer)"/>
             or its non-generic alternative because the target needs a <see cref="T:Rezolver.DecoratingTargetContainer"/>
             to work properly (the creation of which is automatically handled by these extension methods).
             </summary>
             <seealso cref="T:Rezolver.Targets.TargetBase" />
        </member>
        <member name="P:Rezolver.Targets.DecoratorTarget.DeclaredType">
            <summary>
            The type of object returned by the decorator target
            </summary>
        </member>
        <member name="P:Rezolver.Targets.DecoratorTarget.ScopeBehaviour">
            <summary>
            Always returns the same behaviour as the <see cref="P:Rezolver.Targets.DecoratorTarget.InnerTarget"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.DecoratorTarget.InnerTarget">
            <summary>
            Gets the target which will create an instance of the decorator
            </summary>
        </member>
        <member name="P:Rezolver.Targets.DecoratorTarget.DecoratedTarget">
            <summary>
            Gets the target whose instance will be wrapped (decorated) by the one produced by
            <see cref="P:Rezolver.Targets.DecoratorTarget.InnerTarget"/>.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.DecoratorTarget.DecoratedType">
            <summary>
            Gets the underlying type (e.g. a common service interface or base) that is being implemented
            by decoration.
            </summary>
        </member>
        <member name="M:Rezolver.Targets.DecoratorTarget.#ctor(Rezolver.ITarget,Rezolver.ITarget,System.Type)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Targets.DecoratorTarget"/> type when the target that create the decorator is already known.
            </summary>
            <param name="decoratorTarget"></param>
            <param name="decoratedTarget"></param>
            <param name="decoratedType"></param>
        </member>
        <member name="M:Rezolver.Targets.DecoratorTarget.SupportsType(System.Type)">
            <summary>
            Overrides <see cref="M:Rezolver.Targets.TargetBase.SupportsType(System.Type)"/> to forward the call to <see cref="P:Rezolver.Targets.DecoratorTarget.InnerTarget"/>.
            </summary>
            <param name="type">The type which is to be checked.</param>
            <returns><c>true</c> if the type is compatible with the object created by <see cref="P:Rezolver.Targets.DecoratorTarget.InnerTarget"/>, <c>false</c>
            if not.</returns>
        </member>
        <member name="T:Rezolver.Targets.DefaultTarget">
            <summary>
            A target that simply creates a default instance of a given type.  I.e. the same
            as doing default(type) in C#.
            </summary>
            <remarks>The type also implements the <see cref="T:Rezolver.IInstanceProvider"/> interface for direct
            resolving.</remarks>
        </member>
        <member name="P:Rezolver.Targets.DefaultTarget.ScopeBehaviour">
            <summary>
            Override of <see cref="P:Rezolver.Targets.TargetBase.ScopeBehaviour"/> - always returns
            <see cref="F:Rezolver.ScopeBehaviour.None"/>.
            </summary>
            <value>The scope behaviour.</value>
        </member>
        <member name="P:Rezolver.Targets.DefaultTarget.DeclaredType">
            <summary>
            Always equal to the type for which the default value will be returned
            </summary>
        </member>
        <member name="P:Rezolver.Targets.DefaultTarget.Value">
            <summary>
            Gets the actual default value represented by this instance.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.DefaultTarget.Factory">
            <summary>
            Implementation of <see cref="P:Rezolver.IFactoryProvider.Factory"/>
            </summary>
        </member>
        <member name="M:Rezolver.Targets.DefaultTarget.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Targets.DefaultTarget"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="T:Rezolver.Targets.DelegateTarget">
             <summary>
             An <see cref="T:Rezolver.ITarget" /> which resolve objects by executing a delegate with argument injection.
             </summary>
             <remarks>The delegate must be non-void and can have any number of parameters.
            
             A compiler must ensure that any parameters for the <see cref="P:Rezolver.Targets.DelegateTarget.Factory"/> are automatically
             resolved from the container, and that a parameter of the type <see cref="T:Rezolver.ResolveContext"/>
             will receive the context passed to the <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/>
             method call for which this target is being compiled and/or executed.</remarks>
        </member>
        <member name="P:Rezolver.Targets.DelegateTarget.Factory">
            <summary>
            Gets the factory delegate that will be invoked when this target is compiled and executed
            </summary>
            <value>The factory.</value>
        </member>
        <member name="P:Rezolver.Targets.DelegateTarget.ScopeBehaviour">
            <summary>
            Overrides <see cref="P:Rezolver.Targets.TargetBase.ScopeBehaviour"/> to return the value that's passed on construction
            through the <see cref="M:Rezolver.Targets.DelegateTarget.#ctor(System.Delegate,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)"/>
            constructor.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.DelegateTarget.ScopePreference">
            <summary>
            Overrides <see cref="P:Rezolver.Targets.TargetBase.ScopePreference"/> to return the value that's passed on construction
            through the <see cref="M:Rezolver.Targets.DelegateTarget.#ctor(System.Delegate,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)"/>
            constructor.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.DelegateTarget.FactoryMethod">
            <summary>
            Gets the MethodInfo for the <see cref="P:Rezolver.Targets.DelegateTarget.Factory"/> delegate.
            </summary>
            <remarks>Whilst this can be easily obtained from the delegate yourself (by using the
            <see cref="M:System.Reflection.RuntimeReflectionExtensions.GetMethodInfo(System.Delegate)"/> extension method) however, this
            class also uses it to determine the <see cref="P:Rezolver.Targets.DelegateTarget.DeclaredType"/> of the target or whether the delegate
            is actually compatible with the one supplied on construction, therefore if you need to introspect
            the delegate, you might as well use this.</remarks>
        </member>
        <member name="P:Rezolver.Targets.DelegateTarget.DeclaredType">
            <summary>
            Gets the declared type of object that is constructed by this target, either set on
            construction or derived from the return type of the <see cref="P:Rezolver.Targets.DelegateTarget.Factory"/>
            </summary>
        </member>
        <member name="M:Rezolver.Targets.DelegateTarget.#ctor(System.Delegate,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Targets.DelegateTarget" /> class.
            </summary>
            <param name="factory">Required - the factory delegate.  Must have a return type and can take
            0 or more parameters.</param>
            <param name="declaredType">Optional - type that will be set into the <see cref="P:Rezolver.Targets.DelegateTarget.DeclaredType" /> for the target;
            if not provided, then it will be derived from the <paramref name="factory" />'s return type</param>
            <param name="scopeBehaviour">Scope behaviour for this delegate.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the delegate produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <exception cref="T:System.ArgumentException">If the <paramref name="factory" /> represents a void delegate or if
            <paramref name="declaredType" /> is passed but the type is not compatible with the return type of
            <paramref name="factory" />.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="factory" /> is null</exception>
        </member>
        <member name="T:Rezolver.Targets.EnumerableTarget">
            <summary>
            A specialised target for creating instances of <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.EnumerableTarget.DeclaredType">
            <summary>
            Always returns a concrete version of the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface type, with
            <c>T</c> equal to <see cref="P:Rezolver.Targets.EnumerableTarget.ElementType"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.EnumerableTarget.ScopeBehaviour">
            <summary>
            Always returns <see cref="F:Rezolver.ScopeBehaviour.None"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.EnumerableTarget.UseFallback">
            <summary>
            Returns <c>true</c> if <see cref="P:Rezolver.Targets.EnumerableTarget.Targets"/> is empty, otherwise <c>false</c>.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.EnumerableTarget.Targets">
            <summary>
            The targets whose objects will be included in the enumerable
            </summary>
        </member>
        <member name="P:Rezolver.Targets.EnumerableTarget.ElementType">
            <summary>
            The element type of the enumerable (i.e. the '<c>T</c>' in <see cref="T:System.Collections.Generic.IEnumerable`1"/>)
            </summary>
        </member>
        <member name="M:Rezolver.Targets.EnumerableTarget.#ctor(System.Collections.Generic.IEnumerable{Rezolver.ITarget},System.Type)">
            <summary>
            Creates a new instance of <see cref="T:Rezolver.Targets.EnumerableTarget"/>
            </summary>
            <param name="targets">Required.  Will be set into the <see cref="P:Rezolver.Targets.EnumerableTarget.Targets"/> property.  All elements must be non-null
            and must support the <paramref name="elementType"/> (verified by calling the <see cref="M:Rezolver.ITarget.SupportsType(System.Type)"/>
            method.</param>
            <param name="elementType">Required.  Will be set into the <see cref="P:Rezolver.Targets.EnumerableTarget.ElementType"/> property.  Must be a concrete type - that is,
            it must *not* be an open generic.</param>
        </member>
        <member name="M:Rezolver.Targets.EnumerableTarget.GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/> (through the <see cref="P:Rezolver.Targets.EnumerableTarget.Targets"/> property).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Targets.EnumerableTarget.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Targets.ExpressionTarget">
             <summary>
             A generic target for all expressions not explicitly supported by a particular target.
            
             Enables more complex behaviours to be registered and used with the more formal
             <see cref="T:Rezolver.ITarget"/> implementations.
             </summary>
             <remarks>Note to compiler implementers: This class can be used to represent simple
             expressions such as constants, constructor calls and so on; but can also contain whole
             lambda expressions with parameters.
            
             In the latter case, expression parameters are expected to receive injected arguments and,
             therefore, some rewriting of the expression is likely to be required.</remarks>
        </member>
        <member name="P:Rezolver.Targets.ExpressionTarget.Expression">
            <summary>
            Gets the static expression represented by this target - if <c>null</c>, then
            a factory is being used to produce the expression, which is available from
            the <see cref="P:Rezolver.Targets.ExpressionTarget.ExpressionFactory"/> property.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ExpressionTarget.ScopeBehaviour">
            <summary>
            Overrides <see cref="P:Rezolver.Targets.TargetBase.ScopeBehaviour"/> to return the value that's passed on construction.
            constructor.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ExpressionTarget.ScopePreference">
            <summary>
            Overrides <see cref="P:Rezolver.Targets.TargetBase.ScopePreference"/> to return the value that's passed on construction.
            constructor.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ExpressionTarget.DeclaredType">
            <summary>
            Gets the type of <see cref="P:Rezolver.Targets.ExpressionTarget.Expression"/> or the type that all expressions returned by the
            <see cref="P:Rezolver.Targets.ExpressionTarget.ExpressionFactory"/> are expected to be equal to.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ExpressionTarget.ExpressionFactory">
             <summary>
             Gets a factory which will be executed to obtain an expression given a particular <see cref="T:Rezolver.Compilation.ICompileContext"/>.
            
             If <c>null</c>, then a static expression will be used instead and is available
             from the <see cref="P:Rezolver.Targets.ExpressionTarget.Expression"/> property.
             </summary>
        </member>
        <member name="M:Rezolver.Targets.ExpressionTarget.#ctor(System.Linq.Expressions.Expression,System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Targets.ExpressionTarget" /> class.
            </summary>
            <param name="expression">Required. The static expression which should be used by compilers.</param>
            <param name="declaredType">Declared type of the target to be created (used when registering without
            an explicit type or when this target is used as a value inside another target).</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
            <remarks><paramref name="declaredType"/> will automatically be determined if not provided
            by examining the type of the <paramref name="expression"/>.  For lambdas, the type will
            be derived from the Type of the lambda's body.  For all other expressions, the type is
            taken directly from the Type property of the expression itself.</remarks>
        </member>
        <member name="M:Rezolver.Targets.ExpressionTarget.#ctor(System.Func{Rezolver.Compilation.ICompileContext,System.Linq.Expressions.Expression},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Targets.ExpressionTarget"/> class.
            </summary>
            <param name="expressionFactory">Required. The factory delegate that a compiler should call to get the expression to use when
            compiling this target.</param>
            <param name="declaredType">Required. Static type of all expressions that will be
            returned by <paramref name="expressionFactory"/>.</param>
            <param name="scopeBehaviour">Scope behaviour for this expression.  The default is <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>, which means
            that that any returned instance will be tracked implicitly by the active scope.  If the expression produces a new instance, then 
            this or <see cref="F:Rezolver.ScopeBehaviour.Explicit"/> can be used safely - the choice being whether
            the expression should produce one instance per scope, or should act as a disposable transient object.</param>
            <param name="scopePreference">If <paramref name="scopeBehaviour"/> is not <see cref="F:Rezolver.ScopeBehaviour.None"/>, then this controls
            the preferred scope for the instance to be tracked.  Defaults to <see cref="F:Rezolver.ScopePreference.Current"/></param>
        </member>
        <member name="T:Rezolver.Targets.GenericConstructorTarget">
             <summary>
             Equivalent of <see cref="T:Rezolver.Targets.ConstructorTarget"/> but for open generic types.
            
             So, this will handle the open generic MyType&lt;,&gt;, for example, whereas <see cref="T:Rezolver.Targets.ConstructorTarget"/>
             would handle the closed type MyType&lt;int, string&gt;.
             </summary>
             <seealso cref="T:Rezolver.Targets.TargetBase" />
        </member>
        <member name="T:Rezolver.Targets.GenericConstructorTarget.ITypeArgGenericMismatch">
            <summary>
            base interface only for <see cref="T:Rezolver.Targets.GenericConstructorTarget.ITypeArgGenericMismatch`4"/>
            just to simplify type testing
            </summary>
        </member>
        <member name="T:Rezolver.Targets.GenericConstructorTarget.ITypeArgGenericMismatch`4">
            <summary>
            Used purely to carry diagnostic information when type arguments aren't mapped successfully
            </summary>
            <typeparam name="TFrom">The type argument mapped from a target's <see cref="P:Rezolver.Targets.GenericConstructorTarget.DeclaredType"/> corresponding to the argument that can't be mapped</typeparam>
            <typeparam name="TFromParent">The generic type which declares the type parameter <typeparamref name="TFrom"/></typeparam>
            <typeparam name="TTo">The type argument in the type for which a match was sought</typeparam>
            <typeparam name="TToParent">The generic type which declared the type parameter <typeparamref name="TTo"/></typeparam>
        </member>
        <member name="T:Rezolver.Targets.GenericConstructorTarget.INotGeneric">
            <summary>
            Another diagnostic-only interface.  Used for TFromParent and TToParent type arguments in the
            <see cref="T:Rezolver.Targets.GenericConstructorTarget.ITypeArgGenericMismatch`4"/> type when a type parameter
            wasn't generic.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.GenericConstructorTarget.GenericType">
            <summary>
            Gets the generic type definition from which generic types are to be built and instances of which
            will be constructed.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Rezolver.Targets.GenericConstructorTarget.GenericTypeConstructor">
            <summary>
            If supplied on construction, then this is a constructor declared on the <see cref="P:Rezolver.Targets.GenericConstructorTarget.GenericType"/> which is to be
            used for every instance that is created.
            </summary>
            <remarks>When set, the <see cref="P:Rezolver.Targets.GenericConstructorTarget.GenericType"/> is derived from the <see cref="P:System.Reflection.MemberInfo.DeclaringType"/> of this
            reference.</remarks>
        </member>
        <member name="P:Rezolver.Targets.GenericConstructorTarget.MemberBindingBehaviour">
            <summary>
            Gets the member binding behaviour to be used when creating an instance.  The rules for this are the same as for
            <see cref="P:Rezolver.Targets.ConstructorTarget.MemberBindingBehaviour"/>.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.GenericConstructorTarget.DeclaredType">
            <summary>
            Implementation of the abstract base property.  Will return the unbound generic type passed to this object on construction.
            </summary>
        </member>
        <member name="M:Rezolver.Targets.GenericConstructorTarget.#ctor(System.Type,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> for the given open generic type,
            which will utilise the optional <paramref name="memberBinding"/> when it constructs its
            <see cref="T:Rezolver.Targets.ConstructorTarget"/> when <see cref="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> is called.
            </summary>
            <param name="genericType">Required. The type of the object that is to be built (open generic of course)</param>
            <param name="memberBinding">Optional. Provides an explicit member injection behaviour to be used when creating the instance.
            If not provided, then the <see cref="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method will attempt to obtain one via the options API from the
            <see cref="T:Rezolver.Compilation.ICompileContext"/> - and if one is still not available, then no member binding will be performed.</param>
        </member>
        <member name="M:Rezolver.Targets.GenericConstructorTarget.#ctor(System.Reflection.ConstructorInfo,Rezolver.IMemberBindingBehaviour)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> type.
            </summary>
            <param name="genericConstructor">Required. The constructor on a generic type definition that will be used for
            each concrete generic instance produced by this target.  Must be a member of a generic type definition that is
            neither an abstract class or interface.</param>
            <param name="memberBinding">Optional. Provides an explicit member injection behaviour to be used when creating the instance.
            If not provided, then the <see cref="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)"/> method will attempt to obtain one via the options API from the
            <see cref="T:Rezolver.Compilation.ICompileContext"/> - and if one is still not available, then no member binding will be performed.</param>
        </member>
        <member name="M:Rezolver.Targets.GenericConstructorTarget.SupportsType(System.Type)">
             <summary>
             Override - introduces additional logic to cope with generic types not generally supported by the majority of other targets.
            
             This uses the <see cref="M:Rezolver.Targets.GenericConstructorTarget.MapType(System.Type)"/> function to determine success, but only checks the <see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/>
             flag.  As a result, this method will return true if an open generic base or interface of <see cref="P:Rezolver.Targets.GenericConstructorTarget.DeclaredType"/>
             </summary>
             <param name="type"></param>
             <returns></returns>
        </member>
        <member name="M:Rezolver.Targets.GenericConstructorTarget.MapType(System.Type)">
             <summary>
             Maps the <see cref="P:Rezolver.Targets.GenericConstructorTarget.DeclaredType"/> open generic type to the <paramref name="targetType"/>.
            
             Examine the <see cref="P:Rezolver.Runtime.GenericTypeMapping.Success"/> of the result to check whether the
             result was successful.
             </summary>
             <param name="targetType">Type of the target.</param>
        </member>
        <member name="M:Rezolver.Targets.GenericConstructorTarget.Bind(Rezolver.Compilation.ICompileContext)">
             <summary>
             Obtains an <see cref="T:Rezolver.ITarget"/> (usually a <see cref="T:Rezolver.Targets.ConstructorTarget"/>) which will create
             an instance of a generic type (whose definition is equal to <see cref="P:Rezolver.Targets.GenericConstructorTarget.GenericType"/>) with
             generic arguments set correctly according to the <see cref="P:Rezolver.Compilation.ICompileContext.TargetType"/> of
             the <paramref name="context"/>.
             </summary>
             <param name="context">The context.</param>
             <remarks>The process of binding a requested type to the concrete type can be very complex, when
             inheritance chains and interface implementation maps are taken into account.
            
             At the simplest end of the spectrum, if <see cref="P:Rezolver.Targets.GenericConstructorTarget.GenericType"/> is <c>MyGeneric&lt;&gt;</c> and
             the <paramref name="context"/>'s <see cref="P:Rezolver.Compilation.ICompileContext.TargetType"/> is <c>MyGeneric&lt;int&gt;</c>,
             then this function merely has to insert the <c>int</c> type as the generic parameter to the <c>MyGeneric&lt;&gt;</c>
             type definition, bake a new type and create an auto-bound <see cref="T:Rezolver.Targets.ConstructorTarget"/>.
            
             Consider what happens, however, when the inheritance chain is more complex:
            
             <code>
             interface IMyInterfaceCore&lt;T, U&gt; { }
            
             class MyBaseClass&lt;T, U&gt; : IMyInterfaceCore&lt;U, T&gt; { }
            
             class MyDerivedClass&lt;T, U&gt; : MyBaseClass&lt;U, T&gt; { }
             </code>
            
             A <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> bound to the generic type definition <c>MyDerivedClass&lt;,&gt;</c> can
             create instances not only of any generic type based on that definition, but also any generic type based on the definitions
             of either it's immediate base, or that base's interface.  In order to do so, however, the parameters must be mapped
             between the generic type definitions so that if an instance of <c>MyBaseClass&lt;string, int&gt;</c> is requested,
             then an instance of <c>MyDerivedClass&lt;int, string&gt;</c> (note the arguments are reversed) is actually created.
            
             Similarly, if an instance of <c>IMyInterface&lt;string, int&gt;</c> is requested, we actually need to create an
             instance of <c>MyDerivedClass&lt;string, int&gt;</c> - because the generic arguments are reversed first through
             the base class inheritance, and then again by the base class' implementation of the interface.
            
             Note that a <see cref="T:Rezolver.Targets.GenericConstructorTarget"/> can only bind to the context's target type if there is enough information
             in order to deduce the generic type arguments for <see cref="P:Rezolver.Targets.GenericConstructorTarget.GenericType"/>.  This means, in general, that the requested
             type will almost always need to be a generic type with at least as many type arguments as the <see cref="P:Rezolver.Targets.GenericConstructorTarget.GenericType"/>.
             </remarks>
        </member>
        <member name="P:Rezolver.Targets.GenericConstructorTarget.GenericParameterMapping.Index">
            <summary>
            Gets or sets the index of the mapper parameter in the array of type parameters for <see cref="P:Rezolver.Targets.GenericConstructorTarget.GenericParameterMapping.BaseType"/>
            </summary>
            <value>The index.</value>
        </member>
        <member name="P:Rezolver.Targets.GenericConstructorTarget.GenericParameterMapping.BaseTypeArgument">
            <summary>
            Gets or sets the type argument in <see cref="P:Rezolver.Targets.GenericConstructorTarget.GenericParameterMapping.BaseType"/> represented by this mapping.
            </summary>
            <value>The base type parameter.</value>
        </member>
        <member name="P:Rezolver.Targets.GenericConstructorTarget.GenericParameterMapping.BaseType">
            <summary>
            Gets or sets the type to which this mapping relates.  The type will be a base or interface of the <see cref="P:Rezolver.Targets.GenericConstructorTarget.DeclaredType"/>
            </summary>
            <value>The type of the base.</value>
        </member>
        <member name="M:Rezolver.Targets.GenericConstructorTarget.DeepSearchTypeParameterMapping(System.Collections.Generic.Stack{Rezolver.Targets.GenericConstructorTarget.GenericParameterMapping},System.Type,System.Type)">
            <summary>
            Returns a series of type parameter indexes from the baseType parameter which can be used to derive
            the concrete type parameter to be used in a target type, given a fully-closed generic type as the model
            </summary>
            <param name="previousTypeParameterPositions"></param>
            <param name="baseTypeParameter"></param>
            <param name="targetTypeParameter"></param>
            <returns></returns>
        </member>
        <member name="T:Rezolver.Targets.ListTarget">
             <summary>
             This target produces arrays (<see cref="P:Rezolver.Targets.ListTarget.AsArray"/> = <c>true</c>) or lists (<see cref="P:Rezolver.Targets.ListTarget.AsArray"/> = <c>false</c>) whose
             individual items are built by ITarget instances.
             
             Note that this target is *not* used in Rezolver's implementation of <see cref="T:System.Collections.Generic.IEnumerable`1"/> injection.
             </summary>
             <remarks>
             The element type you feed on construction determines the type of array or the generic argument to List&lt;T&gt;.
            
             Each of the rezolve targets that you then pass must support that type.
             </remarks>
        </member>
        <member name="P:Rezolver.Targets.ListTarget.ScopeBehaviour">
            <summary>
            Always returns <see cref="F:Rezolver.ScopeBehaviour.None"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ListTarget.ElementType">
             <summary>
             Gets the declared type of each element in the array or list that will be constructed.
            
             The <see cref="P:Rezolver.Targets.ListTarget.DeclaredType"/> returned by this instance will either be <c>ElementType[]</c> or <c>List&lt;ElementType&gt;</c>
             depending on the value of <see cref="P:Rezolver.Targets.ListTarget.AsArray"/>.
             </summary>
             <value>The declared type of each element.</value>
        </member>
        <member name="P:Rezolver.Targets.ListTarget.DeclaredType">
            <summary>
            Implementation of the abstract property from the base.  This will always return either a type equal to an array of <see cref="P:Rezolver.Targets.ListTarget.ElementType"/>,
            or <see cref="T:System.Collections.Generic.List`1"/> with <see cref="P:Rezolver.Targets.ListTarget.ElementType"/> as the generic parameter.  This is controlled by the <see cref="P:Rezolver.Targets.ListTarget.AsArray"/> property.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ListTarget.UseFallback">
            <summary>
            Returns true if the <see cref="P:Rezolver.Targets.ListTarget.Items"/> enumerable is empty.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ListTarget.Items">
            <summary>
            Gets the rezolve targets that will build each individual item in the resulting list or array.
            </summary>
            <value>The items.</value>
        </member>
        <member name="P:Rezolver.Targets.ListTarget.AsArray">
            <summary>
            Gets a value indicating whether the target will build an array (<c>true</c>) or a list (<c>false</c>).
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ListTarget.ListConstructor">
            <summary>
            Gets the list constructor to be invoked when <see cref="P:Rezolver.Targets.ListTarget.AsArray"/> is false.
            </summary>
            <value>The list constructor.</value>
            <exception cref="T:System.InvalidOperationException">
            Since this target is configured to build an array, getting the ListConstructor is not a valid operation.
            </exception>
        </member>
        <member name="M:Rezolver.Targets.ListTarget.#ctor(System.Type,System.Collections.Generic.IEnumerable{Rezolver.ITarget},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Targets.ListTarget" /> class.
            </summary>
            <param name="elementType">Required. Type of the elements in the array or list.</param>
            <param name="items">Required. The targets that will create each the individual items.</param>
            <param name="asArray">A boolean indicating whether the target will build an array (<c>true</c>) or a list (<c>false</c>).</param>
            <exception cref="T:System.ArgumentNullException">
            elementType
            or
            items
            </exception>
            <exception cref="T:System.ArgumentException">
            All targets in the items enumerable must be non-null;items
            or
            All targets in the items enumerable must support the element type <paramref name="elementType"/></exception>
        </member>
        <member name="T:Rezolver.Targets.NullaryDelegateTarget">
             <summary>
             A special delegate target which explicitly allows direct resolving (via <see cref="T:Rezolver.IDirectTarget"/>) without compilation.
            
             Created by the factory and registration functions e.g. <see cref="M:Rezolver.Target.ForDelegate``1(System.Func{Rezolver.ResolveContext,``0},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)"/>
             or <see cref="M:Rezolver.TargetContainerExtensions.RegisterDelegate``1(Rezolver.ITargetContainer,System.Func{Rezolver.ResolveContext,``0},System.Type,Rezolver.ScopeBehaviour,Rezolver.ScopePreference)"/>.
             </summary>
        </member>
        <member name="T:Rezolver.Targets.ObjectTarget">
            <summary>
            Implements <see cref="T:Rezolver.ITarget"/> by wrapping a single instance that's already been constructed by application code.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ObjectTarget.ScopeBehaviour">
            <summary>
            Gets the scope behaviour.
            </summary>
            <value>The scope behaviour.</value>
        </member>
        <member name="P:Rezolver.Targets.ObjectTarget.ScopePreference">
            <summary>
            Always returns <see cref="F:Rezolver.ScopePreference.Root"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ObjectTarget.DeclaredType">
            <summary>
            Gets the declared type of object that is returned by this target.  Might be different from the type
            of <see cref="P:Rezolver.Targets.ObjectTarget.Value"/> if explicitly defined when this target was constructed.
            </summary>
            <value>The type of the declared.</value>
        </member>
        <member name="P:Rezolver.Targets.ObjectTarget.Value">
            <summary>
            Gets the value that will be exposed by expressions built by this instance.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:Rezolver.Targets.ObjectTarget.#ctor(System.Object,System.Type,Rezolver.ScopeBehaviour)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.Targets.ObjectTarget"/> class.
            </summary>
            <param name="obj">The object to be returned by this target when resolved.</param>
            <param name="declaredType">Optional.  The declared type of this target, if different from the absolute type of the <paramref name="obj"/></param>
            <param name="scopeBehaviour">Optional.  If you want the object to be disposed by Rezolver when the root scope is disposed, then
            specify a behaviour other than the default.  Note - the only real behaviour that makes sense for this is <see cref="F:Rezolver.ScopeBehaviour.Explicit"/>,
            since the Implicit behaviour will typically fool a scope that multiple instances are being created and, therefore, the object
            will be tracked multiple times by that scope.</param>
            <remarks>Please note - if you enable scope tracking, but the object is never resolved, then the object will not be disposed and you will need
            to ensure you dispose of it.</remarks>
        </member>
        <member name="P:Rezolver.Targets.ObjectTarget.Rezolver#IFactoryProvider#Factory">
            <summary>
            Implementation of <see cref="P:Rezolver.IFactoryProvider.Factory"/>
            </summary>
            <returns>A factory delegate which returns the <see cref="P:Rezolver.Targets.ObjectTarget.Value"/></returns>
        </member>
        <member name="T:Rezolver.Targets.OptionalParameterTarget">
             <summary>
             Used specifically when binding arguments to method parameters when a parameter is optional and its
             default value is to be used when binding to it.
            
             It is highly unlikely you'll ever create one of these directly.
             </summary>
        </member>
        <member name="P:Rezolver.Targets.OptionalParameterTarget.DeclaredType">
            <summary>
            Always returns the <see cref="P:System.Reflection.ParameterInfo.ParameterType"/> of the <see cref="P:Rezolver.Targets.OptionalParameterTarget.MethodParameter"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.OptionalParameterTarget.ScopeBehaviour">
            <summary>
            Always returns <see cref="F:Rezolver.ScopeBehaviour.None"/>
            </summary>
            <value>The scope behaviour.</value>
        </member>
        <member name="P:Rezolver.Targets.OptionalParameterTarget.UseFallback">
            <summary>
            Always returns true, since using a default argument of a parameter is always considered
            to be a last-resort.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.OptionalParameterTarget.MethodParameter">
            <summary>
            The parameter to which this target is bound.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.OptionalParameterTarget.Value">
            <summary>
            Gets the value represented by this target.  This is either the default value of the
            <see cref="P:Rezolver.Targets.OptionalParameterTarget.MethodParameter"/>, if applicable, or the default for the parameter type.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:Rezolver.Targets.OptionalParameterTarget.#ctor(System.Reflection.ParameterInfo)">
             <summary>
             Constructs a new instance of the <see cref="T:Rezolver.Targets.OptionalParameterTarget"/> class.
             </summary>
             <param name="methodParameter">Required - parameter to which this target will be bound.
            
             Its <see cref="P:System.Reflection.ParameterInfo.IsOptional"/> property must be <c>true</c> otherwise an <see cref="T:System.ArgumentException"/> is thrown.</param>
        </member>
        <member name="T:Rezolver.Targets.ProjectionTarget">
             <summary>
             Target that represents the projection of an individual object of type <see cref="P:Rezolver.Targets.ProjectionTarget.InputType"/>
             into an object of type <see cref="P:Rezolver.Targets.ProjectionTarget.OutputType"/>.
            
             Created automatically by the <see cref="T:Rezolver.ProjectionTargetContainer"/>.
             </summary>
        </member>
        <member name="P:Rezolver.Targets.ProjectionTarget.ScopeBehaviour">
            <summary>
            Always returns <see cref="F:Rezolver.ScopeBehaviour.None"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ProjectionTarget.DeclaredType">
            <summary>
            Always returns <see cref="P:Rezolver.Targets.ProjectionTarget.OutputType"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ProjectionTarget.ImplementationType">
            <summary>
            The type of object that is to be created by the <see cref="P:Rezolver.Targets.ProjectionTarget.OutputTarget"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ProjectionTarget.InputTarget">
            <summary>
            The target whose result is being projected by the <see cref="P:Rezolver.Targets.ProjectionTarget.OutputTarget"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ProjectionTarget.InputType">
            <summary>
            The element type of the enumerable from which the <see cref="P:Rezolver.Targets.ProjectionTarget.InputTarget"/> was obtained.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ProjectionTarget.OutputTarget">
             <summary>
             The target which produces the projected object from the result of the <see cref="P:Rezolver.Targets.ProjectionTarget.InputTarget"/>.
            
             The expectation is that it has a dependency on an instance of <see cref="P:Rezolver.Targets.ProjectionTarget.InputType"/> (e.g. via
             a parameter on a constructor or delegate etc).
             </summary>
        </member>
        <member name="P:Rezolver.Targets.ProjectionTarget.OutputType">
            <summary>
            The element type of the enumerable into which the result of the <see cref="P:Rezolver.Targets.ProjectionTarget.OutputTarget"/>
            will go.
            </summary>
        </member>
        <member name="M:Rezolver.Targets.ProjectionTarget.#ctor(Rezolver.ITarget,Rezolver.ITarget,System.Type,System.Type,System.Type)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Targets.ProjectionTarget"/> class.
            </summary>
            <param name="inputTarget">The target whose result is being projected by the <paramref name="outputTarget"/></param>
            <param name="outputTarget">The target which produces the projected object from the result of the <paramref name="inputTarget"/></param>
            <param name="inputType">The element type of the enumerable from which the <paramref name="inputTarget"/> was obtained</param>
            <param name="outputType">The element type of the enumerable into which the result of the <paramref name="outputTarget"/> will go.</param>
            <param name="implementationType">The type of object that is to be created by the <paramref name="outputTarget"/></param>
        </member>
        <member name="T:Rezolver.Targets.ResolvedTarget">
             <summary>
             Represents a target that is rezolved statically at compile time via the <see cref="T:Rezolver.Compilation.ICompileContext"/>, or dynamically
             (at 'resolve time') from the <see cref="T:Rezolver.Container"/> that is attached to the current <see cref="T:Rezolver.ResolveContext"/> when
             <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> is called.
            
             This is the most common way that we bind constructor parameters, for example - i.e. 'I want an
             <c>IService</c> instance - go get it'.
             </summary>
             <remarks>Represents an object that will be resolved from the container when a factory into which this target is compiled,
             or when the target is used perhaps by another <see cref="T:Rezolver.ITarget"/> (e.g. - a <see cref="T:Rezolver.Targets.ConstructorTarget"/> with a
             constructor parameter bound to one of these).
            
             So, in essence, a <see cref="T:Rezolver.Targets.ResolvedTarget"/> represents an automatic call to a container's
             <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> method, for the <see cref="P:Rezolver.Targets.ResolvedTarget.DeclaredType"/>.
            
             In practise - an <see cref="T:Rezolver.Compilation.ITargetCompiler"/> might take advantage of the fact that, during compilation, targets
             can be discovered directly from the <see cref="T:Rezolver.Compilation.ICompileContext"/> that is passed to
             <see cref="M:Rezolver.Compilation.ITargetCompiler.CompileTarget(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)"/> by leveraging its <see cref="T:Rezolver.ITargetContainer"/>
             implementation.
            
             Indeed - the expressions compiler uses this to avoid repeated recursion into the Resolve method of the container, instead
             choosing to compile all the expressions for all targets required for an operation into one dynamically built method -
             which results in very fast execution times for all resolve operations.
            
             Not only this, but the behaviour can be extended still further by realising that a container
             on which a resolve operation is invoked might not be the same container for which this <see cref="T:Rezolver.Targets.ResolvedTarget"/> was
             first compiled.  In this case - it's possible that the other container has alternative registrations for a given service
             type which the application expects to take precedence over those which were originally resolved when compilation took
             place.  The expressions compiler, again, detects this - allowing compiled code from a root container to detect an
             'overriding' container and to dynamically resolve a different dependency in this situation.
             </remarks>
        </member>
        <member name="P:Rezolver.Targets.ResolvedTarget.DeclaredType">
            <summary>
            The type that is to be resolved from the container at resolve-time.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.ResolvedTarget.ScopeBehaviour">
            <summary>
            Always returns <see cref="F:Rezolver.ScopeBehaviour.None"/>
            </summary>
            <value>The scope behaviour.</value>
        </member>
        <member name="P:Rezolver.Targets.ResolvedTarget.FallbackTarget">
             <summary>
             Gets the target that this <see cref="T:Rezolver.Targets.ResolvedTarget"/> will fallback to if a satisfactory target cannot be found
             at compile time or resolve-time.
             </summary>
             <remarks>The <see cref="P:Rezolver.ITarget.UseFallback"/> property is also used to determine whether this will be
             used.  If the target resolved from the <see cref="T:Rezolver.Compilation.ICompileContext"/> has its <see cref="P:Rezolver.ITarget.UseFallback"/>
             property set to true, and this property is non-null for this target, then this target will be used.
            
             Note also that extension containers such as <see cref="T:Rezolver.OverridingContainer"/> also have the ability to override
             the use of this fallback if they successfully resolve the type.
             </remarks>
        </member>
        <member name="M:Rezolver.Targets.ResolvedTarget.#ctor(System.Type,Rezolver.ITarget)">
            <summary>
            Creates a new <see cref="T:Rezolver.Targets.ResolvedTarget"/> for the given <paramref name="type"/> which will attempt to
            resolve a value at compile time and/or resolve-time and, if it can't, will either use the <paramref name="fallbackTarget"/>
            or will throw an exception.
            </summary>
            <param name="type">Required.  The type to be resolved</param>
            <param name="fallbackTarget">Optional.  The target to be used if the value cannot be resolved at either compile time or
            resolve-time.  An <see cref="T:System.ArgumentException"/> is thrown if this target's <see cref="M:Rezolver.ITarget.SupportsType(System.Type)"/>
            function returns <c>false</c> when called with the <paramref name="type"/>.</param>
        </member>
        <member name="M:Rezolver.Targets.ResolvedTarget.Bind(Rezolver.Compilation.ICompileContext)">
             <summary>
             Attempts to obtain the target that this <see cref="T:Rezolver.Targets.ResolvedTarget"/> resolves to for the given <see cref="T:Rezolver.Compilation.ICompileContext"/>.
            
             This function should be used by <see cref="T:Rezolver.Compilation.ITargetCompiler"/> implementations when compiling factories which included this
             instance, who wish to perform some form of up-front optimisations.
             </summary>
             <param name="context">The context from which a target is to be resolved.</param>
             <returns>The target resolved by this target - could be the <see cref="P:Rezolver.Targets.ResolvedTarget.FallbackTarget"/>, could be null.</returns>
             <remarks>The target that is returned depends both on the <paramref name="context"/> passed and also whether
             a <see cref="P:Rezolver.Targets.ResolvedTarget.FallbackTarget"/> has been provided to this target.
             </remarks>
        </member>
        <member name="T:Rezolver.Targets.ScopedTarget">
             <summary>
             A target that produces or fetches a single instance of an object within a lifetime scope.
             </summary>
             <remarks>Scopes in Rezolver operate much the same as they do in any IOC framework, but use
             of them is always entirely optional.
            
             When a scope is active for a given <see cref="M:Rezolver.Container.Resolve(Rezolver.ResolveContext)"/> operation, most
             objects which are returned from those operations will implicitly be scoped to whichever scope is active
             when the objects are resolved.  Implicitly scoped objects are only disposed of when their containing
             scope is disposed, and you can have an unlimited number of instances of implicitly scoped objects
             per scope.
            
             This target is used to scope the object produced by a target *explicitly* to a scope, and to ensure
             that only *one* instance of that object is produced per scope.  Such objects are also not inherited between
             parent scopes and child scopes.</remarks>
        </member>
        <member name="P:Rezolver.Targets.ScopedTarget.InnerTarget">
            <summary>
            Gets the inner target whose result (when compiled) will be scoped to the active scope.
            </summary>
            <value>The inner target.</value>
        </member>
        <member name="P:Rezolver.Targets.ScopedTarget.DeclaredType">
            <summary>
            Gets the declared type of object that is constructed by this target.
            </summary>
            <remarks>Always forwards the call on to <see cref="P:Rezolver.Targets.ScopedTarget.InnerTarget"/></remarks>
        </member>
        <member name="P:Rezolver.Targets.ScopedTarget.ScopeBehaviour">
            <summary>
            Always returns <see cref="F:Rezolver.ScopeBehaviour.None"/>
            </summary>
            <value>The scope behaviour.</value>
        </member>
        <member name="M:Rezolver.Targets.ScopedTarget.#ctor(Rezolver.ITarget)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Targets.ScopedTarget"/> class.
            </summary>
            <param name="innerTarget">Required.  The inner target.</param>
        </member>
        <member name="M:Rezolver.Targets.ScopedTarget.SupportsType(System.Type)">
            <summary>
            Called to check whether a target can create an expression that builds an instance of the given <paramref name="type" />.
            </summary>
            <param name="type">Required</param>
            <remarks>Always forwards the call on the <see cref="P:Rezolver.Targets.ScopedTarget.InnerTarget"/></remarks>
        </member>
        <member name="T:Rezolver.Targets.SingletonTarget">
             <summary>
             A target which applies the singleton pattern to any <see cref="T:Rezolver.ITarget"/>.
            
             The inner target is available from the <see cref="P:Rezolver.Targets.SingletonTarget.InnerTarget"/> property.
             </summary>
        </member>
        <member name="P:Rezolver.Targets.SingletonTarget.DeclaredType">
            <summary>
            Override of <see cref="P:Rezolver.Targets.TargetBase.DeclaredType"/> - always returns the DeclaredType of the <see cref="P:Rezolver.Targets.SingletonTarget.InnerTarget"/>
            </summary>
            <value>The type of the declared.</value>
        </member>
        <member name="P:Rezolver.Targets.SingletonTarget.ScopeBehaviour">
            <summary>
            Always returns the same behaviour as the <see cref="P:Rezolver.Targets.SingletonTarget.InnerTarget"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.SingletonTarget.ScopePreference">
            <summary>
            Always returns <see cref="F:Rezolver.ScopePreference.Root"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.SingletonTarget.InnerTarget">
            <summary>
            Gets the inner target for this singleton.
            </summary>
        </member>
        <member name="M:Rezolver.Targets.SingletonTarget.#ctor(Rezolver.ITarget)">
            <summary>
            Constructs a new instance of the <see cref="T:Rezolver.Targets.SingletonTarget"/> class.
            </summary>
            <param name="innerTarget">The target whose result (when compiled) is to be used as the singleton instance.</param>
        </member>
        <member name="M:Rezolver.Targets.SingletonTarget.SupportsType(System.Type)">
             <summary>
             Called to check whether a target can create an expression that builds an instance of the given <paramref name="type" />.
            
             The base implementation always passes the call on to the <see cref="P:Rezolver.Targets.SingletonTarget.InnerTarget"/>
             </summary>
             <param name="type">Required</param>
        </member>
        <member name="T:Rezolver.Targets.TargetBase">
            <summary>
            Abstract base class, suggested as a starting point for implementations of <see cref="T:Rezolver.ITarget"/>.
            </summary>
        </member>
        <member name="M:Rezolver.Targets.TargetBase.NextId">
            <summary>
            Gets the next available ID for a target.
            </summary>
            <remarks>
            This function is not generally intended to be called from your code.
            </remarks>
            <returns>The next application-unique ID available for a new target</returns>
        </member>
        <member name="P:Rezolver.Targets.TargetBase.Id">
             <summary>
             Implementation of <see cref="P:Rezolver.ITarget.Id"/>.  Unique Id for this target.
            
             Always initialised to a new <see cref="T:System.Guid"/> using <see cref="M:System.Guid.NewGuid"/>
             </summary>
        </member>
        <member name="P:Rezolver.Targets.TargetBase.UseFallback">
             <summary>
             Implementation of <see cref="P:Rezolver.ITarget.UseFallback"/>
            
             Base version always returns <c>false</c>.
             </summary>
        </member>
        <member name="P:Rezolver.Targets.TargetBase.DeclaredType">
            <summary>
            Gets the declared type of object that is constructed by this target.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.TargetBase.ScopeBehaviour">
            <summary>
            Gets the scoping behaviour for instances that will ultimately be produced by this target.
            </summary>
            <value>The scope behaviour.</value>
            <remarks>Base implementation always returns <see cref="F:Rezolver.ScopeBehaviour.Implicit"/>.</remarks>
        </member>
        <member name="P:Rezolver.Targets.TargetBase.ScopePreference">
            <summary>
            Get the preferred scope in which an object produced from this target should be tracked.
            </summary>
            <remarks>Base implementation always returns <see cref="F:Rezolver.ScopePreference.Current"/></remarks>
        </member>
        <member name="M:Rezolver.Targets.TargetBase.SupportsType(System.Type)">
             <summary>
             Implementation of <see cref="M:Rezolver.ITarget.SupportsType(System.Type)"/>. Returns a boolean indicating whether the target
             is able to produce an instance of, or an instance that is compatible with, the passed <paramref name="type" />.
             </summary>
             <param name="type">The type.</param>
             <remarks>It is strongly suggested that you use this method to check whether the target can construct
             an instance of a given type rather than performing any type checking yourself on the
             <see cref="P:Rezolver.Targets.TargetBase.DeclaredType" />, because an <see cref="T:Rezolver.ITarget" /> might be able to support a much wider
             range of types other than just those which are directly compatible with its <see cref="P:Rezolver.Targets.TargetBase.DeclaredType" />.
            
             For example, the <see cref="T:Rezolver.Targets.GenericConstructorTarget" /> is statically bound to an open generic, so therefore
             traditional type checks on the <see cref="P:Rezolver.Targets.TargetBase.DeclaredType" /> do not work.  That class' implementation of this
             method, however, contains the complex logic necessary to determine if the open generic can be closed into a
             generic type which is compatible with the given <paramref name="type" />.
            
             Implementations of <see cref="T:Rezolver.Compilation.ITargetCompiler" /> should always consult this function in their
             implementation of <see cref="M:Rezolver.Compilation.ITargetCompiler.CompileTarget(Rezolver.ITarget,Rezolver.Compilation.ICompileContext)" />
             to determine if the target is compatible with the <see cref="P:Rezolver.Compilation.CompileContext.TargetType" /> of the
             <see cref="T:Rezolver.Compilation.CompileContext" />
             </remarks>
        </member>
        <member name="M:Rezolver.Targets.TargetBase.ToString">
            <summary>
            Returns a string similar to <c>"&lt;[TargetType], DeclaredType=[DeclaredType]&gt;"</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rezolver.Targets.TargetBase.#ctor">
            <summary>
            Default constructor for derived types
            </summary>
        </member>
        <member name="M:Rezolver.Targets.TargetBase.#ctor(System.Int32)">
            <summary>
            Can be used by derived types to initialise the base with a specific ID.  Specifically used by targets which 'proxy' others,
            such as with the <see cref="T:Rezolver.Targets.VariantMatchTarget"/> etc.
            </summary>
            <param name="id"></param>
        </member>
        <member name="T:Rezolver.Targets.UnscopedTarget">
            <summary>
            Wraps another target to force scoping to be ignored for the object that it produces, regardless
            of whether that object is IDisposable or otherwise has its own scoping behaviour.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.UnscopedTarget.ScopeBehaviour">
            <summary>
            Always returns <see cref="F:Rezolver.ScopeBehaviour.None"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.UnscopedTarget.DeclaredType">
            <summary>
            Gets the declared type of object that is constructed by this target - always forwards the call
            to the <see cref="P:Rezolver.Targets.UnscopedTarget.Inner"/> target.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.UnscopedTarget.UseFallback">
            <summary>
            Implementation of <see cref="P:Rezolver.ITarget.UseFallback" />
            Always forwards the call to <see cref="P:Rezolver.Targets.UnscopedTarget.Inner"/> target.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.UnscopedTarget.Inner">
            <summary>
            Gets the inner target whose scoping rules are to be stripped by this target.
            </summary>
        </member>
        <member name="M:Rezolver.Targets.UnscopedTarget.#ctor(Rezolver.ITarget)">
            <summary>
            Initializes a new instance of the <see cref="T:Rezolver.Targets.UnscopedTarget"/> class.
            </summary>
            <param name="inner">Required - the inner target.</param>
        </member>
        <member name="M:Rezolver.Targets.UnscopedTarget.SupportsType(System.Type)">
            <summary>
            Always forward the call to the <see cref="P:Rezolver.Targets.UnscopedTarget.Inner"/> target's implementation.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="T:Rezolver.Targets.VariantMatchTarget">
            <summary>
            Target used to wrap another when matched against a service type contravariantly or covariantly.
            </summary>
            <remarks>This target is produced automatically by functionality such as 
            <see cref="M:Rezolver.RootTargetContainerExtensions.FetchAllCompatibleTargets(Rezolver.IRootTargetContainer,System.Type)"/> for any target
            whose registered type is not exactly the same as the type requested.  The target's identity (chiefly determined by 
            its <see cref="P:Rezolver.Targets.VariantMatchTarget.Id"/>) is always equal to the <see cref="P:Rezolver.Targets.VariantMatchTarget.Target"/> that it wraps, thus allowing it to masquerade as
            the wrapped target.</remarks>
        </member>
        <member name="P:Rezolver.Targets.VariantMatchTarget.Id">
            <summary>
            Always returns the <see cref="P:Rezolver.ITarget.Id"/> of the <see cref="P:Rezolver.Targets.VariantMatchTarget.Target"/>, since this target
            masquerades as the one that it wraps.
            </summary>
        </member>
        <member name="P:Rezolver.Targets.VariantMatchTarget.UseFallback">
            <summary>
            Returns the value of the same property returned by the <see cref="P:Rezolver.Targets.VariantMatchTarget.Target"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.VariantMatchTarget.DeclaredType">
            <summary>
            Returns the value of the same property returned by the <see cref="P:Rezolver.Targets.VariantMatchTarget.Target"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.VariantMatchTarget.ScopeBehaviour">
            <summary>
            Returns the value of the same property returned by the <see cref="P:Rezolver.Targets.VariantMatchTarget.Target"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.VariantMatchTarget.ScopePreference">
            <summary>
            Returns the value of the same property returned by the <see cref="P:Rezolver.Targets.VariantMatchTarget.Target"/>
            </summary>
        </member>
        <member name="P:Rezolver.Targets.VariantMatchTarget.RequestedType">
            <summary>
            Type originally requested
            </summary>
        </member>
        <member name="P:Rezolver.Targets.VariantMatchTarget.RegisteredType">
            <summary>
            Type against which the <see cref="P:Rezolver.Targets.VariantMatchTarget.Target"/> was found
            </summary>
        </member>
        <member name="P:Rezolver.Targets.VariantMatchTarget.Target">
            <summary>
            The <see cref="T:Rezolver.ITarget"/> that's wrapped by this target
            </summary>
        </member>
        <member name="M:Rezolver.Targets.VariantMatchTarget.SupportsType(System.Type)">
            <summary>
            Returns whether the <see cref="P:Rezolver.Targets.VariantMatchTarget.Target"/> supports the given <paramref name="type"/>
            </summary>
            <param name="type">The type to be checked for compatibility.</param>
            <returns><c>true</c> if the inner <see cref="P:Rezolver.Targets.VariantMatchTarget.Target"/> can build/obtain an instance
            of the given <paramref name="type"/>, otherwise <c>false.</c></returns>
        </member>
        <member name="T:Rezolver.TargetTypeSelector">
             <summary>
             Given a type, this produces an enumerable of all types to be sought from an <see cref="T:Rezolver.ITargetContainer"/>
             whose targets might produce a compatible instance.
            
             In particular, this class is responsible for handling generic type matching, including variance.
             </summary>
             <remarks>It's *highly unlikely* that you will ever need to use this type directly in an application.
            
             It's public because it could be useful to developers of components which extend Rezolver.
            
             Internally, the <see cref="T:Rezolver.GenericTargetContainer"/> uses this exclusively to perform searches for
             compatible target types if a requested type is generic.</remarks>
        </member>
        <member name="P:Rezolver.TargetTypeSelector.Type">
            <summary>
            The type for which compatible targets are sought.
            </summary>
        </member>
        <member name="P:Rezolver.TargetTypeSelector.RootTargets">
            <summary>
            The root-most <see cref="T:Rezolver.ITargetContainer"/> containing registrations to be sought,
            and the source of any configuration options.
            </summary>
        </member>
        <member name="F:Rezolver.TargetTypeSelector._results">
            <summary>
            for pre-cached results.
            </summary>
        </member>
        <member name="P:Rezolver.TargetTypeSelector.VariantMatches">
            <summary>
            Contains the set of types which have been projected from this instance which have been generated
            via contravariance or covariance.  
            </summary>
        </member>
        <member name="M:Rezolver.TargetTypeSelector.#ctor(System.Type,Rezolver.IRootTargetContainer)">
            <summary>
            Creates a new instance of the <see cref="T:Rezolver.TargetTypeSelector"/> type for the given
            <paramref name="type"/>.
            </summary>
            <param name="type">The type for which a list of search types is to be produced.</param>
            <param name="rootTargets">The root target container</param>
        </member>
        <member name="M:Rezolver.TargetTypeSelector.IsVariantMatch(System.Type,System.Type)">
            <summary>
            Returns true if the given type has been returned from a search as a result of a covariant or contravariant search
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rezolver.TargetTypeSelector.GetEnumerator">
            <summary>
            Implementation of <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rezolver.ExceptionResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.CyclicDependencyDetectedInTargetFormat">
            <summary>
              Looks up a localized string similar to Cyclic dependency detected in targets - current target of type {0} with DeclaredType of {1} has tried to include itself in its expression..
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.DeclaredTypeIsNotCompatible_Format">
            <summary>
              Looks up a localized string similar to The declared type {0} is not compatible with the type {1}.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.LambdaBodyIsNotNewExpressionFormat">
            <summary>
              Looks up a localized string similar to The body of the lambda &quot;{0}&quot; is not a NewExpression.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.LambdaBodyNewExpressionIsWrongTypeFormat">
            <summary>
              Looks up a localized string similar to The expression {0} does not represent calling a constructor of the type {1}.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.MoreThanOneBestConstructorFormat">
             <summary>
               Looks up a localized string similar to More than one constructor for {0} found that could be bound from the current context.
            
            Possible candidates:
            {1}.
             </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.MoreThanOneConstructorFormat">
            <summary>
              Looks up a localized string similar to More than one constructor for {0} qualifies as a target for Auto construction.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.MoreThanOneObjectFoundInScope">
            <summary>
              Looks up a localized string similar to More than one matching object was found in the scope.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.NoApplicableConstructorForContextFormat">
            <summary>
              Looks up a localized string similar to No constructor found on the type {0} which can be satisfied by the CompileContext.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.NoConstructorSetOnNewExpression">
            <summary>
              Looks up a localized string similar to No constructor has been set on the NewExpression - this is not allowed..
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.NoDefaultOrAllOptionalConstructorFormat">
            <summary>
              Looks up a localized string similar to The type {0} has no default constructor, nor any constructors where all the parameters are optional..
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.NoPublicConstructorsDefinedFormat">
            <summary>
              Looks up a localized string similar to No public constructors declared on the type {0}.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.NotRuntimeMethod">
            <summary>
              Looks up a localized string similar to This method is not to be called at run-time - it is only used for static expression analysis in creating IRezolveTargets for an IRezolveBuilder.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.PathIsAtEnd">
            <summary>
              Looks up a localized string similar to path&apos;s Next must not be null - pass path as null once it&apos;s reached the last item.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.PathIsInvalid">
            <summary>
              Looks up a localized string similar to The path {0} is invalid.  All path steps must contain non-whitespace characters and be at least one character in length.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.RezolverTargetEntryHasBeenRealised">
            <summary>
              Looks up a localized string similar to No more targets can be added to this entry.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.ScopedSingletonRequiresAScope">
            <summary>
              Looks up a localized string similar to A lifetime scope is required for a scoped singleton.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.TargetDoesntSupportType_Format">
            <summary>
              Looks up a localized string similar to The target does not support the type {0}.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.TargetIsNullButTypeIsNotNullable_Format">
            <summary>
              Looks up a localized string similar to The type {0} is not a nullable type.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.TargetReturnedNullExpressionFormat">
            <summary>
              Looks up a localized string similar to Target of type {0} returned a null expression for context {1} - implementation is invalid, targets must never return a null expression..
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.TypeIsAlreadyRegistered">
            <summary>
              Looks up a localized string similar to The type {0} has already been registered.
            </summary>
        </member>
        <member name="P:Rezolver.ExceptionResources.UnableToResolveTypeFromBuilderFormat">
            <summary>
              Looks up a localized string similar to Unable to resolve type {0} from builder.
            </summary>
        </member>
        <member name="T:Rezolver.ExpressionExtractor">
             <summary>
             Used to help grab method and constructor info from expressions (which is easier than writing long
             strings of reflection code).
            
             For example: <code>MethodCallExtractor.ExtractCalledMethod(() => Console.WriteLine("foo"))</code>
            
             Will return the MethodInfo for the <c>WriteLine</c> method of the <c>Console</c> class.
             </summary>
        </member>
        <member name="M:Rezolver.ExpressionExtractor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Visits the children of the <see cref="T:System.Linq.Expressions.MethodCallExpression" />.
            </summary>
            <param name="node">The expression to visit.</param>
        </member>
        <member name="M:Rezolver.ExpressionExtractor.VisitNew(System.Linq.Expressions.NewExpression)">
            <summary>
            Visits the children of the <see cref="T:System.Linq.Expressions.NewExpression" />.
            </summary>
            <param name="node">The expression to visit.</param>
        </member>
        <member name="M:Rezolver.Extract.Method``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Extracts the MethodInfo of the first method call found in the expression.
            </summary>
            <typeparam name="T">Allows the expression to declare a parameter to aid overload resolution, but doesn't
            actually have any material influence on the expression analysis.</typeparam>
            <param name="expr">The expression to be read</param>
            <returns>A MethodInfo representing the method - if the expression contains a method call; otherwise <c>null</c></returns>
        </member>
        <member name="M:Rezolver.Extract.Method(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Extracts the MethodInfo of the first method call found in the expression.
            </summary>
            <param name="expr">The expression to be read</param>
            <returns>A MethodInfo representing the method - if the expression contains a method call; otherwise <c>null</c></returns>
        </member>
        <member name="M:Rezolver.Extract.Method``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Extracts the MethodInfo of the first method call found in the expression.
            </summary>
            <typeparam name="TResult">Return type of the expression.  Not actually used in any way, it's just here to allow overload resolution
            when an expression represents a non-void function call</typeparam>
            <param name="expr">The expression to be read</param>
            <returns>A MethodInfo representing the method - if the expression contains a method call; otherwise <c>null</c></returns>
        </member>
        <member name="M:Rezolver.Extract.Method``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the MethodInfo of the first method call found in the expression.
            </summary>
            <typeparam name="TInstance">Allows the expression to declare a parameter to aid overload resolution, but doesn't
            actually have any material influence on the expression analysis.</typeparam>
            <typeparam name="TResult">Return type of the expression.  Not actually used in any way, it's just here to allow overload resolution
            when an expression represents a non-void function call</typeparam>
            <param name="expr">The expression to be read</param>
            <returns>A MethodInfo representing the method - if the expression contains a method call; otherwise <c>null</c></returns>
        </member>
        <member name="M:Rezolver.Extract.Constructor``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Extracts the ConstructorInfo of the first 'new' statement found in the expression
            </summary>
            <typeparam name="T">Allows the expression to declare a parameter to aid overload resolution, but doesn't
            actually have any material influence on the expression analysis.</typeparam>
            <param name="expr">The expression to be analysed.</param>
            <returns>A ConstructorInfo representing the constructor being called in the expression; otherwise <c>null</c> if not found.</returns>
        </member>
        <member name="M:Rezolver.Extract.Constructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Extracts the ConstructorInfo of the first 'new' statement found in the expression
            </summary>
            <param name="expr">The expression to be analysed.</param>
            <returns>A ConstructorInfo representing the constructor being called in the expression; otherwise <c>null</c> if not found.</returns>
        </member>
        <member name="M:Rezolver.Extract.Constructor``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Extracts the ConstructorInfo of the first 'new' statement found in the expression
            </summary>
            <typeparam name="TResult">Return type of the expression.  Not actually used in any way, it's just here to allow overload resolution
            when an expression represents a non-void function call</typeparam>
            <param name="expr">The expression to be analysed.</param>
            <returns>A ConstructorInfo representing the constructor being called in the expression; otherwise <c>null</c> if not found.</returns>
        </member>
        <member name="M:Rezolver.Extract.Constructor``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the ConstructorInfo of the first 'new' statement found in the expression
            </summary>
            <typeparam name="TInstance">Allows the expression to declare a parameter to aid overload resolution, but doesn't
            actually have any material influence on the expression analysis.</typeparam>
            <typeparam name="TResult">Return type of the expression.  Not actually used in any way, it's just here to allow overload resolution
            when an expression represents a non-void function call</typeparam>
            <param name="expr">The expression to be analysed.</param>
            <returns>A ConstructorInfo representing the constructor being called in the expression; otherwise <c>null</c> if not found.</returns>
        </member>
        <member name="T:Rezolver.LockedList`1">
            <summary>
            Simple implementation of a locked list - used in situations where random access is required over
            a collection of objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Rezolver.ObjectMemberValueExtensions.ObjectMemberValue">
            <summary>
            Used when reading objects to turn them into dictionaries.
            </summary>
        </member>
        <member name="P:Rezolver.ObjectMemberValueExtensions.ObjectMemberValue.Name">
            <summary>
            Gets the name of the object member (taken from the name of the fieldor property).
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Rezolver.ObjectMemberValueExtensions.ObjectMemberValue.Value">
             <summary>
             Gets the value of the property or field on the object that this was created for.
            
             If an exception occurred during the read, then <see cref="P:Rezolver.ObjectMemberValueExtensions.ObjectMemberValue.ValueError"/> will be <c>true</c>
             and this property will contain the exception that occurred.
             </summary>
        </member>
        <member name="P:Rezolver.ObjectMemberValueExtensions.ObjectMemberValue.ValueError">
            <summary>
            Gets a value indicating whether the <see cref="P:Rezolver.ObjectMemberValueExtensions.ObjectMemberValue.Value"/> is an exception that was raised when attempting
            to read the property or field.
            </summary>
        </member>
        <member name="P:Rezolver.ObjectMemberValueExtensions.ObjectMemberValue.Type">
            <summary>
            Gets the type of the object member.  Note - that's not the type of the <see cref="P:Rezolver.ObjectMemberValueExtensions.ObjectMemberValue.Value"/>,
            but the statically declared type of the field or property.
            </summary>
        </member>
        <member name="T:Rezolver.OrderedSet`1">
            <summary>
            Decent enough class from https://stackoverflow.com/a/17853085/157701
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Rezolver.TypeExtensions">
             <summary>
             Extensions for System.Type
            
             Note - these are specifically new functions added to Type by Rezolver,
             not 'ghost' extensions for the type members that are missing under certain
             compilation profiles.
            
             They are in the TypeHelpers static class.
             </summary>
        </member>
        <member name="M:Rezolver.TypeExtensions.GetBaseArrayTypes(System.Type)">
             <summary>
             Note - no verification.  if the type is not an array type, then bad
             things happen.  This method automatically handles a vector/multi-dim
             array type mismatch between vectors (0-based 1 dimensional array) and
             rank 1 multidimensional arrays as described here in this SO:
             https://stackoverflow.com/q/45693868
             (answered by GOAT Skeet of course).
            
             Note that the function only returns down to object[]: Array and Object
             are excluded.
             </summary>
             <param name="arrayType">The type</param>
             <returns>An enumerable of types representing the hierarchy of all array types
             to which an instance of the arrayType can be assigned.</returns>
        </member>
        <member name="M:Rezolver.TypeHelpers.MakeArrayType(System.Type,System.Nullable{System.Int32})">
            <summary>
            Note - will use non-rank overload of underlying MakeArrayType if rank is null
            </summary>
        </member>
        <member name="T:System.Collections.Generic.ReadOnlyEnumerableExtensions.ReadOnlyCollection`1">
            <summary>
            readonly wrapper for generic IEnumerables
            </summary>
            <typeparam name="T"></typeparam>
        </member>
    </members>
</doc>
